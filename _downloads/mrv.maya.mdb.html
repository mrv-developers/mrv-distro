<html>
<head>
<title>mrv.maya.mdb</title>
</head>
<body>
mrv.maya.mdb
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 345 lines<br/>
Missed: 231 lines<br/>
Skipped 365 lines<br/>
Percent: 59 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>Provides classes and functions operating on the MayaAPI class database</pre></div>
<div class="skip"><span class="num"><pre>  4</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>:note: This module must not be auto-initialized as it assumes its parent package to </pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>	be present already</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>:note: The implementation is considered internal and may change any time unless stated</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>	otherwise.</pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre> 11</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>from mrv.path import make_path</pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>from mrv.util import PipeSeparatedFile</pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>import mrv.maya.env as env</pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>import mrv.maya as mrvmaya</pre></div>
<div class="skip"><span class="num"><pre> 16</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>import maya.cmds as cmds</pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>import maya.OpenMaya as api</pre></div>
<div class="skip"><span class="num"><pre> 19</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 20</pre></span><pre>import UserDict</pre></div>
<div class="cov"><span class="num"><pre> 21</pre></span><pre>import inspect</pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>import re</pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>from cStringIO import StringIO</pre></div>
<div class="cov"><span class="num"><pre> 24</pre></span><pre>import string</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>import sys</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>import os</pre></div>
<div class="skip"><span class="num"><pre> 27</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>log = logging.getLogger(&quot;mrv.maya.mdb&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 30</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>__all__ = (&quot;createDagNodeHierarchy&quot;, &quot;createTypeNameToMfnClsMap&quot;, &quot;apiModules&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>           &quot;mfnDBPath&quot;, &quot;cacheFilePath&quot;, &quot;writeMfnDBCacheFiles&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>           &quot;extractMFnFunctions&quot;, &quot;PythonMFnCodeGenerator&quot;, &quot;MMemberMap&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>           &quot;MMethodDescriptor&quot; )</pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 36</pre></span><pre>#{ Initialization </pre></div>
<div class="skip"><span class="num"><pre> 37</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 38</pre></span><pre>def nodeHierarchyFile():</pre></div>
<div class="cov"><span class="num"><pre> 39</pre></span><pre>	&quot;&quot;&quot;:return: Path to the node hierarchy file of the currently active maya version&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 40</pre></span><pre>	return cacheFilePath( &quot;nodeHierarchy&quot;, &quot;hf&quot;, use_version = 1 )</pre></div>
<div class="skip"><span class="num"><pre> 41</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>def createDagNodeHierarchy( ):</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>	&quot;&quot;&quot; Parse the nodes hierarchy file and return a `DAGTree` with its data</pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>	:return: `DAGTree`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 45</pre></span><pre>	mfile = nodeHierarchyFile()</pre></div>
<div class="cov"><span class="num"><pre> 46</pre></span><pre>	return mrvmaya.dag_tree_from_tuple_list( mrvmaya.tuple_list_from_file( mfile ) )</pre></div>
<div class="skip"><span class="num"><pre> 47</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>def createTypeNameToMfnClsMap( ):</pre></div>
<div class="cov"><span class="num"><pre> 49</pre></span><pre>	&quot;&quot;&quot;Parse a file associating node type names with the best compatible MFn function </pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>	set and return a dictionary with the data</pre></div>
<div class="skip"><span class="num"><pre> 51</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>	:return: dict(((nodeTypeNameStr : api.MFnCls), ...)) dictionary with nodetypeName</pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>		MFn class mapping&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>	typenameToClsMap = dict()</pre></div>
<div class="skip"><span class="num"><pre> 55</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>	cfile = cacheFilePath( &quot;nodeTypeToMfnCls&quot;, &quot;map&quot; )</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>	fobj = open( cfile, 'r' )</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>	pf = PipeSeparatedFile( fobj )</pre></div>
<div class="skip"><span class="num"><pre> 59</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>	version = pf.beginReading( )	 # don't care about version</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>	for nodeTypeName, mfnTypeName in pf.readColumnLine( ):</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>		found = False</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>		for apimod in apiModules():</pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>				typenameToClsMap[ nodeTypeName ] = getattr( apimod, mfnTypeName )</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>				found = True</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>				break				# it worked, there is only one matching class</pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>			except AttributeError:</pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>				pass</pre></div>
<div class="skip"><span class="num"><pre> 70</pre></span><pre>		# END for each api module</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>		if not found:</pre></div>
<div class="nocov"><span class="num"><pre> 72</pre></span><pre>			log.debug(&quot;Couldn't find mfn class named %s&quot; % mfnTypeName)</pre></div>
<div class="skip"><span class="num"><pre> 73</pre></span><pre>	# END for each type/mfnclass pair</pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>	fobj.close()</pre></div>
<div class="skip"><span class="num"><pre> 75</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>	return typenameToClsMap</pre></div>
<div class="skip"><span class="num"><pre> 77</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 78</pre></span><pre>#} END initialization</pre></div>
<div class="skip"><span class="num"><pre> 79</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 80</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 81</pre></span><pre>#{ Utilities </pre></div>
<div class="skip"><span class="num"><pre> 82</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>def apiModules():</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>	&quot;&quot;&quot;:return: tuple of api modules containing MayaAPI classes</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>	:note: This takes a moment to load as it will import many api modules. Delay </pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>		the call as much as possible&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	import maya.OpenMaya as api</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>	import maya.OpenMayaAnim as apianim</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>	import maya.OpenMayaUI	as apiui</pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>	import maya.OpenMayaRender	as apirender</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>	import maya.OpenMayaFX as apifx</pre></div>
<div class="skip"><span class="num"><pre> 92</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>	return (api, apianim, apiui, apirender, apifx)</pre></div>
<div class="skip"><span class="num"><pre> 94</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 95</pre></span><pre>def mfnDBPath( mfnclsname ):</pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>	&quot;&quot;&quot;Generate a path to a database file containing mfn wrapping information&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>	return make_path(cacheFilePath(&quot;mfndb/&quot;+ mfnclsname, '', use_version=False)[:-1])	# cut the '.'</pre></div>
<div class="skip"><span class="num"><pre> 98</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>def headerPath( apiname ):</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>101</pre></span><pre>	:return: Path to file containing the c++ header of the given apiclass' name.</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>		The file will not be verified, hence it may be inaccessible</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>	:param apiname: string name, like 'MFnBase'</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>	:raise ValueError: if MAYA_LOCATION is not set&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>	p = make_path(&quot;$MAYA_LOCATION&quot;).expand_or_raise().realpath()</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>	if sys.platform == 'darwin':</pre></div>
<div class="nocov"><span class="num"><pre>107</pre></span><pre>		p = p.parent().parent() / &quot;devkit&quot;</pre></div>
<div class="skip"><span class="num"><pre>108</pre></span><pre>	# END handle platform dependency</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>	return p / (&quot;include/maya/%s.h&quot; % apiname)</pre></div>
<div class="skip"><span class="num"><pre>110</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>def cacheFilePath( filename, ext, use_version = False ):</pre></div>
<div class="cov"><span class="num"><pre>112</pre></span><pre>	&quot;&quot;&quot;Return path to cache file from which you would initialize data structures</pre></div>
<div class="skip"><span class="num"><pre>113</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>	:param use_version: if true, the maya version will be appended to the filename  &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>	mfile = make_path( __file__ ).parent()</pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>	version = &quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>	if use_version:</pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>		version = cmds.about( version=1 ).split( &quot; &quot; )[0]</pre></div>
<div class="skip"><span class="num"><pre>119</pre></span><pre>	# END use version</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>	return mfile / ( &quot;cache/%s%s.%s&quot; % ( filename, version, ext ) )</pre></div>
<div class="skip"><span class="num"><pre>121</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>def extractMFnFunctions(mfncls):</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>	&quot;&quot;&quot;Extract callables from mfncls, sorted into static methods and instance methods</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>	:return: tuple(list(callable_staticmethod, ...), list(callable_instancemethod, ...))&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>	mfnfuncs = list()</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>	staticmfnfuncs = list()</pre></div>
<div class="cov"><span class="num"><pre>127</pre></span><pre>	mfnname = mfncls.__name__</pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>	for fn, f in mfncls.__dict__.iteritems():</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>		if fn.startswith('_') or fn.endswith(mfnname) or not inspect.isroutine(f):</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>131</pre></span><pre>		# END skip non-routines</pre></div>
<div class="skip"><span class="num"><pre>132</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>		if isinstance(f, staticmethod):</pre></div>
<div class="skip"><span class="num"><pre>134</pre></span><pre>			# convert static methods into callable methods by fetching them officially</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>			staticmfnfuncs.append(getattr(mfncls, fn))</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>			mfnfuncs.append(f)</pre></div>
<div class="skip"><span class="num"><pre>138</pre></span><pre>		# END handle static methods </pre></div>
<div class="skip"><span class="num"><pre>139</pre></span><pre>	# END for each function in mfncls dict</pre></div>
<div class="skip"><span class="num"><pre>140</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>	return (staticmfnfuncs, mfnfuncs)</pre></div>
<div class="skip"><span class="num"><pre>142</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>def hasMEnumeration(mfncls):</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>	&quot;&quot;&quot;:return: True if the given mfncls has at least one enumeration&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>	for n in mfncls.__dict__.keys():</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>		if n.startswith('k') and n[1] in string.ascii_uppercase:	# a single k would kill us ... </pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>			return True</pre></div>
<div class="skip"><span class="num"><pre>148</pre></span><pre>	# END for each dict name</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>	return False</pre></div>
<div class="skip"><span class="num"><pre>150</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>def writeMfnDBCacheFiles(  ):</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>	&quot;&quot;&quot;Create a simple Memberlist of available mfn classes and their members</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>	to allow a simple human-editable way of adjusting which methods will be added</pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>	to the Nodes.</pre></div>
<div class="skip"><span class="num"><pre>155</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>	:note: currently writes information about all known api modules&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>157</pre></span><pre>	for apimod in apiModules():</pre></div>
<div class="nocov"><span class="num"><pre>158</pre></span><pre>		mfnclsnames = [ clsname for clsname in dir( apimod ) if clsname.startswith( &quot;MFn&quot; ) ]</pre></div>
<div class="nocov"><span class="num"><pre>159</pre></span><pre>		for mfnname in mfnclsnames:</pre></div>
<div class="nocov"><span class="num"><pre>160</pre></span><pre>			mfncls = getattr( apimod, mfnname )</pre></div>
<div class="nocov"><span class="num"><pre>161</pre></span><pre>			if not inspect.isclass(mfncls):</pre></div>
<div class="nocov"><span class="num"><pre>162</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>163</pre></span><pre>			# END assure we don't get methods, like MFnName_deallocateFlag</pre></div>
<div class="nocov"><span class="num"><pre>164</pre></span><pre>			mfnfile = mfnDBPath( mfnname )</pre></div>
<div class="skip"><span class="num"><pre>165</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>166</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>167</pre></span><pre>			mfnfuncs = list()</pre></div>
<div class="nocov"><span class="num"><pre>168</pre></span><pre>			fstatic, finst = extractMFnFunctions(mfncls)</pre></div>
<div class="nocov"><span class="num"><pre>169</pre></span><pre>			mfnfuncs.extend(fstatic)</pre></div>
<div class="nocov"><span class="num"><pre>170</pre></span><pre>			mfnfuncs.extend(finst)</pre></div>
<div class="skip"><span class="num"><pre>171</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>172</pre></span><pre>			if not mfnfuncs:</pre></div>
<div class="nocov"><span class="num"><pre>173</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>174</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>175</pre></span><pre>			db = MMemberMap()</pre></div>
<div class="nocov"><span class="num"><pre>176</pre></span><pre>			if mfnfile.exists():</pre></div>
<div class="nocov"><span class="num"><pre>177</pre></span><pre>				db = MMemberMap( mfnfile )</pre></div>
<div class="skip"><span class="num"><pre>178</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>179</pre></span><pre>			# assure folder exists</pre></div>
<div class="nocov"><span class="num"><pre>180</pre></span><pre>			folder = mfnfile.dirname()</pre></div>
<div class="nocov"><span class="num"><pre>181</pre></span><pre>			if not folder.isdir(): folder.makedirs()</pre></div>
<div class="skip"><span class="num"><pre>182</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>183</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>184</pre></span><pre>			# write data - simple set the keys, use default flags</pre></div>
<div class="nocov"><span class="num"><pre>185</pre></span><pre>			for func in mfnfuncs:</pre></div>
<div class="skip"><span class="num"><pre>186</pre></span><pre>				# it could be prefixed with the function set name - remove the prefix</pre></div>
<div class="skip"><span class="num"><pre>187</pre></span><pre>				# This happens in maya2008 + and may introduce plenty of new methods</pre></div>
<div class="nocov"><span class="num"><pre>188</pre></span><pre>				fname = func.__name__</pre></div>
<div class="nocov"><span class="num"><pre>189</pre></span><pre>				if fname.startswith(mfnname):</pre></div>
<div class="nocov"><span class="num"><pre>190</pre></span><pre>					fname = fname[len(mfnname)+1:]	# cut MFnName_(function)</pre></div>
<div class="skip"><span class="num"><pre>191</pre></span><pre>				# END handle prefix</pre></div>
<div class="skip"><span class="num"><pre>192</pre></span><pre>				</pre></div>
<div class="nocov"><span class="num"><pre>193</pre></span><pre>				db.createEntry(fname)</pre></div>
<div class="skip"><span class="num"><pre>194</pre></span><pre>			# END for each function to add</pre></div>
<div class="skip"><span class="num"><pre>195</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>196</pre></span><pre>			# finally write the change db</pre></div>
<div class="nocov"><span class="num"><pre>197</pre></span><pre>			db.writeToFile( mfnfile )</pre></div>
<div class="skip"><span class="num"><pre>198</pre></span><pre>		# END for each api class</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre>	# END for each api module</pre></div>
<div class="skip"><span class="num"><pre>200</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>def _createTmpNode(nodetype):</pre></div>
<div class="cov"><span class="num"><pre>202</pre></span><pre>	&quot;&quot;&quot;Return tuple(mobject, modifier) for the nodetype or raise RuntimeError</pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>	doIt has not yet been called on the modifier, hence the mobject is temporary&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>204</pre></span><pre>	try:</pre></div>
<div class="nocov"><span class="num"><pre>205</pre></span><pre>		mod = api.MDGModifier()</pre></div>
<div class="nocov"><span class="num"><pre>206</pre></span><pre>		obj = mod.createNode(nodetype)</pre></div>
<div class="nocov"><span class="num"><pre>207</pre></span><pre>		return (obj, mod)</pre></div>
<div class="nocov"><span class="num"><pre>208</pre></span><pre>	except RuntimeError:</pre></div>
<div class="nocov"><span class="num"><pre>209</pre></span><pre>		mod = api.MDagModifier()</pre></div>
<div class="nocov"><span class="num"><pre>210</pre></span><pre>		tmpparent = mod.createNode(&quot;transform&quot;)</pre></div>
<div class="nocov"><span class="num"><pre>211</pre></span><pre>		obj = mod.createNode(nodetype, tmpparent)</pre></div>
<div class="nocov"><span class="num"><pre>212</pre></span><pre>		return (obj, mod)</pre></div>
<div class="skip"><span class="num"><pre>213</pre></span><pre>	# END exception handling</pre></div>
<div class="skip"><span class="num"><pre>214</pre></span><pre># END utility</pre></div>
<div class="skip"><span class="num"><pre>215</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>def _iterAllNodeTypes( ):</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>	&quot;&quot;&quot;Returns iterator which yield tuple(nodeTypeName, MObject, modifier) triplets</pre></div>
<div class="cov"><span class="num"><pre>218</pre></span><pre>	of nodeTypes, with an MObjects instance of it, created with the given modifier, </pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>	one for each node type available to maya.</pre></div>
<div class="skip"><span class="num"><pre>220</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>221</pre></span><pre>	:note: skips manipulators as they tend to crash maya on creation ( perhaps its only</pre></div>
<div class="cov"><span class="num"><pre>222</pre></span><pre>		one which does that, but its not that important )&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>223</pre></span><pre>	for nodetype in sorted(cmds.ls(nodeTypes=1)):</pre></div>
<div class="skip"><span class="num"><pre>224</pre></span><pre>		# evil crashers</pre></div>
<div class="nocov"><span class="num"><pre>225</pre></span><pre>		if 'Manip' in nodetype or nodetype.startswith('manip'):</pre></div>
<div class="nocov"><span class="num"><pre>226</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>		# END skip manipulators</pre></div>
<div class="nocov"><span class="num"><pre>228</pre></span><pre>		try:</pre></div>
<div class="nocov"><span class="num"><pre>229</pre></span><pre>			obj, mod = _createTmpNode(nodetype) </pre></div>
<div class="nocov"><span class="num"><pre>230</pre></span><pre>			yield nodetype, obj, mod</pre></div>
<div class="nocov"><span class="num"><pre>231</pre></span><pre>		except RuntimeError:</pre></div>
<div class="nocov"><span class="num"><pre>232</pre></span><pre>			log.warn(&quot;Could not create '%s'&quot; % nodetype)</pre></div>
<div class="nocov"><span class="num"><pre>233</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>234</pre></span><pre>		# END create dg/dag node exception handling</pre></div>
<div class="skip"><span class="num"><pre>235</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>def generateNodeHierarchy( ):</pre></div>
<div class="cov"><span class="num"><pre>237</pre></span><pre>	&quot;&quot;&quot;Generate the node-hierarchy for the current version based on all node types </pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>	which can be created in maya.</pre></div>
<div class="skip"><span class="num"><pre>239</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>	:return: tuple(DAGTree, typeToMFnClsNameList)</pre></div>
<div class="skip"><span class="num"><pre>241</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>		* DAGTree representing the type hierarchy</pre></div>
<div class="cov"><span class="num"><pre>243</pre></span><pre>		* list represents typeName to MFnClassName associations</pre></div>
<div class="skip"><span class="num"><pre>244</pre></span><pre>		 </pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>	:note: should only be run as part of the upgrade process to prepare MRV for  a</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>		new maya release. Otherwise the nodetype tree will be read from a cache&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>247</pre></span><pre>	from mrv.util import DAGTree</pre></div>
<div class="nocov"><span class="num"><pre>248</pre></span><pre>	from mrv.util import uncapitalize, capitalize</pre></div>
<div class="nocov"><span class="num"><pre>249</pre></span><pre>	from mrv.maya.util import MEnumeration</pre></div>
<div class="skip"><span class="num"><pre>250</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>251</pre></span><pre>	# init DagTree</pre></div>
<div class="nocov"><span class="num"><pre>252</pre></span><pre>	root = &quot;_root_&quot; </pre></div>
<div class="nocov"><span class="num"><pre>253</pre></span><pre>	depnode = 'dependNode'</pre></div>
<div class="nocov"><span class="num"><pre>254</pre></span><pre>	depnode_list = [depnode]</pre></div>
<div class="nocov"><span class="num"><pre>255</pre></span><pre>	noderoottype = 'node'</pre></div>
<div class="nocov"><span class="num"><pre>256</pre></span><pre>	dagTree = DAGTree()</pre></div>
<div class="nocov"><span class="num"><pre>257</pre></span><pre>	dagTree.add_edge(root, noderoottype)</pre></div>
<div class="nocov"><span class="num"><pre>258</pre></span><pre>	dagTree.add_edge(noderoottype, depnode)</pre></div>
<div class="skip"><span class="num"><pre>259</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>260</pre></span><pre>	apiTypeToNodeTypeMap = dict()		# apiTypeStr -&gt; nodeTypeName</pre></div>
<div class="nocov"><span class="num"><pre>261</pre></span><pre>	mfnTypes = set()					# apiTypeStr of mfns used by NodeTypes</pre></div>
<div class="nocov"><span class="num"><pre>262</pre></span><pre>	sl = list()							# string list</pre></div>
<div class="skip"><span class="num"><pre>263</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>264</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>265</pre></span><pre>	mfndep = api.MFnDependencyNode()</pre></div>
<div class="nocov"><span class="num"><pre>266</pre></span><pre>	def getInheritanceAndUndo(obj, modifier):</pre></div>
<div class="nocov"><span class="num"><pre>267</pre></span><pre>		&quot;&quot;&quot;Takes a prepared modifier ( doIt not yet called ) and the previously created object, </pre></div>
<div class="nocov"><span class="num"><pre>268</pre></span><pre>		returning the inheritance of the obj which was retrieved before undoing</pre></div>
<div class="nocov"><span class="num"><pre>269</pre></span><pre>		its creation&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>270</pre></span><pre>		modifier.doIt()</pre></div>
<div class="nocov"><span class="num"><pre>271</pre></span><pre>		mfndep.setObject(obj)</pre></div>
<div class="nocov"><span class="num"><pre>272</pre></span><pre>		inheritance = cmds.nodeType(mfndep.name(), i=1)</pre></div>
<div class="nocov"><span class="num"><pre>273</pre></span><pre>		modifier.undoIt()</pre></div>
<div class="nocov"><span class="num"><pre>274</pre></span><pre>		return inheritance</pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre>	# END utility</pre></div>
<div class="skip"><span class="num"><pre>276</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>277</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>278</pre></span><pre>	# CREATE ALL NODE TYPES</pre></div>
<div class="skip"><span class="num"><pre>279</pre></span><pre>	#######################</pre></div>
<div class="skip"><span class="num"><pre>280</pre></span><pre>	# query the inheritance afterwards</pre></div>
<div class="nocov"><span class="num"><pre>281</pre></span><pre>	for nodetype, obj, mod in _iterAllNodeTypes():</pre></div>
<div class="nocov"><span class="num"><pre>282</pre></span><pre>		inheritance = getInheritanceAndUndo(obj, mod)</pre></div>
<div class="skip"><span class="num"><pre>283</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>284</pre></span><pre>		if not inheritance:</pre></div>
<div class="nocov"><span class="num"><pre>285</pre></span><pre>			log.error(&quot;Failed on type %s&quot; % nodetype)</pre></div>
<div class="nocov"><span class="num"><pre>286</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>287</pre></span><pre>		# END handle unusual case</pre></div>
<div class="skip"><span class="num"><pre>288</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>289</pre></span><pre>		# filter bases</pre></div>
<div class="nocov"><span class="num"><pre>290</pre></span><pre>		for parent, child in zip(depnode_list + inheritance[:-1], inheritance):</pre></div>
<div class="nocov"><span class="num"><pre>291</pre></span><pre>			dagTree.add_edge(parent, child)</pre></div>
<div class="skip"><span class="num"><pre>292</pre></span><pre>		# END for each edge to add</pre></div>
<div class="skip"><span class="num"><pre>293</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>294</pre></span><pre>		# retrieve all compatible MFnTypes - these refer to apiTypes which are </pre></div>
<div class="skip"><span class="num"><pre>295</pre></span><pre>		# also used by Nodes. Currently we have only the type of the node, fortunately, </pre></div>
<div class="skip"><span class="num"><pre>296</pre></span><pre>		# it will match very well with the MFnType, by just prepending MFn.</pre></div>
<div class="skip"><span class="num"><pre>297</pre></span><pre>		# As some MFn are in other modules, we will search em all ... later</pre></div>
<div class="nocov"><span class="num"><pre>298</pre></span><pre>		apiTypeToNodeTypeMap[obj.apiTypeStr()] = nodetype</pre></div>
<div class="skip"><span class="num"><pre>299</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>300</pre></span><pre>		api.MGlobal.getFunctionSetList(obj, sl)</pre></div>
<div class="nocov"><span class="num"><pre>301</pre></span><pre>		for mfnType in sl:</pre></div>
<div class="nocov"><span class="num"><pre>302</pre></span><pre>			mfnTypes.add(mfnType)</pre></div>
<div class="skip"><span class="num"><pre>303</pre></span><pre>	# END for each node type</pre></div>
<div class="skip"><span class="num"><pre>304</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>305</pre></span><pre>	# INSERT SPECIAL TYPES</pre></div>
<div class="skip"><span class="num"><pre>306</pre></span><pre>	######################</pre></div>
<div class="skip"><span class="num"><pre>307</pre></span><pre>	# used by the type system if it cannot classify a node at all</pre></div>
<div class="nocov"><span class="num"><pre>308</pre></span><pre>	dagTree.add_edge(depnode, 'unknown')</pre></div>
<div class="skip"><span class="num"><pre>309</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>310</pre></span><pre>	# can be iterated using the DagIterator, and it should at least be a dag node, </pre></div>
<div class="skip"><span class="num"><pre>311</pre></span><pre>	# not unknown. The groundPlane is actually a special object that users shouldn't</pre></div>
<div class="skip"><span class="num"><pre>312</pre></span><pre>	# touch directly</pre></div>
<div class="nocov"><span class="num"><pre>313</pre></span><pre>	dagTree.add_edge('transform', 'groundPlane')</pre></div>
<div class="skip"><span class="num"><pre>314</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>315</pre></span><pre>	# although we don't handle manips directly, we must still support them if it</pre></div>
<div class="skip"><span class="num"><pre>316</pre></span><pre>	# is a plugin manipulator</pre></div>
<div class="nocov"><span class="num"><pre>317</pre></span><pre>	dagTree.add_edge('transform', 'manipContainer')</pre></div>
<div class="skip"><span class="num"><pre>318</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>319</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>320</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>321</pre></span><pre>	# INSERT PLUGIN TYPES</pre></div>
<div class="skip"><span class="num"><pre>322</pre></span><pre>	######################</pre></div>
<div class="nocov"><span class="num"><pre>323</pre></span><pre>	for edge in (	(depnode, 'DependNode'),</pre></div>
<div class="nocov"><span class="num"><pre>324</pre></span><pre>					('shape', 'Shape'), </pre></div>
<div class="nocov"><span class="num"><pre>325</pre></span><pre>					('locator', 'LocatorNode'), </pre></div>
<div class="nocov"><span class="num"><pre>326</pre></span><pre>					('spring', 'SpringNode'), </pre></div>
<div class="nocov"><span class="num"><pre>327</pre></span><pre>					('transform', 'TransformNode'), </pre></div>
<div class="nocov"><span class="num"><pre>328</pre></span><pre>					('manipContainer', 'ManipContainer'), </pre></div>
<div class="nocov"><span class="num"><pre>329</pre></span><pre>					('dynBase', 'EmitterNode'), </pre></div>
<div class="nocov"><span class="num"><pre>330</pre></span><pre>					('field', 'FieldNode'), </pre></div>
<div class="nocov"><span class="num"><pre>331</pre></span><pre>					('objectSet', 'ObjectSet'), </pre></div>
<div class="nocov"><span class="num"><pre>332</pre></span><pre>					('geometryFilter', 'DeformerNode'), </pre></div>
<div class="nocov"><span class="num"><pre>333</pre></span><pre>					(depnode, 'HwShaderNode'), </pre></div>
<div class="nocov"><span class="num"><pre>334</pre></span><pre>					('ikSolver', 'IkSolver'), </pre></div>
<div class="nocov"><span class="num"><pre>335</pre></span><pre>					(depnode, 'ImagePlaneNode'), </pre></div>
<div class="nocov"><span class="num"><pre>336</pre></span><pre>					(depnode, 'ParticleAttributeMapperNode')	):</pre></div>
<div class="nocov"><span class="num"><pre>337</pre></span><pre>		dagTree.add_edge(edge[0], 'unknownPlugin'+edge[1])</pre></div>
<div class="skip"><span class="num"><pre>338</pre></span><pre>	# END for each plugin edge to add</pre></div>
<div class="skip"><span class="num"><pre>339</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>340</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>341</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>342</pre></span><pre>	# BULD TYPE-TO-MFN MAP</pre></div>
<div class="skip"><span class="num"><pre>343</pre></span><pre>	######################</pre></div>
<div class="skip"><span class="num"><pre>344</pre></span><pre>	# Prepare data to be put into a type separated file, it associates </pre></div>
<div class="skip"><span class="num"><pre>345</pre></span><pre>	# a nodeType or nodeApiType with the respecitve MFnClass name</pre></div>
<div class="nocov"><span class="num"><pre>346</pre></span><pre>	typeToMFn = set()		# list((typeName, MFnClsName), ...)</pre></div>
<div class="skip"><span class="num"><pre>347</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>348</pre></span><pre>	# add default associations - some are not picked up due to name mismatches</pre></div>
<div class="nocov"><span class="num"><pre>349</pre></span><pre>	typeToMFn.add((noderoottype, 'MFn'))</pre></div>
<div class="nocov"><span class="num"><pre>350</pre></span><pre>	typeToMFn.add((depnode, 'MFnDependencyNode'))</pre></div>
<div class="nocov"><span class="num"><pre>351</pre></span><pre>	typeToMFn.add(('dagContainer', 'MFnContainerNode'))</pre></div>
<div class="skip"><span class="num"><pre>352</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>353</pre></span><pre>	abstractMFns = ('MFnBase', )		# MFns which cannot be instantiated ans should be ignored</pre></div>
<div class="nocov"><span class="num"><pre>354</pre></span><pre>	failedMFnTypes = list()			# list of types we could not yet associate</pre></div>
<div class="skip"><span class="num"><pre>355</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>356</pre></span><pre>	modsapi = apiModules()</pre></div>
<div class="nocov"><span class="num"><pre>357</pre></span><pre>	for mfnApiType in mfnTypes:</pre></div>
<div class="nocov"><span class="num"><pre>358</pre></span><pre>		mfnNodePseudoType = uncapitalize(mfnApiType[1:])	# # kSomething -&gt; something</pre></div>
<div class="nocov"><span class="num"><pre>359</pre></span><pre>		nodeType = apiTypeToNodeTypeMap.get(mfnApiType, mfnNodePseudoType)</pre></div>
<div class="skip"><span class="num"><pre>360</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>361</pre></span><pre>		# MFnSets follow their kMFnType names, but when we try to associate it with </pre></div>
<div class="skip"><span class="num"><pre>362</pre></span><pre>		# the actual nodeType . Sometimes, they follow the actual nodeType, so we </pre></div>
<div class="skip"><span class="num"><pre>363</pre></span><pre>		# have to use this one as well</pre></div>
<div class="nocov"><span class="num"><pre>364</pre></span><pre>		found = False</pre></div>
<div class="nocov"><span class="num"><pre>365</pre></span><pre>		for nt, mfnNameCandidate in ( (mfnNodePseudoType, &quot;MFn%s&quot; % capitalize(mfnApiType[1:])), </pre></div>
<div class="nocov"><span class="num"><pre>366</pre></span><pre>									   (nodeType, &quot;MFn%s&quot; % capitalize(nodeType)) ):</pre></div>
<div class="skip"><span class="num"><pre>367</pre></span><pre>			# ignore abstract ones</pre></div>
<div class="nocov"><span class="num"><pre>368</pre></span><pre>			if mfnNameCandidate in abstractMFns:</pre></div>
<div class="nocov"><span class="num"><pre>369</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>370</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>371</pre></span><pre>			for modapi in modsapi:</pre></div>
<div class="nocov"><span class="num"><pre>372</pre></span><pre>				if hasattr(modapi, mfnNameCandidate):</pre></div>
<div class="nocov"><span class="num"><pre>373</pre></span><pre>					found = True</pre></div>
<div class="skip"><span class="num"><pre>374</pre></span><pre>					</pre></div>
<div class="skip"><span class="num"><pre>375</pre></span><pre>					# prefer a real nodetype if we have one - it will default</pre></div>
<div class="skip"><span class="num"><pre>376</pre></span><pre>					# to the pseudotype</pre></div>
<div class="nocov"><span class="num"><pre>377</pre></span><pre>					typeToMFn.add((nodeType, mfnNameCandidate))</pre></div>
<div class="nocov"><span class="num"><pre>378</pre></span><pre>					break</pre></div>
<div class="skip"><span class="num"><pre>379</pre></span><pre>				# END module with given name exists</pre></div>
<div class="skip"><span class="num"><pre>380</pre></span><pre>			# END for each api module</pre></div>
<div class="skip"><span class="num"><pre>381</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>382</pre></span><pre>			if found:</pre></div>
<div class="nocov"><span class="num"><pre>383</pre></span><pre>				break</pre></div>
<div class="skip"><span class="num"><pre>384</pre></span><pre>		# END for each nodeType/mfnNamecandidate</pre></div>
<div class="skip"><span class="num"><pre>385</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>386</pre></span><pre>		# still not found ? Keep it, but only if there is a nodetype </pre></div>
<div class="skip"><span class="num"><pre>387</pre></span><pre>		# associated with it</pre></div>
<div class="nocov"><span class="num"><pre>388</pre></span><pre>		if not found and mfnApiType in apiTypeToNodeTypeMap:</pre></div>
<div class="nocov"><span class="num"><pre>389</pre></span><pre>			failedMFnTypes.append(mfnApiType)</pre></div>
<div class="skip"><span class="num"><pre>390</pre></span><pre>		# END keep a record</pre></div>
<div class="skip"><span class="num"><pre>391</pre></span><pre>	# END for each mfnType</pre></div>
<div class="skip"><span class="num"><pre>392</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>393</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>394</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>395</pre></span><pre>	# DATA, COMPONENTS, ATTRIBUTES</pre></div>
<div class="skip"><span class="num"><pre>396</pre></span><pre>	###############################</pre></div>
<div class="skip"><span class="num"><pre>397</pre></span><pre>	# get inheritance of Data, Component and Attribute types</pre></div>
<div class="nocov"><span class="num"><pre>398</pre></span><pre>	def unMFn(name):</pre></div>
<div class="nocov"><span class="num"><pre>399</pre></span><pre>		return uncapitalize(name[3:])</pre></div>
<div class="skip"><span class="num"><pre>400</pre></span><pre>	# END remove MFn in front of MFnSomething strings</pre></div>
<div class="skip"><span class="num"><pre>401</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>402</pre></span><pre>	for mfnsuffix in (&quot;data&quot;, &quot;component&quot;, &quot;attribute&quot;):</pre></div>
<div class="nocov"><span class="num"><pre>403</pre></span><pre>		mfnsuffixcap = capitalize(mfnsuffix)</pre></div>
<div class="nocov"><span class="num"><pre>404</pre></span><pre>		mfnnames = list()</pre></div>
<div class="nocov"><span class="num"><pre>405</pre></span><pre>		for modapi in modsapi:</pre></div>
<div class="nocov"><span class="num"><pre>406</pre></span><pre>			mfnnames.extend( n for n in dir(modapi) if n.endswith(mfnsuffixcap) )</pre></div>
<div class="skip"><span class="num"><pre>407</pre></span><pre>		# END for each api module to get information from</pre></div>
<div class="skip"><span class="num"><pre>408</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>409</pre></span><pre>		dagTree.add_edge(root, mfnsuffix)</pre></div>
<div class="skip"><span class="num"><pre>410</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>411</pre></span><pre>		mfnsuffix_root = [ mfnsuffix ]</pre></div>
<div class="nocov"><span class="num"><pre>412</pre></span><pre>		for mfnname in mfnnames:</pre></div>
<div class="nocov"><span class="num"><pre>413</pre></span><pre>			for modapi in modsapi:</pre></div>
<div class="nocov"><span class="num"><pre>414</pre></span><pre>				try:</pre></div>
<div class="nocov"><span class="num"><pre>415</pre></span><pre>					mfncls = getattr(modapi, mfnname)</pre></div>
<div class="nocov"><span class="num"><pre>416</pre></span><pre>				except AttributeError:</pre></div>
<div class="nocov"><span class="num"><pre>417</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>418</pre></span><pre>				# END handle multi-modules</pre></div>
<div class="skip"><span class="num"><pre>419</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>420</pre></span><pre>				# skip classes which are just named like the super type, but </pre></div>
<div class="skip"><span class="num"><pre>421</pre></span><pre>				# don't actually inherit it</pre></div>
<div class="nocov"><span class="num"><pre>422</pre></span><pre>				if &quot;MFn%s&quot; % mfnsuffixcap not in ( p.__name__ for p in mfncls.mro() ):</pre></div>
<div class="nocov"><span class="num"><pre>423</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>424</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>425</pre></span><pre>				# add type-&gt;MFn association</pre></div>
<div class="nocov"><span class="num"><pre>426</pre></span><pre>				typeToMFn.add((unMFn(mfnname), mfnname))</pre></div>
<div class="skip"><span class="num"><pre>427</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>428</pre></span><pre>				# cut object and MFnBase</pre></div>
<div class="skip"><span class="num"><pre>429</pre></span><pre>				# from the names, cut the MFn and uncaptialize it: MFnData -&gt; data</pre></div>
<div class="nocov"><span class="num"><pre>430</pre></span><pre>				pclsnames = [ unMFn(p.__name__) for p in list(reversed(mfncls.mro()))[2:] ]</pre></div>
<div class="nocov"><span class="num"><pre>431</pre></span><pre>				for parent, child in zip(pclsnames[:-1], pclsnames[1:]):</pre></div>
<div class="nocov"><span class="num"><pre>432</pre></span><pre>					dagTree.add_edge(parent, child)</pre></div>
<div class="skip"><span class="num"><pre>433</pre></span><pre>				# END for each mfn child to add</pre></div>
<div class="skip"><span class="num"><pre>434</pre></span><pre>				</pre></div>
<div class="nocov"><span class="num"><pre>435</pre></span><pre>				break</pre></div>
<div class="skip"><span class="num"><pre>436</pre></span><pre>			# END for each api module</pre></div>
<div class="skip"><span class="num"><pre>437</pre></span><pre>		# END for each name</pre></div>
<div class="skip"><span class="num"><pre>438</pre></span><pre>	# END for each mfnsuffix</pre></div>
<div class="skip"><span class="num"><pre>439</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>440</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>441</pre></span><pre>	# HANDLE FAILED MFN-ASSOCITAIONS</pre></div>
<div class="skip"><span class="num"><pre>442</pre></span><pre>	################################</pre></div>
<div class="skip"><span class="num"><pre>443</pre></span><pre>	# lets take some very special care !</pre></div>
<div class="nocov"><span class="num"><pre>444</pre></span><pre>	if failedMFnTypes:</pre></div>
<div class="skip"><span class="num"><pre>445</pre></span><pre>		# Here we handle cases which don't follow any naming conventions really</pre></div>
<div class="skip"><span class="num"><pre>446</pre></span><pre>		# Hence we have to instantiate an object of the failed type, then </pre></div>
<div class="skip"><span class="num"><pre>447</pre></span><pre>		# we instantiate all the remaining functions sets to see which one fits.</pre></div>
<div class="skip"><span class="num"><pre>448</pre></span><pre>		# If the required one has the requested type, we have a match. </pre></div>
<div class="skip"><span class="num"><pre>449</pre></span><pre>		# If we have no type match, its still a valid MFn - If we haven't seen it </pre></div>
<div class="skip"><span class="num"><pre>450</pre></span><pre>		# yet, its probably a base MFn whose kType string allows deduction of the </pre></div>
<div class="skip"><span class="num"><pre>451</pre></span><pre>		# actual abtract node type which we will use instead.</pre></div>
<div class="nocov"><span class="num"><pre>452</pre></span><pre>		associatedMFns = ( t[1] for t in typeToMFn )</pre></div>
<div class="nocov"><span class="num"><pre>453</pre></span><pre>		allMFnSetNames = list()</pre></div>
<div class="nocov"><span class="num"><pre>454</pre></span><pre>		for modapi in modsapi:</pre></div>
<div class="nocov"><span class="num"><pre>455</pre></span><pre>			allMFnSetNames.extend( n for n in dir(modapi) if n.startswith('MFn') and </pre></div>
<div class="nocov"><span class="num"><pre>456</pre></span><pre>															not n.endswith('Ptr') and </pre></div>
<div class="nocov"><span class="num"><pre>457</pre></span><pre>															not '_' in n and 		# skip 'special' ones</pre></div>
<div class="nocov"><span class="num"><pre>458</pre></span><pre>															not 'Manip' in n )		# skip everything about Manipulators</pre></div>
<div class="skip"><span class="num"><pre>459</pre></span><pre>		# END get all MFn names</pre></div>
<div class="skip"><span class="num"><pre>460</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>461</pre></span><pre>		# find MFnClasses for each candidate name</pre></div>
<div class="nocov"><span class="num"><pre>462</pre></span><pre>		candidateMFnNames = (set(allMFnSetNames) - set(associatedMFns)) - set(abstractMFns)</pre></div>
<div class="nocov"><span class="num"><pre>463</pre></span><pre>		candidateMFns = list()</pre></div>
<div class="nocov"><span class="num"><pre>464</pre></span><pre>		for cn in list(candidateMFnNames):</pre></div>
<div class="nocov"><span class="num"><pre>465</pre></span><pre>			for modapi in modsapi:</pre></div>
<div class="nocov"><span class="num"><pre>466</pre></span><pre>				try:</pre></div>
<div class="nocov"><span class="num"><pre>467</pre></span><pre>					mfncls = getattr(modapi, cn)</pre></div>
<div class="skip"><span class="num"><pre>468</pre></span><pre>					# ignore them if they don't derive from MFnBase</pre></div>
<div class="nocov"><span class="num"><pre>469</pre></span><pre>					if not hasattr(mfncls, &quot;type&quot;):</pre></div>
<div class="nocov"><span class="num"><pre>470</pre></span><pre>						log.debug(&quot;Skipped MFn %s as it didn't derive from MFnBase&quot; % mfncls)</pre></div>
<div class="nocov"><span class="num"><pre>471</pre></span><pre>						candidateMFnNames.discard(cn)</pre></div>
<div class="nocov"><span class="num"><pre>472</pre></span><pre>						continue</pre></div>
<div class="skip"><span class="num"><pre>473</pre></span><pre>					# END skip mfn</pre></div>
<div class="nocov"><span class="num"><pre>474</pre></span><pre>					candidateMFns.append(mfncls)</pre></div>
<div class="nocov"><span class="num"><pre>475</pre></span><pre>					break</pre></div>
<div class="nocov"><span class="num"><pre>476</pre></span><pre>				except AttributeError:</pre></div>
<div class="nocov"><span class="num"><pre>477</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>478</pre></span><pre>			# END for each api module</pre></div>
<div class="skip"><span class="num"><pre>479</pre></span><pre>		# END for each candidate name</pre></div>
<div class="skip"><span class="num"><pre>480</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>481</pre></span><pre>		succeededMFnNames = set()</pre></div>
<div class="skip"><span class="num"><pre>482</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>483</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>484</pre></span><pre>		# PRUNE REMAINING MFNs</pre></div>
<div class="skip"><span class="num"><pre>485</pre></span><pre>		# prune out all MFnClasses that can be constructed without an actual object</pre></div>
<div class="nocov"><span class="num"><pre>486</pre></span><pre>		enumMembers = MEnumDescriptor('Type')</pre></div>
<div class="nocov"><span class="num"><pre>487</pre></span><pre>		enumMembers.extend( m for m in dir(api.MFn) if m.startswith('k') )</pre></div>
<div class="nocov"><span class="num"><pre>488</pre></span><pre>		mfntypes = MEnumeration.create(enumMembers, api.MFn)</pre></div>
<div class="skip"><span class="num"><pre>489</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>490</pre></span><pre>		for mfncls in candidateMFns[:]:</pre></div>
<div class="nocov"><span class="num"><pre>491</pre></span><pre>			try:</pre></div>
<div class="nocov"><span class="num"><pre>492</pre></span><pre>				mfninst = mfncls()</pre></div>
<div class="nocov"><span class="num"><pre>493</pre></span><pre>				if mfntypes.nameByValue(mfninst.type()) in failedMFnTypes:</pre></div>
<div class="nocov"><span class="num"><pre>494</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>495</pre></span><pre>				# END keep actually missing MFns</pre></div>
<div class="nocov"><span class="num"><pre>496</pre></span><pre>				candidateMFns.remove(mfncls)</pre></div>
<div class="nocov"><span class="num"><pre>497</pre></span><pre>				candidateMFnNames.remove(mfncls.__name__)</pre></div>
<div class="nocov"><span class="num"><pre>498</pre></span><pre>			except RuntimeError:</pre></div>
<div class="nocov"><span class="num"><pre>499</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>500</pre></span><pre>		# END for each possible MFn to prune</pre></div>
<div class="skip"><span class="num"><pre>501</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>502</pre></span><pre>		# at this point, we have about 500 api types with no MFn, but only </pre></div>
<div class="skip"><span class="num"><pre>503</pre></span><pre>		# about 10 function sets, </pre></div>
<div class="skip"><span class="num"><pre>504</pre></span><pre>		# Now ... we  brute-force test our way through all of these to find </pre></div>
<div class="skip"><span class="num"><pre>505</pre></span><pre>		# matching ones ... argh</pre></div>
<div class="nocov"><span class="num"><pre>506</pre></span><pre>		derivedMatches = list()		# keeps tuple(kTypeStr, mfnname) of matches of derived types</pre></div>
<div class="nocov"><span class="num"><pre>507</pre></span><pre>		perfectMatches = list()		# keeps mfnnames of perfect matches</pre></div>
<div class="nocov"><span class="num"><pre>508</pre></span><pre>		for failedApiTypeStr in failedMFnTypes:</pre></div>
<div class="nocov"><span class="num"><pre>509</pre></span><pre>			nodeType = apiTypeToNodeTypeMap[failedApiTypeStr]</pre></div>
<div class="nocov"><span class="num"><pre>510</pre></span><pre>			obj, mod = _createTmpNode(nodeType)</pre></div>
<div class="skip"><span class="num"><pre>511</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>512</pre></span><pre>			removeThisMFn = None</pre></div>
<div class="nocov"><span class="num"><pre>513</pre></span><pre>			for mfncls in candidateMFns:</pre></div>
<div class="nocov"><span class="num"><pre>514</pre></span><pre>				try:</pre></div>
<div class="nocov"><span class="num"><pre>515</pre></span><pre>					mfninst = mfncls(obj)</pre></div>
<div class="nocov"><span class="num"><pre>516</pre></span><pre>				except RuntimeError:</pre></div>
<div class="nocov"><span class="num"><pre>517</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>518</pre></span><pre>				# END handle incompatability</pre></div>
<div class="skip"><span class="num"><pre>519</pre></span><pre>				</pre></div>
<div class="nocov"><span class="num"><pre>520</pre></span><pre>				apiTypeStr = mfntypes.nameByValue(mfninst.type())</pre></div>
<div class="skip"><span class="num"><pre>521</pre></span><pre>				</pre></div>
<div class="nocov"><span class="num"><pre>522</pre></span><pre>				if apiTypeStr not in failedMFnTypes:</pre></div>
<div class="nocov"><span class="num"><pre>523</pre></span><pre>					removeThisMFn = mfncls</pre></div>
<div class="nocov"><span class="num"><pre>524</pre></span><pre>					break</pre></div>
<div class="skip"><span class="num"><pre>525</pre></span><pre>				# END remove MFns that no one wants</pre></div>
<div class="skip"><span class="num"><pre>526</pre></span><pre>				</pre></div>
<div class="nocov"><span class="num"><pre>527</pre></span><pre>				if apiTypeStr == failedApiTypeStr:</pre></div>
<div class="nocov"><span class="num"><pre>528</pre></span><pre>					mfnname = mfncls.__name__</pre></div>
<div class="nocov"><span class="num"><pre>529</pre></span><pre>					typeToMFn.add((nodeType, mfnname))</pre></div>
<div class="nocov"><span class="num"><pre>530</pre></span><pre>					perfectMatches.append(mfnname)</pre></div>
<div class="nocov"><span class="num"><pre>531</pre></span><pre>					removeThisMFn = mfncls</pre></div>
<div class="nocov"><span class="num"><pre>532</pre></span><pre>					break</pre></div>
<div class="skip"><span class="num"><pre>533</pre></span><pre>				# END perfect match </pre></div>
<div class="skip"><span class="num"><pre>534</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>535</pre></span><pre>				# its matching, but its not perfectly suited for our node type</pre></div>
<div class="skip"><span class="num"><pre>536</pre></span><pre>				# We keep it, and will map it later if we don't find a better match</pre></div>
<div class="nocov"><span class="num"><pre>537</pre></span><pre>				derivedMatches.append((apiTypeStr, mfncls.__name__))</pre></div>
<div class="skip"><span class="num"><pre>538</pre></span><pre>			# END for each mfncls</pre></div>
<div class="skip"><span class="num"><pre>539</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>540</pre></span><pre>			if removeThisMFn is not None:</pre></div>
<div class="nocov"><span class="num"><pre>541</pre></span><pre>				succeededMFnNames.add(removeThisMFn.__name__)</pre></div>
<div class="nocov"><span class="num"><pre>542</pre></span><pre>				candidateMFns.remove(removeThisMFn)</pre></div>
<div class="skip"><span class="num"><pre>543</pre></span><pre>			# END remove matched MFn</pre></div>
<div class="skip"><span class="num"><pre>544</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>545</pre></span><pre>			if not candidateMFns:</pre></div>
<div class="nocov"><span class="num"><pre>546</pre></span><pre>				break</pre></div>
<div class="skip"><span class="num"><pre>547</pre></span><pre>			# END abort search if there is nothing left </pre></div>
<div class="skip"><span class="num"><pre>548</pre></span><pre>		# END for each failed type</pre></div>
<div class="skip"><span class="num"><pre>549</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>550</pre></span><pre>		# HANDLE DERIVED MFns</pre></div>
<div class="skip"><span class="num"><pre>551</pre></span><pre>		# prune out all derived mfs which have found a perfect match in the meanwhile</pre></div>
<div class="skip"><span class="num"><pre>552</pre></span><pre>		# the rest will be added to the list</pre></div>
<div class="nocov"><span class="num"><pre>553</pre></span><pre>		for apiTypeStr, mfnname in filter(lambda t: t not in perfectMatches, derivedMatches):</pre></div>
<div class="nocov"><span class="num"><pre>554</pre></span><pre>			typeToMFn.add((apiTypeToNodeTypeMap[apiTypeStr], mfnname))</pre></div>
<div class="nocov"><span class="num"><pre>555</pre></span><pre>			succeededMFnNames.add(mfnname)</pre></div>
<div class="skip"><span class="num"><pre>556</pre></span><pre>		# END for each apiTypeStr left ot add</pre></div>
<div class="skip"><span class="num"><pre>557</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>558</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>559</pre></span><pre>		# LAST MANUAL WORK</pre></div>
<div class="skip"><span class="num"><pre>560</pre></span><pre>		##################</pre></div>
<div class="skip"><span class="num"><pre>561</pre></span><pre>		# SubDees, if created empty, cannot be attached to their function set</pre></div>
<div class="skip"><span class="num"><pre>562</pre></span><pre>		# Hence we don't see the match, but ... we know its there, so we add it</pre></div>
<div class="skip"><span class="num"><pre>563</pre></span><pre>		# ourselves</pre></div>
<div class="nocov"><span class="num"><pre>564</pre></span><pre>		for nodeType, mfnname in (('subdiv', 'MFnSubd'), ):</pre></div>
<div class="nocov"><span class="num"><pre>565</pre></span><pre>			typeToMFn.add((nodeType, mfnname))</pre></div>
<div class="nocov"><span class="num"><pre>566</pre></span><pre>			succeededMFnNames.add(mfnname)</pre></div>
<div class="skip"><span class="num"><pre>567</pre></span><pre>		# END for each manually added type</pre></div>
<div class="skip"><span class="num"><pre>568</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>569</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>570</pre></span><pre>		for mfnname in candidateMFnNames - succeededMFnNames:</pre></div>
<div class="nocov"><span class="num"><pre>571</pre></span><pre>			log.warn(&quot;Could not associate MFn: %s&quot; % mfnname)</pre></div>
<div class="skip"><span class="num"><pre>572</pre></span><pre>		# END provide some info</pre></div>
<div class="skip"><span class="num"><pre>573</pre></span><pre>	# END special treatment</pre></div>
<div class="nocov"><span class="num"><pre>574</pre></span><pre>	return (dagTree, sorted(typeToMFn, key=lambda t: t[0]))</pre></div>
<div class="skip"><span class="num"><pre>575</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>576</pre></span><pre>#} END functions </pre></div>
<div class="skip"><span class="num"><pre>577</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>578</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>579</pre></span><pre>#{ Code Generators </pre></div>
<div class="skip"><span class="num"><pre>580</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>581</pre></span><pre>class MFnCodeGeneratorBase(object):</pre></div>
<div class="cov"><span class="num"><pre>582</pre></span><pre>	&quot;&quot;&quot;Define the interface and common utility methods to generate a string defining </pre></div>
<div class="cov"><span class="num"><pre>583</pre></span><pre>	code for a given MFnMethod according to the meta data provided by an `MMethodDescriptor`.</pre></div>
<div class="skip"><span class="num"><pre>584</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>585</pre></span><pre>	Once instantiated, it can create any number of methods&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>586</pre></span><pre>	__slots__ = 'module_dict'</pre></div>
<div class="cov"><span class="num"><pre>587</pre></span><pre>	def __init__(self, module_dict):</pre></div>
<div class="cov"><span class="num"><pre>588</pre></span><pre>		&quot;&quot;&quot;Intialize this instance&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>589</pre></span><pre>		self.module_dict = module_dict</pre></div>
<div class="skip"><span class="num"><pre>590</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>591</pre></span><pre>	#{ Utilities</pre></div>
<div class="cov"><span class="num"><pre>592</pre></span><pre>	def _toRvalFunc( self, funcname ):</pre></div>
<div class="cov"><span class="num"><pre>593</pre></span><pre>		&quot;&quot;&quot;:return: None or a function which receives the return value of our actual mfn function&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>594</pre></span><pre>		if not isinstance( funcname, basestring ):</pre></div>
<div class="nocov"><span class="num"><pre>595</pre></span><pre>			return funcname</pre></div>
<div class="cov"><span class="num"><pre>596</pre></span><pre>		if funcname == 'None': return None</pre></div>
<div class="skip"><span class="num"><pre>597</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>598</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>599</pre></span><pre>			return self.module_dict[funcname]</pre></div>
<div class="nocov"><span class="num"><pre>600</pre></span><pre>		except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>601</pre></span><pre>			raise ValueError(&quot;'%s' does not exist in code generator's dictionary&quot; % funcname )</pre></div>
<div class="skip"><span class="num"><pre>602</pre></span><pre>	#} END utilities</pre></div>
<div class="skip"><span class="num"><pre>603</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>604</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>605</pre></span><pre>	#{ Interface </pre></div>
<div class="cov"><span class="num"><pre>606</pre></span><pre>	def generateMFnClsMethodWrapper(self, source_method_name, target_method_name, mfn_fun_name, method_descriptor, flags=0):</pre></div>
<div class="cov"><span class="num"><pre>607</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>608</pre></span><pre>		:return: string containing the code for the wrapper method as configured by the </pre></div>
<div class="cov"><span class="num"><pre>609</pre></span><pre>			method descriptor</pre></div>
<div class="cov"><span class="num"><pre>610</pre></span><pre>		:param source_method_name: Original name of the method - this is the name under which </pre></div>
<div class="cov"><span class="num"><pre>611</pre></span><pre>			it was requested.</pre></div>
<div class="cov"><span class="num"><pre>612</pre></span><pre>		:param target_method_name: Name of the method in the returned code string</pre></div>
<div class="cov"><span class="num"><pre>613</pre></span><pre>		:param mfn_fun_name: original name of the MFn function</pre></div>
<div class="cov"><span class="num"><pre>614</pre></span><pre>		:param method_descriptor: instance of `MMethodDescriptor`</pre></div>
<div class="cov"><span class="num"><pre>615</pre></span><pre>		:param flags: bit flags providing additional information, depending on the actual </pre></div>
<div class="cov"><span class="num"><pre>616</pre></span><pre>			implementation. Unsupported flags are ignored.&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>617</pre></span><pre>		raise NotImplementedError(&quot;To be implemented in SubClass&quot;)</pre></div>
<div class="skip"><span class="num"><pre>618</pre></span><pre>	#} END interfacec</pre></div>
<div class="skip"><span class="num"><pre>619</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>620</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>621</pre></span><pre>class PythonMFnCodeGenerator(MFnCodeGeneratorBase):</pre></div>
<div class="cov"><span class="num"><pre>622</pre></span><pre>	&quot;&quot;&quot;Specialization to generate python code</pre></div>
<div class="skip"><span class="num"><pre>623</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>624</pre></span><pre>	**Flags**:</pre></div>
<div class="skip"><span class="num"><pre>625</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>626</pre></span><pre>	 * kDirectCall:</pre></div>
<div class="cov"><span class="num"><pre>627</pre></span><pre>	 	If set, the call return the actual mfn method in the best case, which is </pre></div>
<div class="cov"><span class="num"><pre>628</pre></span><pre>	 	a call as direct as it gets. A possibly negative side-effect would be that</pre></div>
<div class="cov"><span class="num"><pre>629</pre></span><pre>	 	it the MFnMethod caches the function set and actual MObject/MDagPath, which </pre></div>
<div class="cov"><span class="num"><pre>630</pre></span><pre>	 	can be dangerous if held too long</pre></div>
<div class="skip"><span class="num"><pre>631</pre></span><pre>	 	</pre></div>
<div class="cov"><span class="num"><pre>632</pre></span><pre>	 * kIsMObject:</pre></div>
<div class="cov"><span class="num"><pre>633</pre></span><pre>	 	If set, the type we create the method for is not derived from Node, but </pre></div>
<div class="cov"><span class="num"><pre>634</pre></span><pre>	 	from MObject. This hint is required in order to generate correct calling code.</pre></div>
<div class="skip"><span class="num"><pre>635</pre></span><pre>	 	</pre></div>
<div class="cov"><span class="num"><pre>636</pre></span><pre>	 * kIsDagNode:</pre></div>
<div class="cov"><span class="num"><pre>637</pre></span><pre>	 	If set, the type we create the method for is derived from DagNode</pre></div>
<div class="skip"><span class="num"><pre>638</pre></span><pre>	 	</pre></div>
<div class="cov"><span class="num"><pre>639</pre></span><pre>	 * kIsStatic:</pre></div>
<div class="cov"><span class="num"><pre>640</pre></span><pre>	 	If set, the method to be wrapped is considered static, no self is needed, nor</pre></div>
<div class="cov"><span class="num"><pre>641</pre></span><pre>	 	any object.</pre></div>
<div class="cov"><span class="num"><pre>642</pre></span><pre>	 	NOTE: This flag is likely to be removed as it should be part of the method_descriptor, </pre></div>
<div class="cov"><span class="num"><pre>643</pre></span><pre>	 	for now though it does not provide that information so we pass it in.</pre></div>
<div class="skip"><span class="num"><pre>644</pre></span><pre>	 	</pre></div>
<div class="cov"><span class="num"><pre>645</pre></span><pre>	 * kWithDocs:</pre></div>
<div class="cov"><span class="num"><pre>646</pre></span><pre>	 	If set, a doc string will be generated the method. In future, this information</pre></div>
<div class="cov"><span class="num"><pre>647</pre></span><pre>	 	will come from the method descriptor. Please note that docs should only be attaced</pre></div>
<div class="cov"><span class="num"><pre>648</pre></span><pre>	 	in interactive modes, otherwise its a waste of memory.</pre></div>
<div class="skip"><span class="num"><pre>649</pre></span><pre>	 </pre></div>
<div class="cov"><span class="num"><pre>650</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>651</pre></span><pre>	# IMPORTANT: If these change, update docs above, and test.maya.test_mdb and test.maya.performance.test_mdb !</pre></div>
<div class="cov"><span class="num"><pre>652</pre></span><pre>	kDirectCall, \</pre></div>
<div class="cov"><span class="num"><pre>653</pre></span><pre>	kIsMObject, \</pre></div>
<div class="cov"><span class="num"><pre>654</pre></span><pre>	kIsDagNode, \</pre></div>
<div class="cov"><span class="num"><pre>655</pre></span><pre>	kIsStatic, \</pre></div>
<div class="cov"><span class="num"><pre>656</pre></span><pre>	kWithDocs = [ 1&lt;&lt;i for i in range(5) ] </pre></div>
<div class="skip"><span class="num"><pre>657</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>658</pre></span><pre>	def generateMFnClsMethodWrapper(self, source_method_name, target_method_name, mfn_fun_name, method_descriptor, flags=0):</pre></div>
<div class="cov"><span class="num"><pre>659</pre></span><pre>		&quot;&quot;&quot;Generates code as python string which can be used to compile a function. It assumes the following </pre></div>
<div class="cov"><span class="num"><pre>660</pre></span><pre>		globals to be existing once evaluated: mfncls, mfn_fun, [rvalfunc]</pre></div>
<div class="cov"><span class="num"><pre>661</pre></span><pre>		Currently supports the following data within method_descriptor:</pre></div>
<div class="skip"><span class="num"><pre>662</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>663</pre></span><pre>		 * method_descriptor.rvalfunc</pre></div>
<div class="skip"><span class="num"><pre>664</pre></span><pre>		 </pre></div>
<div class="cov"><span class="num"><pre>665</pre></span><pre>		as well as all flags except kIsStatic.</pre></div>
<div class="cov"><span class="num"><pre>666</pre></span><pre>		:raise ValueError: if flags are incompatible with each other</pre></div>
<div class="cov"><span class="num"><pre>667</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>668</pre></span><pre>		if flags &amp; self.kIsMObject and flags &amp; self.kIsDagNode:</pre></div>
<div class="cov"><span class="num"><pre>669</pre></span><pre>			raise ValueError(&quot;kIsMObject and kIsDagNode are mutually exclusive&quot;)</pre></div>
<div class="skip"><span class="num"><pre>670</pre></span><pre>		# END handle flags</pre></div>
<div class="skip"><span class="num"><pre>671</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>672</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>673</pre></span><pre>		sio = StringIO()</pre></div>
<div class="skip"><span class="num"><pre>674</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>675</pre></span><pre>		rvalfunname = ''</pre></div>
<div class="cov"><span class="num"><pre>676</pre></span><pre>		if method_descriptor.rvalfunc != 'None':</pre></div>
<div class="cov"><span class="num"><pre>677</pre></span><pre>			rvalfunname = method_descriptor.rvalfunc</pre></div>
<div class="skip"><span class="num"><pre>678</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>679</pre></span><pre>		sio.write(&quot;def %s(self, *args, **kwargs):\n&quot; % target_method_name)</pre></div>
<div class="skip"><span class="num"><pre>680</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>681</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>682</pre></span><pre>		# mfn function call</pre></div>
<div class="cov"><span class="num"><pre>683</pre></span><pre>		mfnset = &quot;mfncls(self&quot;</pre></div>
<div class="cov"><span class="num"><pre>684</pre></span><pre>		if flags &amp; self.kIsDagNode:</pre></div>
<div class="cov"><span class="num"><pre>685</pre></span><pre>			mfnset += &quot;.dagPath()&quot;</pre></div>
<div class="cov"><span class="num"><pre>686</pre></span><pre>		elif not flags &amp; self.kIsMObject:</pre></div>
<div class="cov"><span class="num"><pre>687</pre></span><pre>			mfnset += &quot;.object()&quot;</pre></div>
<div class="cov"><span class="num"><pre>688</pre></span><pre>		mfnset += &quot;)&quot;</pre></div>
<div class="skip"><span class="num"><pre>689</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>690</pre></span><pre>		if flags &amp; self.kDirectCall:</pre></div>
<div class="cov"><span class="num"><pre>691</pre></span><pre>			curline = &quot;\tmfninstfunc = %s.%s\n&quot; % (mfnset, mfn_fun_name)</pre></div>
<div class="cov"><span class="num"><pre>692</pre></span><pre>			sio.write(curline)</pre></div>
<div class="skip"><span class="num"><pre>693</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>694</pre></span><pre>			if rvalfunname:</pre></div>
<div class="cov"><span class="num"><pre>695</pre></span><pre>				sio.write(&quot;\tmfninstfunc = lambda *args, **kwargs: rvalfun(mfninstfunc(*args, **kwargs))\n&quot;)</pre></div>
<div class="skip"><span class="num"><pre>696</pre></span><pre>			# END handle rvalfunc name</pre></div>
<div class="cov"><span class="num"><pre>697</pre></span><pre>			sio.write(&quot;\tself.%s = mfninstfunc\n&quot; % source_method_name)</pre></div>
<div class="cov"><span class="num"><pre>698</pre></span><pre>			sio.write(&quot;\treturn mfninstfunc(*args, **kwargs)&quot;)</pre></div>
<div class="cov"><span class="num"><pre>699</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>700</pre></span><pre>			curline = &quot;mfn_fun(%s, *args, **kwargs)&quot; % mfnset</pre></div>
<div class="cov"><span class="num"><pre>701</pre></span><pre>			if rvalfunname:</pre></div>
<div class="cov"><span class="num"><pre>702</pre></span><pre>				curline = &quot;rvalfunc(%s)&quot; % curline</pre></div>
<div class="cov"><span class="num"><pre>703</pre></span><pre>			sio.write(&quot;\treturn %s&quot; % curline)</pre></div>
<div class="skip"><span class="num"><pre>704</pre></span><pre>		# END handle direct call</pre></div>
<div class="skip"><span class="num"><pre>705</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>706</pre></span><pre>		return sio.getvalue()</pre></div>
<div class="skip"><span class="num"><pre>707</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>708</pre></span><pre>	#{ Interface</pre></div>
<div class="skip"><span class="num"><pre>709</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>710</pre></span><pre>	def generateMFnClsMethodWrapperMethod(self, source_method_name, target_method_name, mfncls, mfn_fun, method_descriptor, flags=0):</pre></div>
<div class="cov"><span class="num"><pre>711</pre></span><pre>		&quot;&quot;&quot;:return: python function suitable to be installed on a class</pre></div>
<div class="cov"><span class="num"><pre>712</pre></span><pre>		:param mfncls: MFnFunction set class from which the method was retrieved.</pre></div>
<div class="cov"><span class="num"><pre>713</pre></span><pre>		:param mfn_fun: function as retrieved from the function set's dict. Its a bare function.</pre></div>
<div class="cov"><span class="num"><pre>714</pre></span><pre>		:note: For all other args, see `MFnCodeGeneratorBase.generateMFnClsMethodWrapper`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>715</pre></span><pre>		rvalfunc = self._toRvalFunc(method_descriptor.rvalfunc)</pre></div>
<div class="cov"><span class="num"><pre>716</pre></span><pre>		mfnfuncname = mfn_fun.__name__</pre></div>
<div class="skip"><span class="num"><pre>717</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>718</pre></span><pre>		# handle MFnName_function</pre></div>
<div class="cov"><span class="num"><pre>719</pre></span><pre>		if mfnfuncname.startswith(mfncls.__name__):</pre></div>
<div class="cov"><span class="num"><pre>720</pre></span><pre>			mfnfuncname = mfnfuncname[len(mfncls.__name__)+1:]</pre></div>
<div class="skip"><span class="num"><pre>721</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>722</pre></span><pre>		new_method = None</pre></div>
<div class="cov"><span class="num"><pre>723</pre></span><pre>		if flags &amp; self.kIsStatic:</pre></div>
<div class="skip"><span class="num"><pre>724</pre></span><pre>			# use the function directly</pre></div>
<div class="cov"><span class="num"><pre>725</pre></span><pre>			rvalfun = self._toRvalFunc(method_descriptor.rvalfunc)</pre></div>
<div class="cov"><span class="num"><pre>726</pre></span><pre>			if rvalfun is None:</pre></div>
<div class="cov"><span class="num"><pre>727</pre></span><pre>				new_method = mfn_fun</pre></div>
<div class="cov"><span class="num"><pre>728</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>729</pre></span><pre>				fun = lambda *args, **kwargs: rvalfun(mfn_fun(*args, **kwargs))</pre></div>
<div class="cov"><span class="num"><pre>730</pre></span><pre>				fun.__name__ = target_method_name</pre></div>
<div class="cov"><span class="num"><pre>731</pre></span><pre>				new_method = fun</pre></div>
<div class="skip"><span class="num"><pre>732</pre></span><pre>			# END </pre></div>
<div class="cov"><span class="num"><pre>733</pre></span><pre>		else:</pre></div>
<div class="skip"><span class="num"><pre>734</pre></span><pre>			# get the compiled code</pre></div>
<div class="cov"><span class="num"><pre>735</pre></span><pre>			codestr = self.generateMFnClsMethodWrapper(source_method_name, target_method_name, mfnfuncname, method_descriptor, flags)</pre></div>
<div class="cov"><span class="num"><pre>736</pre></span><pre>			code = compile(codestr, &quot;mrv/%s&quot; % (mfncls.__name__+&quot;.py&quot;), &quot;exec&quot;)	# this operation is expensive !</pre></div>
<div class="skip"><span class="num"><pre>737</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>738</pre></span><pre>			# get the function into our local dict, globals are our locals</pre></div>
<div class="cov"><span class="num"><pre>739</pre></span><pre>			eval(code, locals())</pre></div>
<div class="skip"><span class="num"><pre>740</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>741</pre></span><pre>			new_method = locals()[target_method_name]</pre></div>
<div class="skip"><span class="num"><pre>742</pre></span><pre>		# END handle static methods</pre></div>
<div class="skip"><span class="num"><pre>743</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>744</pre></span><pre>		if flags &amp; self.kWithDocs:</pre></div>
<div class="cov"><span class="num"><pre>745</pre></span><pre>			if hasattr(new_method, 'func_doc'):</pre></div>
<div class="cov"><span class="num"><pre>746</pre></span><pre>				new_method.func_doc = &quot;%s.%s&quot; % (mfncls.__name__, mfnfuncname)</pre></div>
<div class="skip"><span class="num"><pre>747</pre></span><pre>		# END attach generated doc string</pre></div>
<div class="skip"><span class="num"><pre>748</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>749</pre></span><pre>		return new_method</pre></div>
<div class="skip"><span class="num"><pre>750</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>751</pre></span><pre>	#} END interface</pre></div>
<div class="skip"><span class="num"><pre>752</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>753</pre></span><pre>#} END code generators</pre></div>
<div class="skip"><span class="num"><pre>754</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>755</pre></span><pre>#{ Parsers</pre></div>
<div class="skip"><span class="num"><pre>756</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>757</pre></span><pre>class CppHeaderParser(object):</pre></div>
<div class="cov"><span class="num"><pre>758</pre></span><pre>	&quot;&quot;&quot;Simplistic regex based parser which will extract information from the file</pre></div>
<div class="cov"><span class="num"><pre>759</pre></span><pre>	it was initialized with.</pre></div>
<div class="skip"><span class="num"><pre>760</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>761</pre></span><pre>	For now its so simple that there is no more than one method&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>762</pre></span><pre>	reEnums = re.compile( r&quot;&quot;&quot;^\s+ enum \s+ (?P&lt;name&gt;\w+) \s* \{                 # enum EnumName</pre></div>
<div class="cov"><span class="num"><pre>763</pre></span><pre>                               (?P&lt;members&gt;[\(\)/\w\s,\-+=&quot;'\.\#!&lt;\*\\]+)     # match whitespace or newlines</pre></div>
<div class="cov"><span class="num"><pre>764</pre></span><pre>                               \}[ \t]*;[ \t]*$                                 # closing brace&quot;&quot;&quot;, </pre></div>
<div class="cov"><span class="num"><pre>765</pre></span><pre>							  re.MULTILINE|re.VERBOSE)</pre></div>
<div class="skip"><span class="num"><pre>766</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>767</pre></span><pre>	reEnumMembers = re.compile( &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>768</pre></span><pre>	                           [\t ]{2,}                                        # assure we don't get something within the comment</pre></div>
<div class="cov"><span class="num"><pre>769</pre></span><pre>								(k\w+)[ ]*                                       # find kSomething</pre></div>
<div class="cov"><span class="num"><pre>770</pre></span><pre>								(?:=[ ]*[\w]+[ ]*)?                              # optionally find initializer = int|other_enum_member</pre></div>
<div class="cov"><span class="num"><pre>771</pre></span><pre>								&quot;&quot;&quot;, re.VERBOSE)</pre></div>
<div class="skip"><span class="num"><pre>772</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>773</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>774</pre></span><pre>	def parseAndExtract(cls, header_filepath, parse_enums=True):</pre></div>
<div class="cov"><span class="num"><pre>775</pre></span><pre>		&quot;&quot;&quot;Parse the given header file and return the parsed information</pre></div>
<div class="skip"><span class="num"><pre>776</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>777</pre></span><pre>		:param header_filepath: Path pointing to the given header file. Its currently</pre></div>
<div class="cov"><span class="num"><pre>778</pre></span><pre>			assumed to be 7 bit ascii</pre></div>
<div class="cov"><span class="num"><pre>779</pre></span><pre>		:param parse_enums: If True, enumerations will be parsed from the file. If </pre></div>
<div class="cov"><span class="num"><pre>780</pre></span><pre>			False, the enumeration tuple in the return value will be empty.</pre></div>
<div class="cov"><span class="num"><pre>781</pre></span><pre>		:note: Currently we can only parse non-anonymous enumerations !</pre></div>
<div class="cov"><span class="num"><pre>782</pre></span><pre>		:return: tuple(tuple(MEnumDescriptor, ...), )&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>783</pre></span><pre>		enum_list = list()</pre></div>
<div class="skip"><span class="num"><pre>784</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>785</pre></span><pre>		# ENUMERATIONS</pre></div>
<div class="skip"><span class="num"><pre>786</pre></span><pre>		##############</pre></div>
<div class="skip"><span class="num"><pre>787</pre></span><pre>		# read everything, but skip the license text when matching</pre></div>
<div class="cov"><span class="num"><pre>788</pre></span><pre>		if parse_enums:</pre></div>
<div class="cov"><span class="num"><pre>789</pre></span><pre>			read_method = header_filepath.bytes</pre></div>
<div class="skip"><span class="num"><pre>790</pre></span><pre>			# on windows, we have \r\n newlines, which are automatically </pre></div>
<div class="skip"><span class="num"><pre>791</pre></span><pre>			# converted to \n by the .text method. This might be a bit slower, </pre></div>
<div class="skip"><span class="num"><pre>792</pre></span><pre>			# so we only do it on windows</pre></div>
<div class="cov"><span class="num"><pre>793</pre></span><pre>			if os.name == 'nt':</pre></div>
<div class="nocov"><span class="num"><pre>794</pre></span><pre>				read_method = header_filepath.text</pre></div>
<div class="skip"><span class="num"><pre>795</pre></span><pre>			# END handle newline sequence</pre></div>
<div class="skip"><span class="num"><pre>796</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>797</pre></span><pre>			header = read_method()</pre></div>
<div class="cov"><span class="num"><pre>798</pre></span><pre>			for enummatch in cls.reEnums.finditer(header, 2188):</pre></div>
<div class="cov"><span class="num"><pre>799</pre></span><pre>				ed = MEnumDescriptor(enummatch.group('name'))</pre></div>
<div class="skip"><span class="num"><pre>800</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>801</pre></span><pre>				# parse all occurrences of kSomething, including the initializer</pre></div>
<div class="cov"><span class="num"><pre>802</pre></span><pre>				members = enummatch.group('members')</pre></div>
<div class="cov"><span class="num"><pre>803</pre></span><pre>				assert members</pre></div>
<div class="cov"><span class="num"><pre>804</pre></span><pre>				for memmatch in cls.reEnumMembers.finditer(members):</pre></div>
<div class="cov"><span class="num"><pre>805</pre></span><pre>					ed.append(memmatch.group(1))</pre></div>
<div class="skip"><span class="num"><pre>806</pre></span><pre>				# END for each member to add</pre></div>
<div class="skip"><span class="num"><pre>807</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>808</pre></span><pre>				enum_list.append(ed)</pre></div>
<div class="skip"><span class="num"><pre>809</pre></span><pre>			# END for each match</pre></div>
<div class="skip"><span class="num"><pre>810</pre></span><pre>		# END if enums should be parsed</pre></div>
<div class="skip"><span class="num"><pre>811</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>812</pre></span><pre>		# METHODS </pre></div>
<div class="skip"><span class="num"><pre>813</pre></span><pre>		#########</pre></div>
<div class="skip"><span class="num"><pre>814</pre></span><pre>		# TODO:</pre></div>
<div class="skip"><span class="num"><pre>815</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>816</pre></span><pre>		return (tuple(enum_list), )</pre></div>
<div class="skip"><span class="num"><pre>817</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>818</pre></span><pre>#} END parsers </pre></div>
<div class="skip"><span class="num"><pre>819</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>820</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>821</pre></span><pre>#{ Database</pre></div>
<div class="skip"><span class="num"><pre>822</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>823</pre></span><pre>class MMethodDescriptor(object):</pre></div>
<div class="cov"><span class="num"><pre>824</pre></span><pre>	&quot;&quot;&quot;Contains meta-information about a given method according to data read from </pre></div>
<div class="cov"><span class="num"><pre>825</pre></span><pre>	the MFnDatabase&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>826</pre></span><pre>	__slots__ = (&quot;flag&quot;, &quot;rvalfunc&quot;, &quot;newname&quot;)</pre></div>
<div class="skip"><span class="num"><pre>827</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>828</pre></span><pre>	def __init__( self, flag='', rvalfunc = None, newname=&quot;&quot; ):</pre></div>
<div class="cov"><span class="num"><pre>829</pre></span><pre>		self.flag = flag</pre></div>
<div class="cov"><span class="num"><pre>830</pre></span><pre>		self.rvalfunc = rvalfunc</pre></div>
<div class="cov"><span class="num"><pre>831</pre></span><pre>		self.newname = newname</pre></div>
<div class="skip"><span class="num"><pre>832</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>833</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>834</pre></span><pre>class MEnumDescriptor(list):</pre></div>
<div class="cov"><span class="num"><pre>835</pre></span><pre>	&quot;&quot;&quot;Is an ordered list of enumeration names without its values, together</pre></div>
<div class="cov"><span class="num"><pre>836</pre></span><pre>	with the name of the enumeration type&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>837</pre></span><pre>	__slots__ = &quot;name&quot;</pre></div>
<div class="cov"><span class="num"><pre>838</pre></span><pre>	def __init__(self, name):</pre></div>
<div class="cov"><span class="num"><pre>839</pre></span><pre>		self.name = name</pre></div>
<div class="skip"><span class="num"><pre>840</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>841</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>842</pre></span><pre>class MMemberMap( UserDict.UserDict ):</pre></div>
<div class="cov"><span class="num"><pre>843</pre></span><pre>	&quot;&quot;&quot;Simple accessor for MFnDatabase access</pre></div>
<div class="cov"><span class="num"><pre>844</pre></span><pre>	Direct access like db[funcname] returns an entry object with all values</pre></div>
<div class="skip"><span class="num"><pre>845</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>846</pre></span><pre>	**Globals**:</pre></div>
<div class="cov"><span class="num"><pre>847</pre></span><pre>	The __globals__ entry in MFn db files allows to pass additional options.</pre></div>
<div class="cov"><span class="num"><pre>848</pre></span><pre>	Currently there are no supported flags&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>849</pre></span><pre>	__slots__ = (&quot;flags&quot;, &quot;enums&quot;)</pre></div>
<div class="cov"><span class="num"><pre>850</pre></span><pre>	kDelete = 'x'</pre></div>
<div class="skip"><span class="num"><pre>851</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>852</pre></span><pre>	def __init__( self, filepath = None, parse_enums=False ):</pre></div>
<div class="cov"><span class="num"><pre>853</pre></span><pre>		&quot;&quot;&quot;intiialize self from a file if not None</pre></div>
<div class="skip"><span class="num"><pre>854</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>855</pre></span><pre>		:param parse_enums: if True, enumerations will be parsed. Save time by specifying</pre></div>
<div class="cov"><span class="num"><pre>856</pre></span><pre>			False in case you know that there are no enumerations&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>857</pre></span><pre>		UserDict.UserDict.__init__( self )</pre></div>
<div class="skip"><span class="num"><pre>858</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>859</pre></span><pre>		self._filepath = filepath</pre></div>
<div class="cov"><span class="num"><pre>860</pre></span><pre>		if filepath:</pre></div>
<div class="cov"><span class="num"><pre>861</pre></span><pre>			self._initFromFile( filepath )</pre></div>
<div class="skip"><span class="num"><pre>862</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>863</pre></span><pre>		# initialize globals</pre></div>
<div class="cov"><span class="num"><pre>864</pre></span><pre>		self.flags = 0</pre></div>
<div class="cov"><span class="num"><pre>865</pre></span><pre>		ge = self.get('__global__', None)</pre></div>
<div class="cov"><span class="num"><pre>866</pre></span><pre>		if ge is not None:</pre></div>
<div class="skip"><span class="num"><pre>867</pre></span><pre>			# currently we know none</pre></div>
<div class="nocov"><span class="num"><pre>868</pre></span><pre>			pass</pre></div>
<div class="skip"><span class="num"><pre>869</pre></span><pre>		# END fetch info</pre></div>
<div class="skip"><span class="num"><pre>870</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>871</pre></span><pre>		# INITIALIZE PARSED DATA</pre></div>
<div class="cov"><span class="num"><pre>872</pre></span><pre>		self.enums = tuple()</pre></div>
<div class="cov"><span class="num"><pre>873</pre></span><pre>		if parse_enums:</pre></div>
<div class="cov"><span class="num"><pre>874</pre></span><pre>			self.enums, = CppHeaderParser.parseAndExtract(headerPath(filepath.namebase()))</pre></div>
<div class="skip"><span class="num"><pre>875</pre></span><pre>		# END if enumerations should be parsed</pre></div>
<div class="skip"><span class="num"><pre>876</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>877</pre></span><pre>	def __str__( self ):</pre></div>
<div class="nocov"><span class="num"><pre>878</pre></span><pre>		return &quot;MMemberMap(%s)&quot; % self._filepath</pre></div>
<div class="skip"><span class="num"><pre>879</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>880</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>881</pre></span><pre>	def _initFromFile( self, filepath ):</pre></div>
<div class="cov"><span class="num"><pre>882</pre></span><pre>		&quot;&quot;&quot;Initialize the database with values from the given file</pre></div>
<div class="skip"><span class="num"><pre>883</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>884</pre></span><pre>		:note: the file must have been written using the `writeToFile` method&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>885</pre></span><pre>		self.clear()</pre></div>
<div class="cov"><span class="num"><pre>886</pre></span><pre>		fobj = open( filepath, 'r' )</pre></div>
<div class="skip"><span class="num"><pre>887</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>888</pre></span><pre>		pf = PipeSeparatedFile( fobj )</pre></div>
<div class="cov"><span class="num"><pre>889</pre></span><pre>		pf.beginReading( )</pre></div>
<div class="skip"><span class="num"><pre>890</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>891</pre></span><pre>		# get the entries</pre></div>
<div class="cov"><span class="num"><pre>892</pre></span><pre>		for tokens in pf.readColumnLine( ):</pre></div>
<div class="cov"><span class="num"><pre>893</pre></span><pre>			key = tokens[ 1 ]</pre></div>
<div class="cov"><span class="num"><pre>894</pre></span><pre>			self[ key ] = MMethodDescriptor( flag=tokens[0], rvalfunc=tokens[2], newname=tokens[3] )</pre></div>
<div class="skip"><span class="num"><pre>895</pre></span><pre>		# END for each token in read column line</pre></div>
<div class="skip"><span class="num"><pre>896</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>897</pre></span><pre>	def writeToFile( self, filepath ):</pre></div>
<div class="cov"><span class="num"><pre>898</pre></span><pre>		&quot;&quot;&quot;Write our database contents to the given file&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>899</pre></span><pre>		klist = self.keys()</pre></div>
<div class="nocov"><span class="num"><pre>900</pre></span><pre>		klist.sort()</pre></div>
<div class="skip"><span class="num"><pre>901</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>902</pre></span><pre>		fobj = open( filepath, 'w' )</pre></div>
<div class="nocov"><span class="num"><pre>903</pre></span><pre>		pf = PipeSeparatedFile( fobj )</pre></div>
<div class="nocov"><span class="num"><pre>904</pre></span><pre>		pf.beginWriting( ( 4,40,20,40 ) )</pre></div>
<div class="skip"><span class="num"><pre>905</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>906</pre></span><pre>		for key in klist:							# write entries</pre></div>
<div class="nocov"><span class="num"><pre>907</pre></span><pre>			e = self[ key ]</pre></div>
<div class="nocov"><span class="num"><pre>908</pre></span><pre>			pf.writeTokens( ( e.flag, key,e.rvalfunc, e.newname ) )</pre></div>
<div class="skip"><span class="num"><pre>909</pre></span><pre>		# end for each key</pre></div>
<div class="skip"><span class="num"><pre>910</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>911</pre></span><pre>		fobj.close()</pre></div>
<div class="skip"><span class="num"><pre>912</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>913</pre></span><pre>	def methodByName( self, funcname ):</pre></div>
<div class="cov"><span class="num"><pre>914</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>915</pre></span><pre>		:return: Tuple( mfnfuncname, entry )</pre></div>
<div class="cov"><span class="num"><pre>916</pre></span><pre>			original mfnclass function name paired with the</pre></div>
<div class="cov"><span class="num"><pre>917</pre></span><pre>			db entry containing more information</pre></div>
<div class="cov"><span class="num"><pre>918</pre></span><pre>		:raise KeyError: if no such function exists&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>919</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>920</pre></span><pre>			return ( funcname, self[ funcname ] )</pre></div>
<div class="cov"><span class="num"><pre>921</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>922</pre></span><pre>			for mfnfuncname,entry in self.iteritems():</pre></div>
<div class="cov"><span class="num"><pre>923</pre></span><pre>				if entry.newname == funcname:</pre></div>
<div class="cov"><span class="num"><pre>924</pre></span><pre>					return ( mfnfuncname, entry )</pre></div>
<div class="skip"><span class="num"><pre>925</pre></span><pre>			# END for each item</pre></div>
<div class="skip"><span class="num"><pre>926</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>927</pre></span><pre>		raise KeyError( &quot;Function named '%s' did not exist in db&quot; % funcname )</pre></div>
<div class="skip"><span class="num"><pre>928</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>929</pre></span><pre>	def createEntry( self, funcname ):</pre></div>
<div class="cov"><span class="num"><pre>930</pre></span><pre>		&quot;&quot;&quot; Create an entry for the given function, or return the existing one</pre></div>
<div class="skip"><span class="num"><pre>931</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>932</pre></span><pre>		:return: Entry object for funcname&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>933</pre></span><pre>		return self.setdefault( funcname, MMethodDescriptor() )</pre></div>
<div class="skip"><span class="num"><pre>934</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>935</pre></span><pre>	def mfnFunc( self, funcname ):</pre></div>
<div class="cov"><span class="num"><pre>936</pre></span><pre>		&quot;&quot;&quot;:return: mfn functionname corresponding to the ( possibly renamed ) funcname &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>937</pre></span><pre>		return self.methodByName( funcname )[0]</pre></div>
<div class="skip"><span class="num"><pre>938</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>939</pre></span><pre>#} END database</pre></div>
<div class="skip"><span class="num"><pre>940</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>941</pre></span><pre></pre></div>
</div>
</body>
</html>
