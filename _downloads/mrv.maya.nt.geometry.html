<html>
<head>
<title>mrv.maya.nt.geometry</title>
</head>
<body>
mrv.maya.nt.geometry
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 258 lines<br/>
Missed: 15 lines<br/>
Skipped 159 lines<br/>
Percent: 94 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot; Contains implementations ( or improvements ) to mayas geometric shapes &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>  4</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>import base</pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>from mrv.enum import (create as enum, Element as elm)</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>import maya.OpenMaya as api</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>log = logging.getLogger(&quot;mrv.maya.nt.geometry&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 10</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>__all__ = (&quot;GeometryShape&quot;, &quot;DeformableShape&quot;, &quot;ControlPoint&quot;, &quot;SurfaceShape&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>	       &quot;Mesh&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 13</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>class GeometryShape( base.Shape ):	# base for epydoc !</pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>	&quot;&quot;&quot;Contains common methods for all geometry types&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>	def copyLightLinks( self, other, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>		&quot;&quot;&quot;Copy lightlinks from one meshShape to another</pre></div>
<div class="skip"><span class="num"><pre> 19</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 20</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre> 21</pre></span><pre>			 * substitute: </pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>			 	if True, default False, the other shape will be put</pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>				in place of self, effectively receiving it's light-links whereas self losses</pre></div>
<div class="cov"><span class="num"><pre> 24</pre></span><pre>				them. This is practical in case you create a new shape below a transform that</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>				had a previously visible and manipulated shape whose external connections you</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>				wouuld like to keep&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>		def freeLogicalIndex( parent_plug ):</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>			&quot;&quot;&quot;:return: a free parent compound index&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>			ilogical = parent_plug.logicalIndex()</pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>			array_plug = parent_plug.array()</pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>			num_elments = array_plug.numElements()</pre></div>
<div class="skip"><span class="num"><pre> 32</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 33</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 34</pre></span><pre>			# one of the logical indices must be the highest one - start searching</pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre>			# at the end of the physical array</pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>			for iphysical in xrange( num_elments - 1, -1, -1 ):</pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>				p_plug = array_plug[ iphysical ]</pre></div>
<div class="cov"><span class="num"><pre> 38</pre></span><pre>				try_index = p_plug.logicalIndex() + 1</pre></div>
<div class="cov"><span class="num"><pre> 39</pre></span><pre>				try_plug = array_plug.elementByLogicalIndex( try_index )</pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>				if try_plug.child( 0 ).minput().isNull():</pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>					return try_index</pre></div>
<div class="skip"><span class="num"><pre> 43</pre></span><pre>			# END endless loop</pre></div>
<div class="skip"><span class="num"><pre> 44</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre> 45</pre></span><pre>			raise AssertionError( &quot;Did not find valid free index&quot; )</pre></div>
<div class="skip"><span class="num"><pre> 46</pre></span><pre>		# END helper method</pre></div>
<div class="skip"><span class="num"><pre> 47</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>		substitute = kwargs.get( &quot;substitute&quot;, False )</pre></div>
<div class="cov"><span class="num"><pre> 49</pre></span><pre>		for input_plug in self.message.moutputs():</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>			node = input_plug.mwrappedNode()</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>			if node.apiType() != api.MFn.kLightLink:</pre></div>
<div class="nocov"><span class="num"><pre> 52</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre> 53</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 54</pre></span><pre>			# we are always connected to the object portion of the compound model</pre></div>
<div class="skip"><span class="num"><pre> 55</pre></span><pre>			# from there we can conclude it all</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>			parent_compound = input_plug.mparent()</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>			target_compound_index = -1</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>			if substitute:</pre></div>
<div class="cov"><span class="num"><pre> 59</pre></span><pre>				target_compound_index = parent_compound.logicalIndex()</pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>				target_compound_index = freeLogicalIndex(parent_compound)</pre></div>
<div class="skip"><span class="num"><pre> 62</pre></span><pre>			# END get some logical index</pre></div>
<div class="skip"><span class="num"><pre> 63</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>			new_parent_compound = parent_compound.array().elementByLogicalIndex( target_compound_index )</pre></div>
<div class="skip"><span class="num"><pre> 65</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 66</pre></span><pre>			# retrieve light link, connect other - light is only needed if we do not</pre></div>
<div class="skip"><span class="num"><pre> 67</pre></span><pre>			# substitute</pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>			if not substitute:</pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>				light_plug = parent_compound.child( 0 ).minput()</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>				if not light_plug.isNull():</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>					light_plug.mconnectTo(new_parent_compound.child( 0 ), force=False)</pre></div>
<div class="skip"><span class="num"><pre> 72</pre></span><pre>				# END if lightplug is connected</pre></div>
<div class="skip"><span class="num"><pre> 73</pre></span><pre>			# END if no substitute required</pre></div>
<div class="skip"><span class="num"><pre> 74</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 75</pre></span><pre>			# connect object</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>			other.message.mconnectTo(new_parent_compound.child(1))</pre></div>
<div class="skip"><span class="num"><pre> 77</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 78</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 79</pre></span><pre>		# END for each output plug</pre></div>
<div class="skip"><span class="num"><pre> 80</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 81</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 82</pre></span><pre>class DeformableShape( GeometryShape ):	# base for epydoc !</pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre> 84</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 85</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>class ControlPoint( DeformableShape ):		# base for epydoc !</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre> 88</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 89</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>class SurfaceShape( ControlPoint ):	# base for epydoc !</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre> 92</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 93</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 94</pre></span><pre>#{ Helpers </pre></div>
<div class="skip"><span class="num"><pre> 95</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>class _SingleIndexedComponentGenerator(object):</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>	&quot;&quot;&quot;Utility producing components, initialized with the given indices. See `Mesh`</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>	for more info. &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>	__slots__ = ('_mesh', '_component')</pre></div>
<div class="skip"><span class="num"><pre>100</pre></span><pre>	# to detect slices, funny thing to remark: Maya passes 1 &lt;&lt; 31 - 1 for some reason</pre></div>
<div class="skip"><span class="num"><pre>101</pre></span><pre>	# we want to be smaller, hence -2</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>	_int32b = ( 1 &lt;&lt; 31 ) - 2</pre></div>
<div class="skip"><span class="num"><pre>103</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>	def __init__(self, mesh, component):</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>		self._mesh = mesh</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>		self._component = component</pre></div>
<div class="skip"><span class="num"><pre>107</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>	def __getslice__(self, i, j):</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>		comp = self._mesh.component(self._component)</pre></div>
<div class="skip"><span class="num"><pre>110</pre></span><pre>		# for some reason , python inside maya returns 31 bit ints to indicate </pre></div>
<div class="skip"><span class="num"><pre>111</pre></span><pre>		# slices, instead of sys.maxint. To be sure we handle all, we just </pre></div>
<div class="skip"><span class="num"><pre>112</pre></span><pre>		# check larger/than cases</pre></div>
<div class="skip"><span class="num"><pre>113</pre></span><pre>		# handle [:] slices</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>		if j &gt; self._int32b:</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>			comp.setComplete(1)</pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>			comp.addElements(api.MIntArray.mfromRange(i, j))</pre></div>
<div class="skip"><span class="num"><pre>118</pre></span><pre>		# END handle slice range </pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>		return comp</pre></div>
<div class="skip"><span class="num"><pre>120</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>	def __getitem__(self, *args):</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>		comp = self._mesh.component(self._component)</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>		ia = None</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>		if len(args) == 1:</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>			arg = args[0]</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>			if hasattr(arg, 'next'):</pre></div>
<div class="cov"><span class="num"><pre>127</pre></span><pre>				ia = api.MIntArray.mfromIter(arg)</pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>			elif isinstance(arg, (list, tuple)):</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>				ia = api.MIntArray.mfromList(arg)</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>			elif isinstance(arg, api.MIntArray):</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>				ia = arg</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>				ia = api.MIntArray.mfromMultiple(arg)</pre></div>
<div class="skip"><span class="num"><pre>134</pre></span><pre>			# END handle type</pre></div>
<div class="nocov"><span class="num"><pre>135</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>136</pre></span><pre>			ia = api.MIntArray.mfromList(args)</pre></div>
<div class="skip"><span class="num"><pre>137</pre></span><pre>		# END handle args</pre></div>
<div class="skip"><span class="num"><pre>138</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>		return comp.addElements(ia)</pre></div>
<div class="skip"><span class="num"><pre>140</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>	def empty(self):</pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>		&quot;&quot;&quot;:return: empty component of our type&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>		return self._mesh.component(self._component)</pre></div>
<div class="skip"><span class="num"><pre>144</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>145</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>class _SingleIndexedComponentIterator(_SingleIndexedComponentGenerator):</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>	&quot;&quot;&quot;Utility which produces iterators for the component type</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>	it was initialized with. As a bonus, it allows to return </pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>	quick constrained iterators using the slice and get-item notation&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>150</pre></span><pre>	__slots__ = tuple()</pre></div>
<div class="skip"><span class="num"><pre>151</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>	def __iter__(self):</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>		return iter(self._get_complete_iterator())</pre></div>
<div class="skip"><span class="num"><pre>154</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>155</pre></span><pre>	def _get_complete_iterator(self):</pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>		return self._mesh.iterComponents(self._component)</pre></div>
<div class="skip"><span class="num"><pre>157</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>158</pre></span><pre>	def _check_component(self):</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>		:raise NotImplementedError: if comp needs double-index component, our interface</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>			cannot support anything else than SingleIndex components&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>162</pre></span><pre>		if self._component == Mesh.eComponentType.uv:</pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>			raise NotImplementedError(&quot;This Utility does not support iteration using \</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>				component-constrained iterators as it can only reproduce \</pre></div>
<div class="cov"><span class="num"><pre>165</pre></span><pre>				SingleIndexedComponents - create the Component yourself and \</pre></div>
<div class="cov"><span class="num"><pre>166</pre></span><pre>				use iterComponents to retrieve the iterator instead&quot;)</pre></div>
<div class="skip"><span class="num"><pre>167</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>168</pre></span><pre>	def __getslice__(self, i, j):</pre></div>
<div class="cov"><span class="num"><pre>169</pre></span><pre>		self._check_component()</pre></div>
<div class="skip"><span class="num"><pre>170</pre></span><pre>		# skip full slices, as in fact no components are needed there.</pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>		if j &gt; self._int32b:</pre></div>
<div class="cov"><span class="num"><pre>172</pre></span><pre>			return self._get_complete_iterator()</pre></div>
<div class="skip"><span class="num"><pre>173</pre></span><pre>		# END handle [:] slice</pre></div>
<div class="skip"><span class="num"><pre>174</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>		comp = super(_SingleIndexedComponentIterator, self).__getslice__(i,j)</pre></div>
<div class="cov"><span class="num"><pre>176</pre></span><pre>		return self._mesh.iterComponents(self._component, comp)</pre></div>
<div class="skip"><span class="num"><pre>177</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>	def __getitem__(self, *args):</pre></div>
<div class="cov"><span class="num"><pre>179</pre></span><pre>		self._check_component()</pre></div>
<div class="cov"><span class="num"><pre>180</pre></span><pre>		comp = super(_SingleIndexedComponentIterator, self).__getitem__(*args)</pre></div>
<div class="cov"><span class="num"><pre>181</pre></span><pre>		return self._mesh.iterComponents(self._component, comp) </pre></div>
<div class="skip"><span class="num"><pre>182</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>183</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>	def iterator(self):</pre></div>
<div class="cov"><span class="num"><pre>185</pre></span><pre>		&quot;&quot;&quot;:return: Iterator for all components in the mesh&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>186</pre></span><pre>		return self._get_complete_iterator()</pre></div>
<div class="skip"><span class="num"><pre>187</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>188</pre></span><pre>	# shortcut alias</pre></div>
<div class="cov"><span class="num"><pre>189</pre></span><pre>	iter = property(iterator)</pre></div>
<div class="skip"><span class="num"><pre>190</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>191</pre></span><pre>#} END helpers </pre></div>
<div class="skip"><span class="num"><pre>192</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>194</pre></span><pre>class Mesh( SurfaceShape ):		# base for epydoc !</pre></div>
<div class="cov"><span class="num"><pre>195</pre></span><pre>	&quot;&quot;&quot;Implemnetation of mesh related methods to make its handling more</pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>	convenient</pre></div>
<div class="skip"><span class="num"><pre>197</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>198</pre></span><pre>	**Component Access**:</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>		&gt;&gt;&gt; m.cvtx[:]                   # a complete set of components</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>		&gt;&gt;&gt; m.cvtx[1:4]                 # initialized with 3 indices</pre></div>
<div class="cov"><span class="num"><pre>202</pre></span><pre>		&gt;&gt;&gt; m.cvtx[1]                   # initialized with a single index</pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>		&gt;&gt;&gt; m.cvtx[1,2,3]               # initialized with multiple indices</pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>		&gt;&gt;&gt; m.cf[(1,2,3)]               # initialized with list or tuple</pre></div>
<div class="cov"><span class="num"><pre>205</pre></span><pre>		&gt;&gt;&gt; m.ce[iter(1,2,3)]           # initialized from iterator</pre></div>
<div class="cov"><span class="num"><pre>206</pre></span><pre>		&gt;&gt;&gt; m.ce[api.MIntArray()]       # initialized from MIntArray</pre></div>
<div class="skip"><span class="num"><pre>207</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>209</pre></span><pre>	# component types that make up a mesh</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>	eComponentType = enum( elm(&quot;vertex&quot;, api.MFn.kMeshVertComponent), </pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>							elm(&quot;edge&quot;, api.MFn.kMeshEdgeComponent ), </pre></div>
<div class="cov"><span class="num"><pre>212</pre></span><pre>							elm(&quot;face&quot;, api.MFn.kMeshPolygonComponent ), </pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>							elm(&quot;uv&quot;, api.MFn.kMeshMapComponent ) )</pre></div>
<div class="skip"><span class="num"><pre>214</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>215</pre></span><pre>	#{ Iterator Shortcuts</pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>	def _make_component_getter(cls, component):</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>		def internal(self):</pre></div>
<div class="cov"><span class="num"><pre>218</pre></span><pre>			return cls(self, component)</pre></div>
<div class="skip"><span class="num"><pre>219</pre></span><pre>		# END internal method</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>		return internal</pre></div>
<div class="skip"><span class="num"><pre>221</pre></span><pre>	# END pseudo-decorator</pre></div>
<div class="skip"><span class="num"><pre>222</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>223</pre></span><pre>	# SETUP ITERATOR SHORTCUTS</pre></div>
<div class="cov"><span class="num"><pre>224</pre></span><pre>	for shortname, component in zip(('vtx', 'e', 'f', 'map'), eComponentType):</pre></div>
<div class="cov"><span class="num"><pre>225</pre></span><pre>		locals()[shortname] = property(_make_component_getter(_SingleIndexedComponentIterator, component))</pre></div>
<div class="skip"><span class="num"><pre>226</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>	# SETUP COMPONENT SHORTCUTS</pre></div>
<div class="cov"><span class="num"><pre>228</pre></span><pre>	for shortname, component in zip(('cvtx', 'ce', 'cf', 'cmap'), eComponentType):</pre></div>
<div class="cov"><span class="num"><pre>229</pre></span><pre>		locals()[shortname] = property(_make_component_getter(_SingleIndexedComponentGenerator, component))</pre></div>
<div class="skip"><span class="num"><pre>230</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>231</pre></span><pre>	#} END iterator shortcuts</pre></div>
<div class="skip"><span class="num"><pre>232</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>233</pre></span><pre>	#{ Utilities</pre></div>
<div class="skip"><span class="num"><pre>234</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>235</pre></span><pre>	def copyTweaksTo( self, other ):</pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>		&quot;&quot;&quot;Copy our tweaks onto another mesh</pre></div>
<div class="skip"><span class="num"><pre>237</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>		:note: we do not check topology for maximum flexibility&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>239</pre></span><pre>		opnts = other.pnts</pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>		pnts = self.pnts</pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>		for splug in pnts:</pre></div>
<div class="nocov"><span class="num"><pre>242</pre></span><pre>			opnts.elementByLogicalIndex( splug.logicalIndex() ).msetMObject( splug.asMObject() )</pre></div>
<div class="skip"><span class="num"><pre>243</pre></span><pre>		# END for each source plug in pnts</pre></div>
<div class="skip"><span class="num"><pre>244</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>	def isValidMesh( self ):</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>247</pre></span><pre>		:return: True if we are nonempty and valid - emptry meshes do not work with the mfnmesh</pre></div>
<div class="cov"><span class="num"><pre>248</pre></span><pre>			although it should ! Have to catch that case ourselves&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>249</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>250</pre></span><pre>			self.numVertices()</pre></div>
<div class="cov"><span class="num"><pre>251</pre></span><pre>			return True</pre></div>
<div class="cov"><span class="num"><pre>252</pre></span><pre>		except RuntimeError:</pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>			return False</pre></div>
<div class="skip"><span class="num"><pre>254</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>256</pre></span><pre>	def copyAssignmentsTo( self, other, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>257</pre></span><pre>		&quot;&quot;&quot;Copy set assignments including component assignments to other</pre></div>
<div class="skip"><span class="num"><pre>258</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>		:param kwargs: passed to set.addMember, additional kwargs are:</pre></div>
<div class="cov"><span class="num"><pre>260</pre></span><pre>			 * setFilter: default is fSetsRenderable&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>		setFilter = kwargs.pop( &quot;setFilter&quot;, base.Shape.fSetsRenderable )</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>		for sg, comp in self.componentAssignments( setFilter = setFilter ):</pre></div>
<div class="nocov"><span class="num"><pre>263</pre></span><pre>			sg.addMember( other, comp, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>264</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>265</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>266</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>	def resetTweaks( self, tweak_type = eComponentType.vertex, keep_tweak_result = False ):</pre></div>
<div class="cov"><span class="num"><pre>268</pre></span><pre>		&quot;&quot;&quot;Reset the tweaks on the given mesh shape</pre></div>
<div class="skip"><span class="num"><pre>269</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>		:param tweak_type: the component type(s) whose tweaks are to be removed,</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>			valid values are 'vertex' and 'uv' members of the eComponentType enumeration. </pre></div>
<div class="cov"><span class="num"><pre>272</pre></span><pre>			Pass in a scalar value or a list of tweak types</pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>		:param keep_tweak_result: if True, the effect of the tweak will be kept. If False,</pre></div>
<div class="cov"><span class="num"><pre>274</pre></span><pre>			it will be removed. What actually happens depends on the context</pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>276</pre></span><pre>			* [referenced] mesh *without* history:</pre></div>
<div class="cov"><span class="num"><pre>277</pre></span><pre>				copy outMesh to inMesh, resetTweaks</pre></div>
<div class="skip"><span class="num"><pre>278</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>				if referenced, plenty of reference edits are generated, ideally one operates</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>				on non-referenced geomtry</pre></div>
<div class="skip"><span class="num"><pre>281</pre></span><pre>			   </pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>			* [referenced] mesh *with* history:</pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>			 	put tweakNode into mesh history, copy tweaks onto tweak node</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>		:note: currently vertex and uv tweaks will be removed if keep is enabled, thus they must</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>			both be specified&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>286</pre></span><pre>		check_types = ( isinstance( tweak_type, ( list, tuple ) ) and tweak_type ) or [ tweak_type ]</pre></div>
<div class="cov"><span class="num"><pre>287</pre></span><pre>		type_map = {</pre></div>
<div class="cov"><span class="num"><pre>288</pre></span><pre>							self.eComponentType.vertex : ( &quot;pnts&quot;, api.MFnNumericData.k3Float, &quot;polyTweak&quot;, api.MFn.kPolyTweak, &quot;tweak&quot; ),</pre></div>
<div class="cov"><span class="num"><pre>289</pre></span><pre>							self.eComponentType.uv : ( &quot;uvpt&quot;, api.MFnNumericData.k2Float, &quot;polyTweakUV&quot;, api.MFn.kPolyTweakUV, &quot;uvTweak&quot; )</pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>					}</pre></div>
<div class="skip"><span class="num"><pre>291</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>		mia = api.MIntArray()</pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>		for reset_this_type in check_types:</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>295</pre></span><pre>				attrname, datatype, tweak_node_type, tweak_node_type_API, tweakattr = type_map[ reset_this_type ]</pre></div>
<div class="nocov"><span class="num"><pre>296</pre></span><pre>			except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>297</pre></span><pre>				raise ValueError( &quot;Tweak type %s is not supported&quot; % reset_this_type )</pre></div>
<div class="skip"><span class="num"><pre>298</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>299</pre></span><pre>			# KEEP MODE</pre></div>
<div class="skip"><span class="num"><pre>300</pre></span><pre>			#############</pre></div>
<div class="cov"><span class="num"><pre>301</pre></span><pre>			if keep_tweak_result:</pre></div>
<div class="cov"><span class="num"><pre>302</pre></span><pre>				input_plug = self.inMesh.minput()</pre></div>
<div class="skip"><span class="num"><pre>303</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>304</pre></span><pre>				# history check</pre></div>
<div class="cov"><span class="num"><pre>305</pre></span><pre>				if input_plug.isNull():</pre></div>
<div class="skip"><span class="num"><pre>306</pre></span><pre>					# assert as we had to make the handling much more complex to allow this to work right as we copy the whole mesh here</pre></div>
<div class="skip"><span class="num"><pre>307</pre></span><pre>					# containing all tweaks , not only one type</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>					if not ( self.eComponentType.vertex in check_types and self.eComponentType.uv in check_types ):</pre></div>
<div class="cov"><span class="num"><pre>309</pre></span><pre>						log.warn(&quot;Currently vertex AND uv tweaks will be removed if a mesh has no history and a reset is requested&quot;)</pre></div>
<div class="skip"><span class="num"><pre>310</pre></span><pre>					# END print warning</pre></div>
<div class="skip"><span class="num"><pre>311</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>312</pre></span><pre>					# take the output mesh, and stuff it into the input, then proceed</pre></div>
<div class="skip"><span class="num"><pre>313</pre></span><pre>					# with the reset. This implies that all tweaks have to be removed</pre></div>
<div class="cov"><span class="num"><pre>314</pre></span><pre>					out_mesh = self.outMesh.asMObject()</pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>					self.inMesh.msetMObject( out_mesh )</pre></div>
<div class="cov"><span class="num"><pre>316</pre></span><pre>					self.cachedInMesh.msetMObject( out_mesh )</pre></div>
<div class="skip"><span class="num"><pre>317</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>318</pre></span><pre>					# finally reset all tweeaks</pre></div>
<div class="cov"><span class="num"><pre>319</pre></span><pre>					return self.resetTweaks( check_types, keep_tweak_result = False )</pre></div>
<div class="cov"><span class="num"><pre>320</pre></span><pre>				else:</pre></div>
<div class="skip"><span class="num"><pre>321</pre></span><pre>					# create node of valid type</pre></div>
<div class="cov"><span class="num"><pre>322</pre></span><pre>					tweak_node = input_plug.mwrappedNode()</pre></div>
<div class="skip"><span class="num"><pre>323</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>324</pre></span><pre>					# create node if there is none as direct input</pre></div>
<div class="cov"><span class="num"><pre>325</pre></span><pre>					if not tweak_node.hasFn( tweak_node_type_API ):</pre></div>
<div class="cov"><span class="num"><pre>326</pre></span><pre>						tweak_node = base.createNode( &quot;polyTweak&quot;, tweak_node_type, forceNewLeaf = 1  )</pre></div>
<div class="skip"><span class="num"><pre>327</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>328</pre></span><pre>						# hook the node into the history</pre></div>
<div class="cov"><span class="num"><pre>329</pre></span><pre>						input_plug.mconnectTo(tweak_node.inputPolymesh)</pre></div>
<div class="cov"><span class="num"><pre>330</pre></span><pre>						tweak_node.output.mconnectTo(self.inMesh)</pre></div>
<div class="skip"><span class="num"><pre>331</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>332</pre></span><pre>						# setup uvset tweak location to tell uvset where to get tweaks from</pre></div>
<div class="cov"><span class="num"><pre>333</pre></span><pre>						if tweak_node_type_API == api.MFn.kPolyTweakUV:</pre></div>
<div class="nocov"><span class="num"><pre>334</pre></span><pre>							names = list()</pre></div>
<div class="nocov"><span class="num"><pre>335</pre></span><pre>							self.getUVSetNames( names )</pre></div>
<div class="nocov"><span class="num"><pre>336</pre></span><pre>							index = names.index( self.currentUVSetName( ) )</pre></div>
<div class="skip"><span class="num"><pre>337</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>338</pre></span><pre>							own_tweak_location_plug = self.uvSet.elementByLogicalIndex( index ).mchildByName('uvSetTweakLocation')</pre></div>
<div class="nocov"><span class="num"><pre>339</pre></span><pre>							tweak_node.uvTweak.elementByLogicalIndex( index ).mconnectTo(own_tweak_location_plug)</pre></div>
<div class="skip"><span class="num"><pre>340</pre></span><pre>						# END uv special setup</pre></div>
<div class="skip"><span class="num"><pre>341</pre></span><pre>					# END create tweak node</pre></div>
<div class="skip"><span class="num"><pre>342</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>					dtweak_plug = tweak_node.findPlug(tweakattr)</pre></div>
<div class="cov"><span class="num"><pre>344</pre></span><pre>					stweak_plug = self.findPlug(attrname)</pre></div>
<div class="skip"><span class="num"><pre>345</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>346</pre></span><pre>					# copy the tweak values - iterate manually as the plug tends to</pre></div>
<div class="skip"><span class="num"><pre>347</pre></span><pre>					# report incorrect values if history is present - its odd</pre></div>
<div class="cov"><span class="num"><pre>348</pre></span><pre>					stweak_plug.evaluateNumElements()</pre></div>
<div class="skip"><span class="num"><pre>349</pre></span><pre>					</pre></div>
<div class="cov"><span class="num"><pre>350</pre></span><pre>					mia.clear()</pre></div>
<div class="cov"><span class="num"><pre>351</pre></span><pre>					stweak_plug.getExistingArrayAttributeIndices(mia)</pre></div>
<div class="cov"><span class="num"><pre>352</pre></span><pre>					for i in mia:</pre></div>
<div class="cov"><span class="num"><pre>353</pre></span><pre>						try:</pre></div>
<div class="cov"><span class="num"><pre>354</pre></span><pre>							tplug = stweak_plug.elementByLogicalIndex(i)</pre></div>
<div class="nocov"><span class="num"><pre>355</pre></span><pre>						except RuntimeError:</pre></div>
<div class="nocov"><span class="num"><pre>356</pre></span><pre>							continue</pre></div>
<div class="cov"><span class="num"><pre>357</pre></span><pre>						else:</pre></div>
<div class="cov"><span class="num"><pre>358</pre></span><pre>							dtweak_plug.elementByLogicalIndex(i).msetMObject(tplug.asMObject())</pre></div>
<div class="skip"><span class="num"><pre>359</pre></span><pre>						# END exception handling</pre></div>
<div class="skip"><span class="num"><pre>360</pre></span><pre>					# END for each tweak plug</pre></div>
<div class="skip"><span class="num"><pre>361</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>362</pre></span><pre>					# proceed with reset of tweaks</pre></div>
<div class="cov"><span class="num"><pre>363</pre></span><pre>					pass</pre></div>
<div class="skip"><span class="num"><pre>364</pre></span><pre>				# END history handling</pre></div>
<div class="skip"><span class="num"><pre>365</pre></span><pre>			# END keep tweak result handling</pre></div>
<div class="skip"><span class="num"><pre>366</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>367</pre></span><pre>			arrayplug = self.findPlug(attrname)</pre></div>
<div class="cov"><span class="num"><pre>368</pre></span><pre>			dataobj = api.MFnNumericData().create( datatype )</pre></div>
<div class="skip"><span class="num"><pre>369</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>370</pre></span><pre>			# reset values, do it for all components at once using a data object</pre></div>
<div class="cov"><span class="num"><pre>371</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>372</pre></span><pre>				for p in arrayplug:</pre></div>
<div class="cov"><span class="num"><pre>373</pre></span><pre>					p.msetMObject( dataobj )</pre></div>
<div class="cov"><span class="num"><pre>374</pre></span><pre>			except RuntimeError:</pre></div>
<div class="skip"><span class="num"><pre>375</pre></span><pre>				# especially uvtweak array plugs return incorrect lengths, thus we may</pre></div>
<div class="skip"><span class="num"><pre>376</pre></span><pre>				# fail once we reach the end of the iteration.</pre></div>
<div class="skip"><span class="num"><pre>377</pre></span><pre>				# uvpt appears to display a lenght equalling the number of uvpoints in the mesh</pre></div>
<div class="skip"><span class="num"><pre>378</pre></span><pre>				# possibly only for the current uvset</pre></div>
<div class="cov"><span class="num"><pre>379</pre></span><pre>				pass</pre></div>
<div class="skip"><span class="num"><pre>380</pre></span><pre>		# END for tweak type to reset</pre></div>
<div class="skip"><span class="num"><pre>381</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>382</pre></span><pre>	def component(self, component_type):</pre></div>
<div class="cov"><span class="num"><pre>383</pre></span><pre>		&quot;&quot;&quot;:return: A component object able to hold the given component type</pre></div>
<div class="cov"><span class="num"><pre>384</pre></span><pre>		:param component_type: a member of the `eComponentType` enumeration&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>385</pre></span><pre>		if component_type not in self.eComponentType:</pre></div>
<div class="cov"><span class="num"><pre>386</pre></span><pre>			raise ValueError(&quot;Invalid component type&quot;)</pre></div>
<div class="cov"><span class="num"><pre>387</pre></span><pre>		return base.SingleIndexedComponent.create(component_type.value())</pre></div>
<div class="skip"><span class="num"><pre>388</pre></span><pre>		# END handle face-vertex components</pre></div>
<div class="skip"><span class="num"><pre>389</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>390</pre></span><pre>	#} END utilities</pre></div>
<div class="skip"><span class="num"><pre>391</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>392</pre></span><pre>	#{ Iterators </pre></div>
<div class="cov"><span class="num"><pre>393</pre></span><pre>	def iterComponents(self, component_type, component=api.MObject()):</pre></div>
<div class="cov"><span class="num"><pre>394</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>395</pre></span><pre>		:return: MItIterator matching your component_type to iteartor over items</pre></div>
<div class="cov"><span class="num"><pre>396</pre></span><pre>			on this mesh</pre></div>
<div class="cov"><span class="num"><pre>397</pre></span><pre>		:param component_type: </pre></div>
<div class="cov"><span class="num"><pre>398</pre></span><pre>		 * vertex -&gt; MItMeshVertex</pre></div>
<div class="cov"><span class="num"><pre>399</pre></span><pre>		 * edge -&gt; MItMeshEdge</pre></div>
<div class="cov"><span class="num"><pre>400</pre></span><pre>		 * face -&gt; MItMeshPolygon</pre></div>
<div class="cov"><span class="num"><pre>401</pre></span><pre>		 * uv -&gt; MItMeshFaceVertex</pre></div>
<div class="cov"><span class="num"><pre>402</pre></span><pre>		:param component: if not kNullObject, the iterator returned will be constrained</pre></div>
<div class="cov"><span class="num"><pre>403</pre></span><pre>			to the given indices as described by the Component. Use `component` to retrieve </pre></div>
<div class="cov"><span class="num"><pre>404</pre></span><pre>			a matching component type's instance&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>405</pre></span><pre>		if component_type not in self.eComponentType:</pre></div>
<div class="cov"><span class="num"><pre>406</pre></span><pre>			raise ValueError(&quot;Invalid component type&quot;)</pre></div>
<div class="skip"><span class="num"><pre>407</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>408</pre></span><pre>		ec = self.eComponentType</pre></div>
<div class="cov"><span class="num"><pre>409</pre></span><pre>		it_type = { 	ec.vertex : api.MItMeshVertex,</pre></div>
<div class="cov"><span class="num"><pre>410</pre></span><pre>						ec.edge   : api.MItMeshEdge, </pre></div>
<div class="cov"><span class="num"><pre>411</pre></span><pre>						ec.face   : api.MItMeshPolygon, </pre></div>
<div class="cov"><span class="num"><pre>412</pre></span><pre>						ec.uv     : api.MItMeshFaceVertex}[component_type] </pre></div>
<div class="skip"><span class="num"><pre>413</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>414</pre></span><pre>		return it_type(self.dagPath(), component)</pre></div>
<div class="skip"><span class="num"><pre>415</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>416</pre></span><pre>	#} END iterators </pre></div>
<div class="skip"><span class="num"><pre>417</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>418</pre></span><pre>	#( iDuplicatable</pre></div>
<div class="cov"><span class="num"><pre>419</pre></span><pre>	def copyFrom( self, other, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>420</pre></span><pre>		&quot;&quot;&quot;Copy tweaks and sets from other onto self</pre></div>
<div class="skip"><span class="num"><pre>421</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>422</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>423</pre></span><pre>			 * setFilter: if given, default is fSets, you may specify the types of sets to copy</pre></div>
<div class="cov"><span class="num"><pre>424</pre></span><pre>						if None, no set conenctions will be copied &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>425</pre></span><pre>		other.copyTweaksTo( self )</pre></div>
<div class="skip"><span class="num"><pre>426</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>427</pre></span><pre>		setfilter = kwargs.pop( &quot;setFilter&quot;, Mesh.fSets )		# copy all sets by default</pre></div>
<div class="cov"><span class="num"><pre>428</pre></span><pre>		if setfilter is not None:</pre></div>
<div class="cov"><span class="num"><pre>429</pre></span><pre>			other.copyAssignmentsTo( self, setFilter = setfilter )</pre></div>
<div class="skip"><span class="num"><pre>430</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>431</pre></span><pre>	#) END iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre>432</pre></span><pre></pre></div>
</div>
</body>
</html>
