<html>
<head>
<title>mrv.util</title>
</head>
<body>
mrv.util
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 523 lines<br/>
Missed: 117 lines<br/>
Skipped 260 lines<br/>
Percent: 81 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;All kinds of utility methods and classes that are used in more than one modules &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>import networkx as nx</pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>from collections import deque as Deque</pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>import weakref</pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>import inspect</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>import itertools</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>from interface import iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre>  9</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>log = logging.getLogger(&quot;mrv.maya.ui.util&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 12</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>__all__ = (&quot;decodeString&quot;, &quot;decodeStringOrList&quot;, &quot;capitalize&quot;, &quot;uncapitalize&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>	&quot;pythonIndex&quot;, &quot;copyClsMembers&quot;, &quot;packageClasses&quot;, &quot;iterNetworkxGraph&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>           &quot;Call&quot;, &quot;CallAdv&quot;, &quot;WeakInstFunction&quot;, &quot;Event&quot;, &quot;EventSender&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>           &quot;InterfaceMaster&quot;, &quot;Singleton&quot;, &quot;CallOnDeletion&quot;, </pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>           &quot;DAGTree&quot;, &quot;PipeSeparatedFile&quot;, &quot;MetaCopyClsMembers&quot;, &quot;And&quot;, &quot;Or&quot;) </pre></div>
<div class="skip"><span class="num"><pre> 19</pre></span><pre>           </pre></div>
<div class="skip"><span class="num"><pre> 20</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 21</pre></span><pre>def decodeString( valuestr ):</pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>	&quot;&quot;&quot; :return: int,float or str from string valuestr - a string that encodes a</pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>		numeric value or a string</pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>	:raise TypeError: if the type could not be determined&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 26</pre></span><pre>	# put this check here intentionally - want to allow</pre></div>
<div class="nocov"><span class="num"><pre> 27</pre></span><pre>	if not isinstance( valuestr, basestring ):</pre></div>
<div class="nocov"><span class="num"><pre> 28</pre></span><pre>		raise TypeError( &quot;Invalid value type: only int, long, float and str are allowed&quot;, valuestr )</pre></div>
<div class="skip"><span class="num"><pre> 29</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre> 30</pre></span><pre>	types = ( long, float )</pre></div>
<div class="nocov"><span class="num"><pre> 31</pre></span><pre>	for numtype in types:</pre></div>
<div class="nocov"><span class="num"><pre> 32</pre></span><pre>		try:</pre></div>
<div class="nocov"><span class="num"><pre> 33</pre></span><pre>			val = numtype( valuestr )</pre></div>
<div class="skip"><span class="num"><pre> 34</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre>			# truncated value ?</pre></div>
<div class="nocov"><span class="num"><pre> 36</pre></span><pre>			if val != float( valuestr ):</pre></div>
<div class="nocov"><span class="num"><pre> 37</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre> 38</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre> 39</pre></span><pre>			return val</pre></div>
<div class="nocov"><span class="num"><pre> 40</pre></span><pre>		except ( ValueError,TypeError ):</pre></div>
<div class="nocov"><span class="num"><pre> 41</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre> 42</pre></span><pre>	# END for each numeric type</pre></div>
<div class="skip"><span class="num"><pre> 43</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 44</pre></span><pre>	# its just a string and not a numeric type</pre></div>
<div class="nocov"><span class="num"><pre> 45</pre></span><pre>	return valuestr</pre></div>
<div class="skip"><span class="num"><pre> 46</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>def decodeStringOrList( valuestrOrList ):</pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 49</pre></span><pre>	:return: as `decodeString`, but returns a list of appropriate values if</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>		the input argument is a list or tuple type&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 51</pre></span><pre>	if isinstance( valuestrOrList , ( list, tuple ) ):</pre></div>
<div class="nocov"><span class="num"><pre> 52</pre></span><pre>		return [ decodeString( valuestr ) for valuestr in valuestrOrList ]</pre></div>
<div class="skip"><span class="num"><pre> 53</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre> 54</pre></span><pre>	return decodeString( valuestrOrList )</pre></div>
<div class="skip"><span class="num"><pre> 55</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>def capitalize(s):</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>	&quot;&quot;&quot;:return: s with first letter capitalized&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>	return s[0].upper() + s[1:]</pre></div>
<div class="skip"><span class="num"><pre> 59</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>def uncapitalize(s, preserveAcronymns=False):</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>	&quot;&quot;&quot;:return: ``s`` with first letter lower case</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>	:param preserveAcronymns: enabled ensures that 'NTSC' does not become 'nTSC'</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>	:note: from pymel</pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>	try:</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>		if preserveAcronymns and s[0:2].isupper():</pre></div>
<div class="nocov"><span class="num"><pre> 67</pre></span><pre>			return s</pre></div>
<div class="nocov"><span class="num"><pre> 68</pre></span><pre>	except IndexError: pass</pre></div>
<div class="skip"><span class="num"><pre> 69</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>	return s[0].lower() + s[1:]</pre></div>
<div class="skip"><span class="num"><pre> 71</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>def pythonIndex( index, length ):</pre></div>
<div class="cov"><span class="num"><pre> 73</pre></span><pre>	&quot;&quot;&quot;Compute the actual index based on the given index and array length, thus</pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>	-1 will result in the last array element's index&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 75</pre></span><pre>	if index &gt; -1: return index</pre></div>
<div class="nocov"><span class="num"><pre> 76</pre></span><pre>	return length + index			# yes, length be better 1 or more ;)</pre></div>
<div class="skip"><span class="num"><pre> 77</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 78</pre></span><pre>def copyClsMembers( sourcecls, destcls, overwritePrefix = None, forbiddenMembers = list(), copyNamespaceGlobally=None):</pre></div>
<div class="cov"><span class="num"><pre> 79</pre></span><pre>	&quot;&quot;&quot;Copy the members or sourcecls to destcls while ignoring member names in forbiddenMembers</pre></div>
<div class="cov"><span class="num"><pre> 80</pre></span><pre>	It will only copy mebers of this class, not its base classes</pre></div>
<div class="skip"><span class="num"><pre> 81</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 82</pre></span><pre>	:param sourcecls: class whose members should be copied</pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>	:param destcls: class to receive members from sourcecls</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>	:param overwritePrefix: if None, existing members on destcls will not be overwritten, if string,</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>		the original method will be stored in a name like prefix+originalname ( allowing you to access the</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>		original method lateron )</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	:param copyNamespaceGlobally: if not None, the variable contains the name of the namespace as string </pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>		whose methods should also be copied into the global namespace, possibly overwriting existing ones.</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>		For instance, 'nsmethod' will be available as obj.nsmethod and as obj.method if the namespace value was 'ns.</pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>		The forbiddenMembers list is applied to the original as well as the global name</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>	:note: this can be useful if you cannot inherit from a class directly because you would get</pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>		method resolution order problems</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>	:note: see also the `MetaCopyClsMembers` meta class&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>	for orig_name,member in sourcecls.__dict__.iteritems():</pre></div>
<div class="cov"><span class="num"><pre> 95</pre></span><pre>		names = [orig_name]</pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>		if copyNamespaceGlobally is not None and orig_name.startswith(copyNamespaceGlobally):</pre></div>
<div class="nocov"><span class="num"><pre> 97</pre></span><pre>			names.append(orig_name[len(copyNamespaceGlobally):])	# truncate namespace</pre></div>
<div class="skip"><span class="num"><pre> 98</pre></span><pre>		# END handle namespace removal</pre></div>
<div class="skip"><span class="num"><pre> 99</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>		for name in names:</pre></div>
<div class="cov"><span class="num"><pre>101</pre></span><pre>			if name in forbiddenMembers:</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>				continue</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>			try:</pre></div>
<div class="skip"><span class="num"><pre>104</pre></span><pre>				# store original - overwritten members must still be able to access it</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>				if hasattr( destcls, name ):</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>					if not overwritePrefix:</pre></div>
<div class="nocov"><span class="num"><pre>107</pre></span><pre>						continue</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>					morig = getattr( destcls, name )</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>					type.__setattr__( destcls, overwritePrefix+name, morig )</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>				type.__setattr__( destcls, name, member )</pre></div>
<div class="nocov"><span class="num"><pre>111</pre></span><pre>			except TypeError:</pre></div>
<div class="nocov"><span class="num"><pre>112</pre></span><pre>				pass</pre></div>
<div class="skip"><span class="num"><pre>113</pre></span><pre>		# END for each name</pre></div>
<div class="skip"><span class="num"><pre>114</pre></span><pre>	# END for each memebr in sourcecls</pre></div>
<div class="skip"><span class="num"><pre>115</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>def packageClasses( importBase, packageFile, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>	:return: all classes of modules of the given package file that additionally</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>		match given predicate</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>	:param importBase: longest import base path whose submodules contain the classes to import</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>	:param packageFile: the filepath to the package, as given in your __file__ variables</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>	:param predicate: receives the class and returns True if it is a class you are looking for&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>123</pre></span><pre>	from glob import glob</pre></div>
<div class="nocov"><span class="num"><pre>124</pre></span><pre>	import os</pre></div>
<div class="skip"><span class="num"><pre>125</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>126</pre></span><pre>	packageDir = os.path.dirname( packageFile )</pre></div>
<div class="skip"><span class="num"><pre>127</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>128</pre></span><pre>	# get all submodules</pre></div>
<div class="nocov"><span class="num"><pre>129</pre></span><pre>	basenameNoExt = lambda n: os.path.splitext( os.path.split( n )[1] )[0]</pre></div>
<div class="nocov"><span class="num"><pre>130</pre></span><pre>	pymodules = itertools.chain( glob( os.path.join( packageDir, &quot;*.py&quot; ) ), glob( os.path.join( packageDir, &quot;*.pyc&quot; ) ) ) </pre></div>
<div class="nocov"><span class="num"><pre>131</pre></span><pre>	pymodules = [ basenameNoExt( m ) for m in pymodules</pre></div>
<div class="nocov"><span class="num"><pre>132</pre></span><pre>							if not os.path.basename( m ).startswith( '_' ) ]</pre></div>
<div class="skip"><span class="num"><pre>133</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>134</pre></span><pre>	outclasses = []</pre></div>
<div class="nocov"><span class="num"><pre>135</pre></span><pre>	classAndCustom = lambda x: inspect.isclass( x ) and predicate( x )</pre></div>
<div class="nocov"><span class="num"><pre>136</pre></span><pre>	for modulename in pymodules:</pre></div>
<div class="nocov"><span class="num"><pre>137</pre></span><pre>		modobj = __import__( &quot;%s.%s&quot; % ( importBase, modulename ), globals(), locals(), [''] )</pre></div>
<div class="nocov"><span class="num"><pre>138</pre></span><pre>		for name,obj in inspect.getmembers( modobj, predicate = classAndCustom ):</pre></div>
<div class="nocov"><span class="num"><pre>139</pre></span><pre>			outclasses.append( obj )</pre></div>
<div class="skip"><span class="num"><pre>140</pre></span><pre>	# import the modules</pre></div>
<div class="nocov"><span class="num"><pre>141</pre></span><pre>	return outclasses</pre></div>
<div class="skip"><span class="num"><pre>142</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>def iterNetworkxGraph( graph, startItem, direction = 0, prune = lambda i,g: False,</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>					   stop = lambda i,g: False, depth = -1, branch_first=True,</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>					   visit_once = True, ignore_startitem=1 ):</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>	&quot;&quot;&quot;:return: iterator yielding pairs of depth, item </pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>	:param direction: specifies search direction, either :</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>		0 = items being successors of startItem</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>		1 = items being predecessors of startItem</pre></div>
<div class="cov"><span class="num"><pre>150</pre></span><pre>	:param prune: return True if item d,i in graph g should be pruned from result.</pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>		d is the depth of item i</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>	:param stop: return True if item d,i in graph g, d is the depth of item i</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>		stop the search in that direction. It will not be returned.</pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>	:param depth: define at which level the iteration should not go deeper</pre></div>
<div class="cov"><span class="num"><pre>155</pre></span><pre>		if -1, there is no limit</pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>		if 0, you would only get startitem.</pre></div>
<div class="cov"><span class="num"><pre>157</pre></span><pre>		i.e. if 1, you would only get the startitem and the first level of predessessors/successors</pre></div>
<div class="cov"><span class="num"><pre>158</pre></span><pre>	:param branch_first: if True, items will be returned branch first, otherwise depth first</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>	:param visit_once: if True, items will only be returned once, although they might be encountered</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>		several times</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>	:param ignore_startitem: if True, the startItem will be ignored and automatically pruned from</pre></div>
<div class="cov"><span class="num"><pre>162</pre></span><pre>		the result</pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>	:note: this is an adjusted version of `dge.iterShells`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>	visited = set()</pre></div>
<div class="cov"><span class="num"><pre>165</pre></span><pre>	stack = Deque()</pre></div>
<div class="cov"><span class="num"><pre>166</pre></span><pre>	stack.append( ( 0 , startItem ) )		# startitem is always depth level 0</pre></div>
<div class="skip"><span class="num"><pre>167</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>168</pre></span><pre>	def addToStack( stack, lst, branch_first, dpth ):</pre></div>
<div class="cov"><span class="num"><pre>169</pre></span><pre>		if branch_first:</pre></div>
<div class="cov"><span class="num"><pre>170</pre></span><pre>			reviter = ( ( dpth , lst[i] ) for i in range( len( lst )-1,-1,-1) )</pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>			stack.extendleft( reviter )</pre></div>
<div class="nocov"><span class="num"><pre>172</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>173</pre></span><pre>			stack.extend( ( dpth,item ) for item in lst )</pre></div>
<div class="skip"><span class="num"><pre>174</pre></span><pre>	# END addToStack local method</pre></div>
<div class="skip"><span class="num"><pre>175</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>176</pre></span><pre>	# adjust function to define direction</pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>	directionfunc = graph.successors</pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>	if direction == 1:</pre></div>
<div class="cov"><span class="num"><pre>179</pre></span><pre>		directionfunc = graph.predecessors</pre></div>
<div class="skip"><span class="num"><pre>180</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>181</pre></span><pre>	while stack:</pre></div>
<div class="cov"><span class="num"><pre>182</pre></span><pre>		d, item = stack.pop()			# depth of item, item</pre></div>
<div class="skip"><span class="num"><pre>183</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>		if item in visited:</pre></div>
<div class="nocov"><span class="num"><pre>185</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>186</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>187</pre></span><pre>		if visit_once:</pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>			visited.add( item )</pre></div>
<div class="skip"><span class="num"><pre>189</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>190</pre></span><pre>		oitem = (d, item)</pre></div>
<div class="cov"><span class="num"><pre>191</pre></span><pre>		if stop( oitem, graph ):</pre></div>
<div class="nocov"><span class="num"><pre>192</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>194</pre></span><pre>		skipStartItem = ignore_startitem and ( item == startItem )</pre></div>
<div class="cov"><span class="num"><pre>195</pre></span><pre>		if not skipStartItem and not prune( oitem, graph ):</pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>			yield oitem</pre></div>
<div class="skip"><span class="num"><pre>197</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>198</pre></span><pre>		# only continue to next level if this is appropriate !</pre></div>
<div class="cov"><span class="num"><pre>199</pre></span><pre>		nd = d + 1</pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>		if depth &gt; -1 and nd &gt; depth:</pre></div>
<div class="nocov"><span class="num"><pre>201</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>202</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>		addToStack( stack, directionfunc( item ), branch_first, nd )</pre></div>
<div class="skip"><span class="num"><pre>204</pre></span><pre>	# END for each item on work stack</pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>206</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>207</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>class Call( object ):</pre></div>
<div class="cov"><span class="num"><pre>209</pre></span><pre>	&quot;&quot;&quot;Call object encapsulating any code, thus providing a simple facade for it</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>	:note: derive from it if a more complex call is required&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>	__slots__ = ( &quot;func&quot;, &quot;args&quot;, &quot;kwargs&quot; )</pre></div>
<div class="skip"><span class="num"><pre>212</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>	def __init__( self, func, *args,**kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>		&quot;&quot;&quot;Initialize object with function to call once this object is called&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>215</pre></span><pre>		self.func = func</pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>		self.args = args</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>		self.kwargs = kwargs</pre></div>
<div class="skip"><span class="num"><pre>218</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>	def __call__( self, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>		&quot;&quot;&quot;Execute the stored function on call</pre></div>
<div class="cov"><span class="num"><pre>221</pre></span><pre>		:note: having ``args`` and ``kwargs`` set makes it more versatile&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>222</pre></span><pre>		return self.func( *self.args, **self.kwargs )</pre></div>
<div class="skip"><span class="num"><pre>223</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>224</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>225</pre></span><pre>class CallAdv( Call ):</pre></div>
<div class="cov"><span class="num"><pre>226</pre></span><pre>	&quot;&quot;&quot;Advanced call class providing additional options:</pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>228</pre></span><pre>	merge_args: </pre></div>
<div class="cov"><span class="num"><pre>229</pre></span><pre>		if True, default True, incoming arguments will be prepended before the static ones</pre></div>
<div class="cov"><span class="num"><pre>230</pre></span><pre>	merge_kwargs: </pre></div>
<div class="cov"><span class="num"><pre>231</pre></span><pre>		if True, default True, incoming kwargs will be merged into the static ones &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>232</pre></span><pre>	__slots__ = ( &quot;merge_args&quot;, &quot;merge_kwargs&quot; )</pre></div>
<div class="skip"><span class="num"><pre>233</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>234</pre></span><pre>	def __init__( self, func, *args, **kwargs ):</pre></div>
<div class="nocov"><span class="num"><pre>235</pre></span><pre>		self.merge_args = kwargs.pop( &quot;merge_args&quot;, True )</pre></div>
<div class="nocov"><span class="num"><pre>236</pre></span><pre>		self.merge_kwargs = kwargs.pop( &quot;merge_kwargs&quot;, True )</pre></div>
<div class="skip"><span class="num"><pre>237</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>238</pre></span><pre>		super( CallAdv, self ).__init__( func, *args, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>239</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>	def __call__( self, *inargs, **inkwargs ):</pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>		&quot;&quot;&quot;Call with merge support&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>242</pre></span><pre>		args = self.args</pre></div>
<div class="nocov"><span class="num"><pre>243</pre></span><pre>		if self.merge_args:</pre></div>
<div class="nocov"><span class="num"><pre>244</pre></span><pre>			args = list( inargs )</pre></div>
<div class="nocov"><span class="num"><pre>245</pre></span><pre>			args.extend( self.args )</pre></div>
<div class="skip"><span class="num"><pre>246</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>247</pre></span><pre>		if self.merge_kwargs:</pre></div>
<div class="nocov"><span class="num"><pre>248</pre></span><pre>			self.kwargs.update( inkwargs )</pre></div>
<div class="skip"><span class="num"><pre>249</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>250</pre></span><pre>		return self.func( *args, **self.kwargs )</pre></div>
<div class="skip"><span class="num"><pre>251</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>252</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>class WeakInstFunction( object ):</pre></div>
<div class="cov"><span class="num"><pre>254</pre></span><pre>	&quot;&quot;&quot;Create a proper weak instance to an instance function by weakly binding</pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>	the instance, not the bound function object.</pre></div>
<div class="cov"><span class="num"><pre>256</pre></span><pre>	When called, the weakreferenced instance pointer will be retrieved, if possible,</pre></div>
<div class="cov"><span class="num"><pre>257</pre></span><pre>	to finally make the call. If it could not be retrieved, the call</pre></div>
<div class="cov"><span class="num"><pre>258</pre></span><pre>	will do nothing.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>	__slots__ = ( &quot;_weakinst&quot;, &quot;_clsfunc&quot; )</pre></div>
<div class="skip"><span class="num"><pre>260</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>	def __init__( self, instancefunction ):</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>		self._weakinst = weakref.ref( instancefunction.im_self )</pre></div>
<div class="cov"><span class="num"><pre>263</pre></span><pre>		self._clsfunc = instancefunction.im_func</pre></div>
<div class="skip"><span class="num"><pre>264</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>265</pre></span><pre>	def __eq__(self, other):</pre></div>
<div class="cov"><span class="num"><pre>266</pre></span><pre>		return hash(self) == hash(other)</pre></div>
<div class="skip"><span class="num"><pre>267</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>268</pre></span><pre>	def __hash__(self):</pre></div>
<div class="cov"><span class="num"><pre>269</pre></span><pre>		return hash((self._clsfunc,  self._weakinst()))</pre></div>
<div class="skip"><span class="num"><pre>270</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>	def __call__( self, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>272</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>		:raise LookupError: if the instance referred to by the instance method</pre></div>
<div class="cov"><span class="num"><pre>274</pre></span><pre>			does not exist anymore&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>275</pre></span><pre>		inst = self._weakinst()</pre></div>
<div class="cov"><span class="num"><pre>276</pre></span><pre>		if inst is None:	# went out of scope</pre></div>
<div class="nocov"><span class="num"><pre>277</pre></span><pre>			raise LookupError( &quot;Instance for call to %s has been deleted as it is weakly bound&quot; % self._clsfunc.__name__ )</pre></div>
<div class="skip"><span class="num"><pre>278</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>		return self._clsfunc( inst, *args, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>280</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>281</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>class Event( object ):</pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>	&quot;&quot;&quot;Descriptor allowing to easily setup callbacks for classes derived from</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>	EventSender&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>	_inst_event_attr = '__events__'	# dict with event -&gt; set() relation</pre></div>
<div class="skip"><span class="num"><pre>286</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>287</pre></span><pre>	#{ Configuration</pre></div>
<div class="skip"><span class="num"><pre>288</pre></span><pre>	# if true, functions will be weak-referenced - its useful if you use instance</pre></div>
<div class="skip"><span class="num"><pre>289</pre></span><pre>	# variables as callbacks</pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>	use_weakref = True</pre></div>
<div class="skip"><span class="num"><pre>291</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>292</pre></span><pre>	# if True, callback handlers throwing an exception will immediately be</pre></div>
<div class="skip"><span class="num"><pre>293</pre></span><pre>	# removed from the callback list</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>	remove_on_error = False</pre></div>
<div class="skip"><span class="num"><pre>295</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>296</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>297</pre></span><pre>	# If not None, this value overrides the corresponding value on the EventSender class</pre></div>
<div class="cov"><span class="num"><pre>298</pre></span><pre>	sender_as_argument = None</pre></div>
<div class="skip"><span class="num"><pre>299</pre></span><pre>	#} END configuration</pre></div>
<div class="skip"><span class="num"><pre>300</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>301</pre></span><pre>	# internally used to keep track of the current sender. Is None if no event</pre></div>
<div class="skip"><span class="num"><pre>302</pre></span><pre>	# is being fired</pre></div>
<div class="cov"><span class="num"><pre>303</pre></span><pre>	_curSender = None</pre></div>
<div class="skip"><span class="num"><pre>304</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>305</pre></span><pre>	def __init__( self, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>306</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>307</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>			 * weak: if True, default class configuration use_weakref, weak</pre></div>
<div class="cov"><span class="num"><pre>309</pre></span><pre>				references will be created for event handlers, if False it will be strong</pre></div>
<div class="cov"><span class="num"><pre>310</pre></span><pre>				references</pre></div>
<div class="cov"><span class="num"><pre>311</pre></span><pre>			 * remove_failed: if True, defailt False, failed callback handlers</pre></div>
<div class="cov"><span class="num"><pre>312</pre></span><pre>			 	will be removed silently&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>313</pre></span><pre>		self.use_weakref = kwargs.get( &quot;weak&quot;, self.__class__.use_weakref )</pre></div>
<div class="cov"><span class="num"><pre>314</pre></span><pre>		self.remove_on_error = kwargs.get( &quot;remove_failed&quot;, self.__class__.remove_on_error )</pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>		self.sender_as_argument = kwargs.get(&quot;sender_as_argument&quot;, self.__class__.sender_as_argument)</pre></div>
<div class="cov"><span class="num"><pre>316</pre></span><pre>		self._last_inst_ref = None</pre></div>
<div class="skip"><span class="num"><pre>317</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>318</pre></span><pre>	def _func_to_key( self, eventfunc ):</pre></div>
<div class="cov"><span class="num"><pre>319</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>320</pre></span><pre>		:return: an eventfunction suitable to be used as key in our instance</pre></div>
<div class="cov"><span class="num"><pre>321</pre></span><pre>			event set&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>322</pre></span><pre>		if self.use_weakref:</pre></div>
<div class="cov"><span class="num"><pre>323</pre></span><pre>			if inspect.ismethod( eventfunc ):</pre></div>
<div class="cov"><span class="num"><pre>324</pre></span><pre>				eventfunc = WeakInstFunction( eventfunc )</pre></div>
<div class="nocov"><span class="num"><pre>325</pre></span><pre>			else:</pre></div>
<div class="nocov"><span class="num"><pre>326</pre></span><pre>				eventfunc = weakref.ref( eventfunc )</pre></div>
<div class="skip"><span class="num"><pre>327</pre></span><pre>			# END instance function special handling</pre></div>
<div class="skip"><span class="num"><pre>328</pre></span><pre>		# END if use weak ref</pre></div>
<div class="cov"><span class="num"><pre>329</pre></span><pre>		return eventfunc</pre></div>
<div class="skip"><span class="num"><pre>330</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>331</pre></span><pre>	def _key_to_func( self, eventkey ):</pre></div>
<div class="cov"><span class="num"><pre>332</pre></span><pre>		&quot;&quot;&quot;:return: event function from the given eventkey as stored in our events set.</pre></div>
<div class="cov"><span class="num"><pre>333</pre></span><pre>		:note: this is required as the event might be weakreffed or not&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>334</pre></span><pre>		if self.use_weakref:</pre></div>
<div class="cov"><span class="num"><pre>335</pre></span><pre>			if isinstance( eventkey, WeakInstFunction ):</pre></div>
<div class="cov"><span class="num"><pre>336</pre></span><pre>				return eventkey</pre></div>
<div class="nocov"><span class="num"><pre>337</pre></span><pre>			else:</pre></div>
<div class="nocov"><span class="num"><pre>338</pre></span><pre>				return eventkey()</pre></div>
<div class="skip"><span class="num"><pre>339</pre></span><pre>			# END instance method handling</pre></div>
<div class="skip"><span class="num"><pre>340</pre></span><pre>		# END weak ref handling</pre></div>
<div class="cov"><span class="num"><pre>341</pre></span><pre>		return eventkey</pre></div>
<div class="skip"><span class="num"><pre>342</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>	def _get_last_instance(self):</pre></div>
<div class="cov"><span class="num"><pre>344</pre></span><pre>		&quot;&quot;&quot;:return: The last instance that retrieved us&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>345</pre></span><pre>		if self._last_inst_ref is None or self._last_inst_ref() is None:</pre></div>
<div class="nocov"><span class="num"><pre>346</pre></span><pre>			raise TypeError(&quot;Cannot send events through class descriptor&quot;)</pre></div>
<div class="cov"><span class="num"><pre>347</pre></span><pre>		return self._last_inst_ref()</pre></div>
<div class="skip"><span class="num"><pre>348</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>349</pre></span><pre>	def __set__( self, inst, eventfunc ):</pre></div>
<div class="cov"><span class="num"><pre>350</pre></span><pre>		&quot;&quot;&quot;Set a new event to our object&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>351</pre></span><pre>		self._getFunctionSet(inst).add( self._func_to_key( eventfunc ) )</pre></div>
<div class="skip"><span class="num"><pre>352</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>353</pre></span><pre>	def __get__( self, inst, cls = None ):</pre></div>
<div class="cov"><span class="num"><pre>354</pre></span><pre>		&quot;&quot;&quot;Always return self, but keep the instance in case</pre></div>
<div class="cov"><span class="num"><pre>355</pre></span><pre>		we someone wants to send an event.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>356</pre></span><pre>		if inst is not None:</pre></div>
<div class="cov"><span class="num"><pre>357</pre></span><pre>			inst = weakref.ref(inst)</pre></div>
<div class="skip"><span class="num"><pre>358</pre></span><pre>		# END handle instance</pre></div>
<div class="cov"><span class="num"><pre>359</pre></span><pre>		self._last_inst_ref = inst  </pre></div>
<div class="cov"><span class="num"><pre>360</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre>361</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>362</pre></span><pre>	def _getFunctionSet(self, inst):</pre></div>
<div class="cov"><span class="num"><pre>363</pre></span><pre>		&quot;&quot;&quot;:return: function set of the given instance containing functions of our event&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>364</pre></span><pre>		if not hasattr( inst, self._inst_event_attr ):</pre></div>
<div class="cov"><span class="num"><pre>365</pre></span><pre>			setattr( inst, self._inst_event_attr, dict() )</pre></div>
<div class="skip"><span class="num"><pre>366</pre></span><pre>		# END initialize set</pre></div>
<div class="skip"><span class="num"><pre>367</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>368</pre></span><pre>		ed = getattr( inst, self._inst_event_attr )</pre></div>
<div class="cov"><span class="num"><pre>369</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>370</pre></span><pre>			return ed[self]</pre></div>
<div class="cov"><span class="num"><pre>371</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>372</pre></span><pre>			return ed.setdefault(self, set())</pre></div>
<div class="skip"><span class="num"><pre>373</pre></span><pre>		# END handle self -&gt; set relation</pre></div>
<div class="skip"><span class="num"><pre>374</pre></span><pre>	#{ Interface</pre></div>
<div class="skip"><span class="num"><pre>375</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>376</pre></span><pre>	def send( self, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>377</pre></span><pre>		&quot;&quot;&quot;Send our event using the given args</pre></div>
<div class="skip"><span class="num"><pre>378</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>379</pre></span><pre>		:note: if an event listener is weak referenced and goes out of scope</pre></div>
<div class="cov"><span class="num"><pre>380</pre></span><pre>		:note: will catch all event exceptions trown by the methods called</pre></div>
<div class="cov"><span class="num"><pre>381</pre></span><pre>		:return: False if at least one event call threw an exception, true otherwise&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>382</pre></span><pre>		inst = self._get_last_instance()</pre></div>
<div class="cov"><span class="num"><pre>383</pre></span><pre>		callbackset = self._getFunctionSet( inst )</pre></div>
<div class="cov"><span class="num"><pre>384</pre></span><pre>		success = True</pre></div>
<div class="cov"><span class="num"><pre>385</pre></span><pre>		failed_callbacks = list()</pre></div>
<div class="skip"><span class="num"><pre>386</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>387</pre></span><pre>		sas = inst.sender_as_argument</pre></div>
<div class="cov"><span class="num"><pre>388</pre></span><pre>		if self.sender_as_argument is not None:</pre></div>
<div class="cov"><span class="num"><pre>389</pre></span><pre>			sas = self.sender_as_argument</pre></div>
<div class="skip"><span class="num"><pre>390</pre></span><pre>		# END event override</pre></div>
<div class="skip"><span class="num"><pre>391</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>392</pre></span><pre>		# keep the sender</pre></div>
<div class="cov"><span class="num"><pre>393</pre></span><pre>		Event._curSender = inst</pre></div>
<div class="skip"><span class="num"><pre>394</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>395</pre></span><pre>		# copy the set, allowing callbacks to remove themselves during the callback.</pre></div>
<div class="skip"><span class="num"><pre>396</pre></span><pre>		# Otherwise we have a size change during the iteration</pre></div>
<div class="cov"><span class="num"><pre>397</pre></span><pre>		for function in callbackset.copy():</pre></div>
<div class="cov"><span class="num"><pre>398</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>399</pre></span><pre>				func = self._key_to_func( function )</pre></div>
<div class="cov"><span class="num"><pre>400</pre></span><pre>				if func is None:</pre></div>
<div class="nocov"><span class="num"><pre>401</pre></span><pre>					log.warn(&quot;Listener for callback of %s was not available anymore&quot; % self)</pre></div>
<div class="nocov"><span class="num"><pre>402</pre></span><pre>					failed_callbacks.append( function )</pre></div>
<div class="nocov"><span class="num"><pre>403</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>404</pre></span><pre>				# END handle no-func</pre></div>
<div class="skip"><span class="num"><pre>405</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>406</pre></span><pre>				try:</pre></div>
<div class="cov"><span class="num"><pre>407</pre></span><pre>					if sas:</pre></div>
<div class="cov"><span class="num"><pre>408</pre></span><pre>						func( inst, *args, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>409</pre></span><pre>					else:</pre></div>
<div class="cov"><span class="num"><pre>410</pre></span><pre>						func( *args, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>411</pre></span><pre>				except LookupError, e:</pre></div>
<div class="skip"><span class="num"><pre>412</pre></span><pre>					# thrown if self in instance methods went out of scope</pre></div>
<div class="nocov"><span class="num"><pre>413</pre></span><pre>					if inst.reraise_on_error:</pre></div>
<div class="nocov"><span class="num"><pre>414</pre></span><pre>						raise </pre></div>
<div class="nocov"><span class="num"><pre>415</pre></span><pre>					log.error(str( e ))</pre></div>
<div class="nocov"><span class="num"><pre>416</pre></span><pre>					failed_callbacks.append( function )</pre></div>
<div class="skip"><span class="num"><pre>417</pre></span><pre>				# END sendder as argument</pre></div>
<div class="cov"><span class="num"><pre>418</pre></span><pre>			except Exception, e :</pre></div>
<div class="cov"><span class="num"><pre>419</pre></span><pre>				if self.remove_on_error:</pre></div>
<div class="cov"><span class="num"><pre>420</pre></span><pre>					failed_callbacks.append( function )</pre></div>
<div class="skip"><span class="num"><pre>421</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>422</pre></span><pre>				if inst.reraise_on_error:</pre></div>
<div class="nocov"><span class="num"><pre>423</pre></span><pre>					raise </pre></div>
<div class="cov"><span class="num"><pre>424</pre></span><pre>				log.error(str( e ))</pre></div>
<div class="cov"><span class="num"><pre>425</pre></span><pre>				success = False</pre></div>
<div class="skip"><span class="num"><pre>426</pre></span><pre>		# END for each registered event</pre></div>
<div class="skip"><span class="num"><pre>427</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>428</pre></span><pre>		# remove failed listeners</pre></div>
<div class="cov"><span class="num"><pre>429</pre></span><pre>		for function in failed_callbacks:</pre></div>
<div class="cov"><span class="num"><pre>430</pre></span><pre>			callbackset.remove(function)</pre></div>
<div class="skip"><span class="num"><pre>431</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>432</pre></span><pre>		Event._curSender = None</pre></div>
<div class="cov"><span class="num"><pre>433</pre></span><pre>		return success</pre></div>
<div class="skip"><span class="num"><pre>434</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>435</pre></span><pre>	# Alias, to make event sending even easier</pre></div>
<div class="cov"><span class="num"><pre>436</pre></span><pre>	__call__ = send</pre></div>
<div class="skip"><span class="num"><pre>437</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>438</pre></span><pre>	def remove( self, eventfunc ):</pre></div>
<div class="cov"><span class="num"><pre>439</pre></span><pre>		&quot;&quot;&quot;remove the given function from this event</pre></div>
<div class="cov"><span class="num"><pre>440</pre></span><pre>		:note: will not raise if eventfunc does not exist&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>441</pre></span><pre>		inst = self._get_last_instance()</pre></div>
<div class="cov"><span class="num"><pre>442</pre></span><pre>		eventfunc = self._func_to_key( eventfunc )</pre></div>
<div class="cov"><span class="num"><pre>443</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>444</pre></span><pre>			self._getFunctionSet( inst ).remove( eventfunc )</pre></div>
<div class="nocov"><span class="num"><pre>445</pre></span><pre>		except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>446</pre></span><pre>			pass</pre></div>
<div class="skip"><span class="num"><pre>447</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>448</pre></span><pre>	def duplicate( self ):</pre></div>
<div class="nocov"><span class="num"><pre>449</pre></span><pre>		inst = self.__class__( &quot;&quot; )</pre></div>
<div class="nocov"><span class="num"><pre>450</pre></span><pre>		inst._name = self._name	</pre></div>
<div class="nocov"><span class="num"><pre>451</pre></span><pre>		inst.use_weakref = self.use_weakref</pre></div>
<div class="nocov"><span class="num"><pre>452</pre></span><pre>		inst.remove_on_error = self.remove_on_error</pre></div>
<div class="nocov"><span class="num"><pre>453</pre></span><pre>		inst.sender_as_argument = self.sender_as_argument</pre></div>
<div class="nocov"><span class="num"><pre>454</pre></span><pre>		return inst</pre></div>
<div class="skip"><span class="num"><pre>455</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>456</pre></span><pre>	#} END interface </pre></div>
<div class="skip"><span class="num"><pre>457</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>458</pre></span><pre># END event class</pre></div>
<div class="skip"><span class="num"><pre>459</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>460</pre></span><pre>class EventSender( object ):</pre></div>
<div class="cov"><span class="num"><pre>461</pre></span><pre>	&quot;&quot;&quot;Base class for all classes that want to provide a common callback interface</pre></div>
<div class="cov"><span class="num"><pre>462</pre></span><pre>	to supply event information to clients.</pre></div>
<div class="skip"><span class="num"><pre>463</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>464</pre></span><pre>	**Usage**:</pre></div>
<div class="cov"><span class="num"><pre>465</pre></span><pre>	Derive from this class and define your callbacks like:</pre></div>
<div class="skip"><span class="num"><pre>466</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>467</pre></span><pre>		&gt;&gt;&gt; event = Event( )</pre></div>
<div class="cov"><span class="num"><pre>468</pre></span><pre>		&gt;&gt;&gt; # Call it using</pre></div>
<div class="cov"><span class="num"><pre>469</pre></span><pre>		&gt;&gt;&gt; self.event.send( [*args][,**kwargs]] )</pre></div>
<div class="skip"><span class="num"><pre>470</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>471</pre></span><pre>		&gt;&gt;&gt; # Users register using</pre></div>
<div class="cov"><span class="num"><pre>472</pre></span><pre>		&gt;&gt;&gt; yourinstance.event = callable</pre></div>
<div class="skip"><span class="num"><pre>473</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>474</pre></span><pre>		&gt;&gt;&gt; # and deregister using</pre></div>
<div class="cov"><span class="num"><pre>475</pre></span><pre>		&gt;&gt;&gt; yourinstance.event.remove( callable )</pre></div>
<div class="skip"><span class="num"><pre>476</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>477</pre></span><pre>	:note: if use_weakref is True, we will weakref the eventfunction, and deal</pre></div>
<div class="cov"><span class="num"><pre>478</pre></span><pre>		properly with instance methods which would go out of scope immediatly otherwise</pre></div>
<div class="skip"><span class="num"><pre>479</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>480</pre></span><pre>	:note: using weak-references to ensure one does not keep objects alive,</pre></div>
<div class="cov"><span class="num"><pre>481</pre></span><pre>		see `Event.use_weakref`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>482</pre></span><pre>	__slots__ = tuple()</pre></div>
<div class="skip"><span class="num"><pre>483</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>484</pre></span><pre>	#{ Configuration</pre></div>
<div class="skip"><span class="num"><pre>485</pre></span><pre>	# if True, the sender, thus self of an instance of this class, will be put</pre></div>
<div class="skip"><span class="num"><pre>486</pre></span><pre>	# as first arguments to functions when called for a specific event</pre></div>
<div class="cov"><span class="num"><pre>487</pre></span><pre>	sender_as_argument = False</pre></div>
<div class="skip"><span class="num"><pre>488</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>489</pre></span><pre>	# if True, exceptions thrown when sending events will be reraised immediately</pre></div>
<div class="skip"><span class="num"><pre>490</pre></span><pre>	# and may stop execution of the event sender as well</pre></div>
<div class="cov"><span class="num"><pre>491</pre></span><pre>	reraise_on_error = False</pre></div>
<div class="skip"><span class="num"><pre>492</pre></span><pre>	#} END configuration</pre></div>
<div class="skip"><span class="num"><pre>493</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>494</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>495</pre></span><pre>	def listEventNames( cls ):</pre></div>
<div class="cov"><span class="num"><pre>496</pre></span><pre>		&quot;&quot;&quot;:return: list of event ids that exist on our class&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>497</pre></span><pre>		return [ name for name,member in inspect.getmembers( cls, lambda m: isinstance( m, Event ) ) ]</pre></div>
<div class="skip"><span class="num"><pre>498</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>499</pre></span><pre>	def clearAllEvents(self):</pre></div>
<div class="cov"><span class="num"><pre>500</pre></span><pre>		&quot;&quot;&quot;Remove all event receivers for all events registered in this instance.</pre></div>
<div class="skip"><span class="num"><pre>501</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>502</pre></span><pre>		:note: This usually doesn't need to be called directly, but might be useful </pre></div>
<div class="cov"><span class="num"><pre>503</pre></span><pre>			in conjunction with other system that do not release your strongly bound </pre></div>
<div class="cov"><span class="num"><pre>504</pre></span><pre>			instance&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>505</pre></span><pre>		# call remove once for each registered method to properly deregister them</pre></div>
<div class="cov"><span class="num"><pre>506</pre></span><pre>		for en in self.listEventNames():</pre></div>
<div class="cov"><span class="num"><pre>507</pre></span><pre>			event = getattr(self, en)</pre></div>
<div class="cov"><span class="num"><pre>508</pre></span><pre>			for key in event._getFunctionSet(self).copy():</pre></div>
<div class="cov"><span class="num"><pre>509</pre></span><pre>				event.remove(event._key_to_func(key))</pre></div>
<div class="skip"><span class="num"><pre>510</pre></span><pre>			# END for each function key</pre></div>
<div class="skip"><span class="num"><pre>511</pre></span><pre>		# END for each event whose methods are to clear </pre></div>
<div class="skip"><span class="num"><pre>512</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>513</pre></span><pre>	def sender(self):</pre></div>
<div class="cov"><span class="num"><pre>514</pre></span><pre>		&quot;&quot;&quot;:return: instance which sent the event you are currently processing</pre></div>
<div class="cov"><span class="num"><pre>515</pre></span><pre>		:raise ValueError: if no event is currently in progress&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>516</pre></span><pre>		if Event._curSender is None:</pre></div>
<div class="nocov"><span class="num"><pre>517</pre></span><pre>			raise ValueError(&quot;Cannot return sender as no event is being sent&quot;)</pre></div>
<div class="cov"><span class="num"><pre>518</pre></span><pre>		return Event._curSender</pre></div>
<div class="skip"><span class="num"><pre>519</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>520</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>521</pre></span><pre>class InterfaceMaster( iDuplicatable ):</pre></div>
<div class="cov"><span class="num"><pre>522</pre></span><pre>	&quot;&quot;&quot;Base class making the derived class an interface provider, allowing interfaces</pre></div>
<div class="cov"><span class="num"><pre>523</pre></span><pre>	to be set, queried and used including build-in use&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>524</pre></span><pre>	__slots__ = ( &quot;_idict&quot;, )</pre></div>
<div class="skip"><span class="num"><pre>525</pre></span><pre>	#{ Configuration</pre></div>
<div class="cov"><span class="num"><pre>526</pre></span><pre>	im_provide_on_instance = True			 # if true, interfaces are available directly through the class using descriptors</pre></div>
<div class="skip"><span class="num"><pre>527</pre></span><pre>	#} END configuration</pre></div>
<div class="skip"><span class="num"><pre>528</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>529</pre></span><pre>	#{ Helper Classes</pre></div>
<div class="cov"><span class="num"><pre>530</pre></span><pre>	class InterfaceDescriptor( object ):</pre></div>
<div class="cov"><span class="num"><pre>531</pre></span><pre>		&quot;&quot;&quot;Descriptor handing out interfaces from our interface dict</pre></div>
<div class="cov"><span class="num"><pre>532</pre></span><pre>		They allow access to interfaces directly through the InterfaceMaster without calling</pre></div>
<div class="cov"><span class="num"><pre>533</pre></span><pre>		extra functions&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>534</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>535</pre></span><pre>		def __init__( self, interfacename ):</pre></div>
<div class="cov"><span class="num"><pre>536</pre></span><pre>			self.iname = interfacename			# keep name of our interface</pre></div>
<div class="skip"><span class="num"><pre>537</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>538</pre></span><pre>		def __get__( self, inst, cls = None ):</pre></div>
<div class="skip"><span class="num"><pre>539</pre></span><pre>			# allow our instance to be manipulated if accessed through the class</pre></div>
<div class="cov"><span class="num"><pre>540</pre></span><pre>			if inst is None:</pre></div>
<div class="nocov"><span class="num"><pre>541</pre></span><pre>				return self</pre></div>
<div class="skip"><span class="num"><pre>542</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>543</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>544</pre></span><pre>				return inst.interface( self.iname )</pre></div>
<div class="nocov"><span class="num"><pre>545</pre></span><pre>			except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>546</pre></span><pre>				raise AttributeError( &quot;Interface %s does not exist&quot; % self.iname )</pre></div>
<div class="skip"><span class="num"><pre>547</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>548</pre></span><pre>		def __set__( self, value ):</pre></div>
<div class="nocov"><span class="num"><pre>549</pre></span><pre>			raise ValueError( &quot;Cannot set interfaces through the instance - use the setInterface method instead&quot; )</pre></div>
<div class="skip"><span class="num"><pre>550</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>551</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>552</pre></span><pre>	class _InterfaceHandler( object ):</pre></div>
<div class="cov"><span class="num"><pre>553</pre></span><pre>		&quot;&quot;&quot;Utility class passing all calls to the stored InterfaceBase, updating the</pre></div>
<div class="cov"><span class="num"><pre>554</pre></span><pre>		internal caller-id&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>555</pre></span><pre>		def __init__( self, ibase ):</pre></div>
<div class="cov"><span class="num"><pre>556</pre></span><pre>			self.__ibase = ibase</pre></div>
<div class="cov"><span class="num"><pre>557</pre></span><pre>			self.__callerid = ibase._num_callers</pre></div>
<div class="cov"><span class="num"><pre>558</pre></span><pre>			ibase._num_callers += 1</pre></div>
<div class="skip"><span class="num"><pre>559</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>560</pre></span><pre>			ibase._current_caller_id = self.__callerid		# assure the callback finds the right one</pre></div>
<div class="cov"><span class="num"><pre>561</pre></span><pre>			ibase.givenToCaller( )</pre></div>
<div class="skip"><span class="num"><pre>562</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>563</pre></span><pre>		def __getattr__( self, attr ):</pre></div>
<div class="cov"><span class="num"><pre>564</pre></span><pre>			self.__ibase._current_caller_id = self.__callerid 	# set our caller</pre></div>
<div class="cov"><span class="num"><pre>565</pre></span><pre>			return getattr( self.__ibase, attr )</pre></div>
<div class="skip"><span class="num"><pre>566</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>567</pre></span><pre>		def __del__( self ):</pre></div>
<div class="cov"><span class="num"><pre>568</pre></span><pre>			self.__ibase.aboutToRemoveFromCaller( )</pre></div>
<div class="cov"><span class="num"><pre>569</pre></span><pre>			self.__ibase._num_callers -= 1</pre></div>
<div class="cov"><span class="num"><pre>570</pre></span><pre>			self.__ibase._current_caller_id = -1</pre></div>
<div class="skip"><span class="num"><pre>571</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>572</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>573</pre></span><pre>	class InterfaceBase( object ):</pre></div>
<div class="cov"><span class="num"><pre>574</pre></span><pre>		&quot;&quot;&quot;If your interface class is derived from this base, you get access to</pre></div>
<div class="cov"><span class="num"><pre>575</pre></span><pre>		access to call to the number of your current caller.</pre></div>
<div class="skip"><span class="num"><pre>576</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>577</pre></span><pre>		:note: You can register an InterfaceBase with several InterfaceMasters and</pre></div>
<div class="cov"><span class="num"><pre>578</pre></span><pre>			share the caller count respectively&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>579</pre></span><pre>		__slots__ = ( &quot;_current_caller_id&quot;, &quot;_num_callers&quot; )</pre></div>
<div class="cov"><span class="num"><pre>580</pre></span><pre>		def __init__( self ):</pre></div>
<div class="cov"><span class="num"><pre>581</pre></span><pre>			self._current_caller_id	 = -1 # id of the caller currently operating on us</pre></div>
<div class="cov"><span class="num"><pre>582</pre></span><pre>			self._num_callers = 0		# the amount of possible callers, ids range from 0 to (num_callers-1)</pre></div>
<div class="skip"><span class="num"><pre>583</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>584</pre></span><pre>		def numCallers( self ):</pre></div>
<div class="cov"><span class="num"><pre>585</pre></span><pre>			&quot;&quot;&quot;:return: number possible callers&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>586</pre></span><pre>			return self._num_callers</pre></div>
<div class="skip"><span class="num"><pre>587</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>588</pre></span><pre>		def callerId( self ):</pre></div>
<div class="cov"><span class="num"><pre>589</pre></span><pre>			&quot;&quot;&quot;Return the number of the caller that called your interface method</pre></div>
<div class="skip"><span class="num"><pre>590</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>591</pre></span><pre>			:note: the return value of this method is undefined if called if the</pre></div>
<div class="cov"><span class="num"><pre>592</pre></span><pre>				method has been called by someone not being an official caller ( like yourself )&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>593</pre></span><pre>			return self._current_caller_id</pre></div>
<div class="skip"><span class="num"><pre>594</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>595</pre></span><pre>		def givenToCaller( self ):</pre></div>
<div class="cov"><span class="num"><pre>596</pre></span><pre>			&quot;&quot;&quot;Called once our interface has been given to a new caller.</pre></div>
<div class="cov"><span class="num"><pre>597</pre></span><pre>			The caller has not made a call yet, but its id can be queried&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>598</pre></span><pre>			pass</pre></div>
<div class="skip"><span class="num"><pre>599</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>600</pre></span><pre>		def aboutToRemoveFromCaller( self ):</pre></div>
<div class="cov"><span class="num"><pre>601</pre></span><pre>			&quot;&quot;&quot;Called once our interface is about to be removed from the current</pre></div>
<div class="cov"><span class="num"><pre>602</pre></span><pre>			caller - you will not receive a call from it anymore &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>603</pre></span><pre>			pass</pre></div>
<div class="skip"><span class="num"><pre>604</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>605</pre></span><pre>	#} END helper classes</pre></div>
<div class="skip"><span class="num"><pre>606</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>607</pre></span><pre>	#{ Object Overrides</pre></div>
<div class="cov"><span class="num"><pre>608</pre></span><pre>	def __init__( self ):</pre></div>
<div class="cov"><span class="num"><pre>609</pre></span><pre>		&quot;&quot;&quot;Initialize the interface base with some tracking variables&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>610</pre></span><pre>		self._idict = dict()			# keep interfacename-&gt;interfaceinstance relations</pre></div>
<div class="skip"><span class="num"><pre>611</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>612</pre></span><pre>	#} END object overrides</pre></div>
<div class="skip"><span class="num"><pre>613</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>614</pre></span><pre>	def copyFrom( self, other, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>615</pre></span><pre>		&quot;&quot;&quot;Copy all interface from other to self, use they duplciate method if</pre></div>
<div class="cov"><span class="num"><pre>616</pre></span><pre>		possibly &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>617</pre></span><pre>		for ifname, ifinst in other._idict.iteritems():</pre></div>
<div class="nocov"><span class="num"><pre>618</pre></span><pre>			myinst = ifinst</pre></div>
<div class="nocov"><span class="num"><pre>619</pre></span><pre>			if hasattr( ifinst, &quot;duplicate&quot; ):</pre></div>
<div class="nocov"><span class="num"><pre>620</pre></span><pre>				myinst = ifinst.duplicate( )</pre></div>
<div class="skip"><span class="num"><pre>621</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>622</pre></span><pre>			self.setInterface( ifname, myinst )</pre></div>
<div class="skip"><span class="num"><pre>623</pre></span><pre>		# END for each interface in other</pre></div>
<div class="skip"><span class="num"><pre>624</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>625</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>626</pre></span><pre>	#{ Interface</pre></div>
<div class="cov"><span class="num"><pre>627</pre></span><pre>	def setInterface( self, interfaceName, interfaceInstance ):</pre></div>
<div class="cov"><span class="num"><pre>628</pre></span><pre>		&quot;&quot;&quot;Set the given interfaceInstance to be handed out once an interface</pre></div>
<div class="cov"><span class="num"><pre>629</pre></span><pre>		with interfaceName is requested from the provider base</pre></div>
<div class="skip"><span class="num"><pre>630</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>631</pre></span><pre>		:param interfaceName: should start with i..., i.e. names would be iInterface</pre></div>
<div class="cov"><span class="num"><pre>632</pre></span><pre>			The name can be used to refer to the interface later on</pre></div>
<div class="cov"><span class="num"><pre>633</pre></span><pre>		:param interfaceInstance: instance to be handed out once an interface with the</pre></div>
<div class="cov"><span class="num"><pre>634</pre></span><pre>			given name is requested by the InterfaceMaster or None</pre></div>
<div class="cov"><span class="num"><pre>635</pre></span><pre>			if None, the interface will effectively be deleted</pre></div>
<div class="cov"><span class="num"><pre>636</pre></span><pre>		:raise ValueError: if given InterfaceBase has a master already &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>637</pre></span><pre>		if interfaceInstance is None:			# delete interface ?</pre></div>
<div class="skip"><span class="num"><pre>638</pre></span><pre>			# delete from dict</pre></div>
<div class="cov"><span class="num"><pre>639</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>640</pre></span><pre>				del( self._idict[ interfaceName ] )</pre></div>
<div class="cov"><span class="num"><pre>641</pre></span><pre>			except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>642</pre></span><pre>				pass</pre></div>
<div class="skip"><span class="num"><pre>643</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>644</pre></span><pre>			# delete class descriptor</pre></div>
<div class="cov"><span class="num"><pre>645</pre></span><pre>			if self.im_provide_on_instance:</pre></div>
<div class="cov"><span class="num"><pre>646</pre></span><pre>				try:</pre></div>
<div class="cov"><span class="num"><pre>647</pre></span><pre>					delattr( self.__class__, interfaceName )</pre></div>
<div class="cov"><span class="num"><pre>648</pre></span><pre>				except AttributeError:</pre></div>
<div class="cov"><span class="num"><pre>649</pre></span><pre>					pass</pre></div>
<div class="skip"><span class="num"><pre>650</pre></span><pre>			# END del on class</pre></div>
<div class="skip"><span class="num"><pre>651</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>652</pre></span><pre>		# END interface deleting</pre></div>
<div class="cov"><span class="num"><pre>653</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>654</pre></span><pre>			self._idict[ interfaceName ] = interfaceInstance</pre></div>
<div class="skip"><span class="num"><pre>655</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>656</pre></span><pre>			# set on class ?</pre></div>
<div class="cov"><span class="num"><pre>657</pre></span><pre>			if self.im_provide_on_instance:</pre></div>
<div class="cov"><span class="num"><pre>658</pre></span><pre>				setattr( self.__class__, interfaceName, self.InterfaceDescriptor( interfaceName ) )</pre></div>
<div class="skip"><span class="num"><pre>659</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>660</pre></span><pre>		# provide class variables ?</pre></div>
<div class="skip"><span class="num"><pre>661</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>662</pre></span><pre>	def interface( self, interfaceName ):</pre></div>
<div class="cov"><span class="num"><pre>663</pre></span><pre>		&quot;&quot;&quot;:return: an interface registered with interfaceName</pre></div>
<div class="cov"><span class="num"><pre>664</pre></span><pre>		:raise ValueError: if no such interface exists&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>665</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>666</pre></span><pre>			iinst = self._idict[ interfaceName ]</pre></div>
<div class="skip"><span class="num"><pre>667</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>668</pre></span><pre>			# return wrapper if we can, otherwise just</pre></div>
<div class="cov"><span class="num"><pre>669</pre></span><pre>			if isinstance( iinst, self.InterfaceBase ):</pre></div>
<div class="cov"><span class="num"><pre>670</pre></span><pre>				return self._InterfaceHandler( iinst )</pre></div>
<div class="cov"><span class="num"><pre>671</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>672</pre></span><pre>				return iinst</pre></div>
<div class="cov"><span class="num"><pre>673</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>674</pre></span><pre>			raise ValueError( &quot;Interface %s does not exist&quot; % interfaceName )</pre></div>
<div class="skip"><span class="num"><pre>675</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>676</pre></span><pre>	def listInterfaces( self ):</pre></div>
<div class="cov"><span class="num"><pre>677</pre></span><pre>		&quot;&quot;&quot;:return: list of names indicating interfaces available at our InterfaceMaster&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>678</pre></span><pre>		return self._idict.keys()</pre></div>
<div class="skip"><span class="num"><pre>679</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>680</pre></span><pre>	#} END interface</pre></div>
<div class="skip"><span class="num"><pre>681</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>682</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>683</pre></span><pre>class Singleton(object) :</pre></div>
<div class="cov"><span class="num"><pre>684</pre></span><pre>	&quot;&quot;&quot; Singleton classes can be derived from this class,</pre></div>
<div class="cov"><span class="num"><pre>685</pre></span><pre>		you can derive from other classes as long as Singleton comes first (and class doesn't override __new__ ) &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>686</pre></span><pre>	def __new__(cls, *p, **k):</pre></div>
<div class="skip"><span class="num"><pre>687</pre></span><pre>		# explicitly query the classes dict to allow subclassing of singleton types.</pre></div>
<div class="skip"><span class="num"><pre>688</pre></span><pre>		# Querying with hasattr would follow the inheritance graph</pre></div>
<div class="cov"><span class="num"><pre>689</pre></span><pre>		if '_the_instance' not in cls.__dict__:</pre></div>
<div class="cov"><span class="num"><pre>690</pre></span><pre>			cls._the_instance = super(Singleton, cls).__new__(cls)</pre></div>
<div class="cov"><span class="num"><pre>691</pre></span><pre>		return cls._the_instance</pre></div>
<div class="skip"><span class="num"><pre>692</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>693</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>694</pre></span><pre>class CallOnDeletion( object ):</pre></div>
<div class="cov"><span class="num"><pre>695</pre></span><pre>	&quot;&quot;&quot;Call the given callable object once this object is being deleted</pre></div>
<div class="cov"><span class="num"><pre>696</pre></span><pre>	Its usefull if you want to assure certain code to run once the parent scope</pre></div>
<div class="cov"><span class="num"><pre>697</pre></span><pre>	of this object looses focus&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>698</pre></span><pre>	__slots__ = &quot;callableobj&quot;</pre></div>
<div class="cov"><span class="num"><pre>699</pre></span><pre>	def __init__( self, callableobj ):</pre></div>
<div class="cov"><span class="num"><pre>700</pre></span><pre>		self.callableobj = callableobj</pre></div>
<div class="skip"><span class="num"><pre>701</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>702</pre></span><pre>	def __del__( self ):</pre></div>
<div class="cov"><span class="num"><pre>703</pre></span><pre>		if self.callableobj is not None:</pre></div>
<div class="cov"><span class="num"><pre>704</pre></span><pre>			self.callableobj( )</pre></div>
<div class="skip"><span class="num"><pre>705</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>706</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>707</pre></span><pre>class DAGTree( nx.DiGraph ):</pre></div>
<div class="cov"><span class="num"><pre>708</pre></span><pre>	&quot;&quot;&quot;Adds utility functions to DirectedTree allowing to handle a directed tree like a dag</pre></div>
<div class="cov"><span class="num"><pre>709</pre></span><pre>	:note: currently this tree does not support instancing</pre></div>
<div class="cov"><span class="num"><pre>710</pre></span><pre>	:todo: add instancing support&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>711</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>712</pre></span><pre>	def children( self, n ):</pre></div>
<div class="cov"><span class="num"><pre>713</pre></span><pre>		&quot;&quot;&quot; :return: list of children of given node n &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>714</pre></span><pre>		return list( self.children_iter( n ) )</pre></div>
<div class="skip"><span class="num"><pre>715</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>716</pre></span><pre>	def children_iter( self, n ):</pre></div>
<div class="cov"><span class="num"><pre>717</pre></span><pre>		&quot;&quot;&quot; :return: iterator with children of given node n&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>718</pre></span><pre>		return ( e[1] for e in self.out_edges_iter( n ) )</pre></div>
<div class="skip"><span class="num"><pre>719</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>720</pre></span><pre>	def parent( self, n ):</pre></div>
<div class="cov"><span class="num"><pre>721</pre></span><pre>		&quot;&quot;&quot;:return: parent of node n</pre></div>
<div class="cov"><span class="num"><pre>722</pre></span><pre>		:note: currently there is only one parent, as instancing is not supported yet&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>723</pre></span><pre>		for parent in  self.predecessors_iter( n ):</pre></div>
<div class="cov"><span class="num"><pre>724</pre></span><pre>			return parent</pre></div>
<div class="cov"><span class="num"><pre>725</pre></span><pre>		return None</pre></div>
<div class="skip"><span class="num"><pre>726</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>727</pre></span><pre>	def parent_iter( self, n ):</pre></div>
<div class="cov"><span class="num"><pre>728</pre></span><pre>		&quot;&quot;&quot;:return: iterator returning all parents of node n&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>729</pre></span><pre>		while True:</pre></div>
<div class="cov"><span class="num"><pre>730</pre></span><pre>			p = self.parent( n )</pre></div>
<div class="cov"><span class="num"><pre>731</pre></span><pre>			if p is None:</pre></div>
<div class="cov"><span class="num"><pre>732</pre></span><pre>				raise StopIteration( )</pre></div>
<div class="cov"><span class="num"><pre>733</pre></span><pre>			yield p</pre></div>
<div class="cov"><span class="num"><pre>734</pre></span><pre>			n = p</pre></div>
<div class="skip"><span class="num"><pre>735</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>736</pre></span><pre>	def get_root( self, startnode = None ):</pre></div>
<div class="cov"><span class="num"><pre>737</pre></span><pre>		&quot;&quot;&quot;:return: the root node of this dag tree</pre></div>
<div class="cov"><span class="num"><pre>738</pre></span><pre>		:param startnode: if None, the first node will be used to get the root from</pre></div>
<div class="cov"><span class="num"><pre>739</pre></span><pre>			( good for single rooted dags ), otherwise this node will be used to get the root from</pre></div>
<div class="cov"><span class="num"><pre>740</pre></span><pre>			- thus it must exist in the dag tree&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>741</pre></span><pre>		if startnode is None:</pre></div>
<div class="nocov"><span class="num"><pre>742</pre></span><pre>			startnode = self.nodes_iter().next()</pre></div>
<div class="skip"><span class="num"><pre>743</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>744</pre></span><pre>		root = None</pre></div>
<div class="nocov"><span class="num"><pre>745</pre></span><pre>		for parent in self.parent_iter( startnode ):</pre></div>
<div class="nocov"><span class="num"><pre>746</pre></span><pre>			root = parent</pre></div>
<div class="skip"><span class="num"><pre>747</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>748</pre></span><pre>		return root</pre></div>
<div class="skip"><span class="num"><pre>749</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>750</pre></span><pre>	def to_hierarchy_file(self, root, output_path):</pre></div>
<div class="cov"><span class="num"><pre>751</pre></span><pre>		&quot;&quot;&quot;Write ourselves in hierarchy file format to the given output_path.</pre></div>
<div class="skip"><span class="num"><pre>752</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>753</pre></span><pre>		:param root: The root of the written file, nodes above it will not be serialized.</pre></div>
<div class="cov"><span class="num"><pre>754</pre></span><pre>		:note: Directories are expected to exist</pre></div>
<div class="cov"><span class="num"><pre>755</pre></span><pre>		:raise ValueError: If an node's string representation contains a newline or </pre></div>
<div class="cov"><span class="num"><pre>756</pre></span><pre>			starts with a tab</pre></div>
<div class="cov"><span class="num"><pre>757</pre></span><pre>		:note: works best with strings as nodes, which may not contain newlines&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>758</pre></span><pre>		fp = open(output_path, &quot;wb&quot;)</pre></div>
<div class="nocov"><span class="num"><pre>759</pre></span><pre>		for depth, item in iterNetworkxGraph(self, root, branch_first=False, ignore_startitem=False):</pre></div>
<div class="nocov"><span class="num"><pre>760</pre></span><pre>			itemstr = str(item)</pre></div>
<div class="nocov"><span class="num"><pre>761</pre></span><pre>			if itemstr.startswith(&quot;\t&quot;) or &quot;\n&quot; in itemstr:</pre></div>
<div class="nocov"><span class="num"><pre>762</pre></span><pre>				raise ValueError(&quot;Item %r contained characters unsupported by the hierarchy file format&quot;)</pre></div>
<div class="skip"><span class="num"><pre>763</pre></span><pre>			# END handle serialization</pre></div>
<div class="nocov"><span class="num"><pre>764</pre></span><pre>			fp.write(&quot;%s%s\n&quot; % (&quot;\t&quot;*depth, itemstr))</pre></div>
<div class="skip"><span class="num"><pre>765</pre></span><pre>		# END for each item</pre></div>
<div class="nocov"><span class="num"><pre>766</pre></span><pre>		fp.close()</pre></div>
<div class="skip"><span class="num"><pre>767</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>768</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>769</pre></span><pre>class PipeSeparatedFile( object ):</pre></div>
<div class="cov"><span class="num"><pre>770</pre></span><pre>	&quot;&quot;&quot;Read and write simple pipe separated files.</pre></div>
<div class="skip"><span class="num"><pre>771</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>772</pre></span><pre>	The number of column must remain the same per line</pre></div>
<div class="cov"><span class="num"><pre>773</pre></span><pre>	**Format**:</pre></div>
<div class="skip"><span class="num"><pre>774</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>775</pre></span><pre>		val11 | val2 | valn</pre></div>
<div class="cov"><span class="num"><pre>776</pre></span><pre>		...</pre></div>
<div class="cov"><span class="num"><pre>777</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>778</pre></span><pre>	kSeparator = '|'</pre></div>
<div class="cov"><span class="num"><pre>779</pre></span><pre>	__slots__ = ( &quot;_fileobj&quot;, &quot;_columncount&quot;, &quot;_formatstr&quot; )</pre></div>
<div class="skip"><span class="num"><pre>780</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>781</pre></span><pre>	def __init__( self, fileobj ):</pre></div>
<div class="cov"><span class="num"><pre>782</pre></span><pre>		&quot;&quot;&quot;Initialize the instance</pre></div>
<div class="skip"><span class="num"><pre>783</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>784</pre></span><pre>		:param fileobj: fileobject where new lines will be written to or read from</pre></div>
<div class="cov"><span class="num"><pre>785</pre></span><pre>			It must already be opened for reading and/or writing respectively&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>786</pre></span><pre>		self._fileobj = fileobj</pre></div>
<div class="cov"><span class="num"><pre>787</pre></span><pre>		self._columncount = None</pre></div>
<div class="skip"><span class="num"><pre>788</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>789</pre></span><pre>	def beginReading( self ):</pre></div>
<div class="cov"><span class="num"><pre>790</pre></span><pre>		&quot;&quot;&quot;Start reading the file&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>791</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>792</pre></span><pre>	def readColumnLine( self ):</pre></div>
<div class="cov"><span class="num"><pre>793</pre></span><pre>		&quot;&quot;&quot;Generator reading one line after another, returning the stripped columns</pre></div>
<div class="skip"><span class="num"><pre>794</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>795</pre></span><pre>		:return: tuple of stripped column strings</pre></div>
<div class="cov"><span class="num"><pre>796</pre></span><pre>		:raise ValueError: if the column count changes between the lines&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>797</pre></span><pre>		for line in self._fileobj:</pre></div>
<div class="cov"><span class="num"><pre>798</pre></span><pre>			if not len( line.strip() ):</pre></div>
<div class="cov"><span class="num"><pre>799</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>800</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>801</pre></span><pre>			tokens = [ item.strip() for item in line.split( self.kSeparator ) ]</pre></div>
<div class="cov"><span class="num"><pre>802</pre></span><pre>			if not self._columncount:</pre></div>
<div class="cov"><span class="num"><pre>803</pre></span><pre>				self._columncount = len( tokens )</pre></div>
<div class="skip"><span class="num"><pre>804</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>805</pre></span><pre>			if self._columncount != len( tokens ):</pre></div>
<div class="nocov"><span class="num"><pre>806</pre></span><pre>				raise ValueError( &quot;Columncount changed between successive lines&quot; )</pre></div>
<div class="skip"><span class="num"><pre>807</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>808</pre></span><pre>			yield tuple( tokens )</pre></div>
<div class="skip"><span class="num"><pre>809</pre></span><pre>		# END for each line</pre></div>
<div class="skip"><span class="num"><pre>810</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>811</pre></span><pre>	def beginWriting( self, columnSizes ):</pre></div>
<div class="cov"><span class="num"><pre>812</pre></span><pre>		&quot;&quot;&quot;intiialize the writing process</pre></div>
<div class="skip"><span class="num"><pre>813</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>814</pre></span><pre>		:param columnSizes: list of ints defining the size in characters for each column you plan to feed</pre></div>
<div class="cov"><span class="num"><pre>815</pre></span><pre>		:note: When done writing, you have to close the file object yourself ( there is no endWriting method here )&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>816</pre></span><pre>		columnTokens = [ &quot;%%-%is&quot; % csize for csize in columnSizes ]</pre></div>
<div class="nocov"><span class="num"><pre>817</pre></span><pre>		self._formatstr = ( ( self.kSeparator + &quot; &quot; ).join( columnTokens ) ) + &quot;\n&quot;</pre></div>
<div class="skip"><span class="num"><pre>818</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>819</pre></span><pre>	def writeTokens( self, tokens ):</pre></div>
<div class="cov"><span class="num"><pre>820</pre></span><pre>		&quot;&quot;&quot;Write the list of tokens to the file accordingly</pre></div>
<div class="skip"><span class="num"><pre>821</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>822</pre></span><pre>		:param tokens: one token per column that you want to write</pre></div>
<div class="cov"><span class="num"><pre>823</pre></span><pre>		:raise TypeError: If column count changed between successive calls&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>824</pre></span><pre>		self._fileobj.write( self._formatstr % tokens )</pre></div>
<div class="skip"><span class="num"><pre>825</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>826</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>827</pre></span><pre>class MetaCopyClsMembers( type ):</pre></div>
<div class="cov"><span class="num"><pre>828</pre></span><pre>	&quot;&quot;&quot;Meta class copying members from given classes onto the type to be created</pre></div>
<div class="cov"><span class="num"><pre>829</pre></span><pre>	it will read the following attributes from the class dict:</pre></div>
<div class="cov"><span class="num"><pre>830</pre></span><pre>	``forbiddenMembers``, ``overwritePrefix``, ``__virtual_bases__``</pre></div>
<div class="skip"><span class="num"><pre>831</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>832</pre></span><pre>	The virtual bases are a tuple of base classes whose members you whish to receive</pre></div>
<div class="cov"><span class="num"><pre>833</pre></span><pre>	For information on these members, check the docs of `copyClsMembers`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>834</pre></span><pre>	def __new__( metacls, name, bases, clsdict ):</pre></div>
<div class="nocov"><span class="num"><pre>835</pre></span><pre>		forbiddenMembers = clsdict.get( 'forbiddenMembers', [] )</pre></div>
<div class="nocov"><span class="num"><pre>836</pre></span><pre>		overwritePrefix = clsdict.get( 'overwritePrefix', None )</pre></div>
<div class="nocov"><span class="num"><pre>837</pre></span><pre>		vbases = clsdict.get( '__virtual_bases__', [] )</pre></div>
<div class="skip"><span class="num"><pre>838</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>839</pre></span><pre>		for sourcecls in vbases:</pre></div>
<div class="nocov"><span class="num"><pre>840</pre></span><pre>			for name,member in sourcecls.__dict__.iteritems():</pre></div>
<div class="nocov"><span class="num"><pre>841</pre></span><pre>				if name in forbiddenMembers:</pre></div>
<div class="nocov"><span class="num"><pre>842</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>843</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>844</pre></span><pre>				# store original - overwritten members must still be able to access it</pre></div>
<div class="nocov"><span class="num"><pre>845</pre></span><pre>				if name in clsdict:</pre></div>
<div class="nocov"><span class="num"><pre>846</pre></span><pre>					if not overwritePrefix:</pre></div>
<div class="nocov"><span class="num"><pre>847</pre></span><pre>						continue</pre></div>
<div class="nocov"><span class="num"><pre>848</pre></span><pre>					morig = clsdict[ name ]</pre></div>
<div class="nocov"><span class="num"><pre>849</pre></span><pre>					clsdict[ overwritePrefix+name ] = morig</pre></div>
<div class="nocov"><span class="num"><pre>850</pre></span><pre>				clsdict[ name ] = member</pre></div>
<div class="skip"><span class="num"><pre>851</pre></span><pre>			# END for each sourcecls member</pre></div>
<div class="skip"><span class="num"><pre>852</pre></span><pre>		# END for each sourcecls in bases</pre></div>
<div class="skip"><span class="num"><pre>853</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>854</pre></span><pre>		return super( MetaCopyClsMembers, metacls ).__new__( metacls, name, bases, clsdict )</pre></div>
<div class="skip"><span class="num"><pre>855</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>856</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>857</pre></span><pre>#{ Predicates</pre></div>
<div class="skip"><span class="num"><pre>858</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>859</pre></span><pre># general boolean</pre></div>
<div class="cov"><span class="num"><pre>860</pre></span><pre>class And( object ):</pre></div>
<div class="cov"><span class="num"><pre>861</pre></span><pre>	&quot;&quot;&quot;For use with python's filter method, simulates logical AND</pre></div>
<div class="cov"><span class="num"><pre>862</pre></span><pre>	Usage: filter( And( f1,f2,fn ), sequence )&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>863</pre></span><pre>	__slots__ = &quot;functions&quot;</pre></div>
<div class="cov"><span class="num"><pre>864</pre></span><pre>	def __init__( self, *args ):</pre></div>
<div class="cov"><span class="num"><pre>865</pre></span><pre>		&quot;&quot;&quot;args must contain the filter methods to be AND'ed</pre></div>
<div class="cov"><span class="num"><pre>866</pre></span><pre>		To append functions after creation, simply access the 'functions' attribute</pre></div>
<div class="cov"><span class="num"><pre>867</pre></span><pre>		directly as a list&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>868</pre></span><pre>		self.functions = list( args )</pre></div>
<div class="skip"><span class="num"><pre>869</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>870</pre></span><pre>	def __call__( self, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>871</pre></span><pre>		&quot;&quot;&quot;Called during filter function, return true if all functions return true&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>872</pre></span><pre>		val = True</pre></div>
<div class="cov"><span class="num"><pre>873</pre></span><pre>		for func in self.functions:</pre></div>
<div class="cov"><span class="num"><pre>874</pre></span><pre>			val = val and func( *args, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>875</pre></span><pre>			if not val:</pre></div>
<div class="cov"><span class="num"><pre>876</pre></span><pre>				return val</pre></div>
<div class="skip"><span class="num"><pre>877</pre></span><pre>		# END for each function</pre></div>
<div class="cov"><span class="num"><pre>878</pre></span><pre>		return val</pre></div>
<div class="skip"><span class="num"><pre>879</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>880</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>881</pre></span><pre>class Or( object ):</pre></div>
<div class="cov"><span class="num"><pre>882</pre></span><pre>	&quot;&quot;&quot;For use with python's filter method, simulates logical OR</pre></div>
<div class="cov"><span class="num"><pre>883</pre></span><pre>	Usage: filter( Or( f1,f2,fn ), sequence ) &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>884</pre></span><pre>	__slots__ = &quot;functions&quot;</pre></div>
<div class="cov"><span class="num"><pre>885</pre></span><pre>	def __init__( self, *args ):</pre></div>
<div class="cov"><span class="num"><pre>886</pre></span><pre>		&quot;&quot;&quot;args must contain the filter methods to be AND'ed&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>887</pre></span><pre>		self.functions = args</pre></div>
<div class="skip"><span class="num"><pre>888</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>889</pre></span><pre>	def __call__( self, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>890</pre></span><pre>		&quot;&quot;&quot;Called during filter function, return true if all functions return true&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>891</pre></span><pre>		val = False</pre></div>
<div class="cov"><span class="num"><pre>892</pre></span><pre>		for func in self.functions:</pre></div>
<div class="cov"><span class="num"><pre>893</pre></span><pre>			val = val or func( *args, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>894</pre></span><pre>			if val:</pre></div>
<div class="cov"><span class="num"><pre>895</pre></span><pre>				return val</pre></div>
<div class="skip"><span class="num"><pre>896</pre></span><pre>		# END for each function</pre></div>
<div class="cov"><span class="num"><pre>897</pre></span><pre>		return val</pre></div>
<div class="skip"><span class="num"><pre>898</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>899</pre></span><pre>#} END predicates</pre></div>
<div class="skip"><span class="num"><pre>900</pre></span><pre></pre></div>
</div>
</body>
</html>
