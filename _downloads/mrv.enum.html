<html>
<head>
<title>mrv.enum</title>
</head>
<body>
mrv.enum
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 239 lines<br/>
Missed: 4 lines<br/>
Skipped 98 lines<br/>
Percent: 98 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;This module is designed to be the equivalent of the enum type in other</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>languages. An enumeration object is created at run time, and contains</pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>named members that are the enumeration elements.</pre></div>
<div class="skip"><span class="num"><pre>  5</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>The enumeration is also a tuple of all of the values in it. You can iterate</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>through the values, perform 'in' tests, slicing, etc. It also includes</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>functions to lookup specific values by name, or names by value.</pre></div>
<div class="skip"><span class="num"><pre>  9</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>You can specify your own element values, or use the create factory method</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>to create default Elements. These elements are unique system wide, and are</pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>ordered based on the order of the elements in the enumeration. They also</pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>are _repr_'d by the name of the element, which is convenient for testing,</pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>debugging, and generation text output.</pre></div>
<div class="skip"><span class="num"><pre> 15</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>Example Code:</pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>	&gt;&gt;&gt;	# Using Element values</pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>	&gt;&gt;&gt; Colors = Enumeration.create('red', 'green', 'blue')</pre></div>
<div class="skip"><span class="num"><pre> 19</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 20</pre></span><pre>	&gt;&gt;&gt; # Using explicitly specified values</pre></div>
<div class="cov"><span class="num"><pre> 21</pre></span><pre>	&gt;&gt;&gt;Borders = Enumeration.create(('SUNKEN', 1),</pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>	&gt;&gt;&gt;							 	('RAISED', 32),</pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>	&gt;&gt;&gt;							 	('FLAT', 2))</pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>	&gt;&gt;&gt; x = Colors.red</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>	&gt;&gt;&gt; y = Colors.blue</pre></div>
<div class="skip"><span class="num"><pre> 27</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>	&gt;&gt;&gt; assert x &lt; y</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>	&gt;&gt;&gt; assert x == Colors('red')</pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>	&gt;&gt;&gt; assert Borders.FLAT == 2:</pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>	&gt;&gt;&gt; assert 1 in Borders</pre></div>
<div class="skip"><span class="num"><pre> 32</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>:note: slightly modified by Sebastian Thiel to be more flexible and suitable as</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>	base class</pre></div>
<div class="cov"><span class="num"><pre> 35</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>__contact__='garret at bgb dot cc'</pre></div>
<div class="cov"><span class="num"><pre> 38</pre></span><pre>__license__='freeware'</pre></div>
<div class="skip"><span class="num"><pre> 39</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 40</pre></span><pre>import platform</pre></div>
<div class="skip"><span class="num"><pre> 41</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>__all__ = (&quot;Element&quot;, &quot;Enumeration&quot;, &quot;create&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 43</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>class Element(object):</pre></div>
<div class="cov"><span class="num"><pre> 45</pre></span><pre>	&quot;&quot;&quot;Internal helper class used to represent an ordered abstract value.</pre></div>
<div class="skip"><span class="num"><pre> 46</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>	The values have string representations, have strictly defined ordering</pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>	(inside the set) and are never equal to anything but themselves.</pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>	They are usually created through the create factory method as values</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>	for Enumerations.</pre></div>
<div class="skip"><span class="num"><pre> 52</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>	They assume that the enumeration member will be filled in before any</pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>	comparisons are used. This is done by the Enumeration constructor.</pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 56</pre></span><pre>	# we do not define slots to stay pickable ( without reimplementing things )</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>	def __init__(self, name, value):</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>		self._name = name</pre></div>
<div class="cov"><span class="num"><pre> 59</pre></span><pre>		self._value = value</pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>		self.enumeration = None # Will be filled in later</pre></div>
<div class="skip"><span class="num"><pre> 61</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>	def __repr__(self):</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>		return self._name</pre></div>
<div class="skip"><span class="num"><pre> 64</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>	def _checkType( self, other ):</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>		&quot;&quot;&quot;:raise TypeError: if other cannot be used with this element&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>		if ( self.__class__ != other.__class__ ) or ( self.enumeration is not other.enumeration ):</pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>			raise TypeError( &quot;%s is incompatible with %s&quot; % ( other, self ) )</pre></div>
<div class="skip"><span class="num"><pre> 69</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>	def __cmp__(self, other):</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>		&quot;&quot;&quot;We override cmp only because we want the ordering of elements</pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>		in an enumeration to reflect their position in the enumeration.</pre></div>
<div class="cov"><span class="num"><pre> 73</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>			self._checkType( other )</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>		except TypeError:</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>			return NotImplemented	# to make cmp fail</pre></div>
<div class="skip"><span class="num"><pre> 78</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 79</pre></span><pre>		# If we are both elements in the same enumeration, compare</pre></div>
<div class="skip"><span class="num"><pre> 80</pre></span><pre>		#	values for ordering</pre></div>
<div class="cov"><span class="num"><pre> 81</pre></span><pre>		return cmp(self._value, other._value)</pre></div>
<div class="skip"><span class="num"><pre> 82</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>	def _checkBitflag( self ):</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>		if not self.enumeration._supports_bitflags:</pre></div>
<div class="nocov"><span class="num"><pre> 85</pre></span><pre>			raise TypeError( &quot;Enumeration %s of element %s has no bitflag support&quot; % ( self.enumeration, self ) )</pre></div>
<div class="skip"><span class="num"><pre> 86</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	def __or__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>		&quot;&quot;&quot;Allows oring values together - only works if the values are actually orable</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>		integer values</pre></div>
<div class="skip"><span class="num"><pre> 90</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>		:return: integer with the ored result</pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>		:raise TypeError: if we are not a bitflag or other is not an element of our enumeration&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>		self._checkType( other )</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>		self._checkBitflag()</pre></div>
<div class="cov"><span class="num"><pre> 95</pre></span><pre>		return self.value() | other.value()</pre></div>
<div class="skip"><span class="num"><pre> 96</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>	def __xor__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>		&quot;&quot;&quot;Allows to x-or values together - only works if element's values are xorable</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>		integer values.</pre></div>
<div class="skip"><span class="num"><pre>100</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>101</pre></span><pre>		:param other: integer</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>		:return: integer with the xored result&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>		self._checkBitflag()</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>		return self.value() ^ other</pre></div>
<div class="skip"><span class="num"><pre>105</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>106</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>	def __and__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>		&quot;&quot;&quot;Allow and with integers</pre></div>
<div class="skip"><span class="num"><pre>109</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>		:return: self if self &amp; other == self or None if our bit is not set in other</pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>		:raise TypeError: if other is not an int&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>112</pre></span><pre>		if not isinstance( other, int ):</pre></div>
<div class="nocov"><span class="num"><pre>113</pre></span><pre>			raise TypeError( &quot;require integer, got %s&quot; % type( other ) )</pre></div>
<div class="skip"><span class="num"><pre>114</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>		if self.value() &amp; other:</pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>			return self</pre></div>
<div class="skip"><span class="num"><pre>117</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>		return None</pre></div>
<div class="skip"><span class="num"><pre>119</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>	def value( self ):</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>		&quot;&quot;&quot;:return: own value&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>		return self._value</pre></div>
<div class="skip"><span class="num"><pre>123</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>	def name( self ):</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>		&quot;&quot;&quot;:return: name of the element&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>		return self._name</pre></div>
<div class="skip"><span class="num"><pre>127</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>128</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>class Enumeration(tuple):</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>	&quot;&quot;&quot;This class represents an enumeration. You should not normally create</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>	multiple instances of the same enumeration, instead create one with</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>	however many references are convenient.</pre></div>
<div class="skip"><span class="num"><pre>133</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>	The enumeration is a tuple of all of the values in it. You can iterate</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>	through the values, perform 'in' tests, slicing, etc. It also includes</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>	functions to lookup specific values by name, or names by value.</pre></div>
<div class="skip"><span class="num"><pre>137</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>	You can specify your own element values, or use the create factory method</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>	to create default Elements. These elements are unique system wide, and are</pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>	ordered based on the order of the elements in the enumeration. They also</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>	are _repr_'d by the name of the element, which is convenient for testing,</pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>	debugging, and generation text output.</pre></div>
<div class="skip"><span class="num"><pre>143</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>	:note: pickling this class with Elements will fail as they contain cyclic</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>		references that it cannot deal with</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>	:todo: implement proper pickle __getstate__ and __setstate__ that deal with</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>		that problem</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>	_slots_ = ( &quot;_nameMap&quot;, &quot;_valueMap&quot;, &quot;_supports_bitflags&quot; )</pre></div>
<div class="skip"><span class="num"><pre>150</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>	def __new__(self, names, values, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>		&quot;&quot;&quot;This method is needed to get the tuple parent class to do the</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>		Right Thing(tm). &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>		return tuple.__new__(self, values)</pre></div>
<div class="skip"><span class="num"><pre>155</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>	def __setattr__( self, name, value ):</pre></div>
<div class="cov"><span class="num"><pre>157</pre></span><pre>		&quot;&quot;&quot;Do not allow to change this instance&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>158</pre></span><pre>		if name in self._slots_:</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>			return super( Enumeration, self ).__setattr__( name, value )</pre></div>
<div class="skip"><span class="num"><pre>160</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>		raise AttributeError( &quot;No assignments allowed&quot; )</pre></div>
<div class="skip"><span class="num"><pre>162</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>	def __getattr__( self , attr ):</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>		&quot;&quot;&quot;Prefer to return value from our value map&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>165</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>166</pre></span><pre>			return self.valueFromName( attr )</pre></div>
<div class="cov"><span class="num"><pre>167</pre></span><pre>		except ValueError:</pre></div>
<div class="cov"><span class="num"><pre>168</pre></span><pre>			raise AttributeError( &quot;Element %s is not part of the enumeration&quot; % attr )</pre></div>
<div class="skip"><span class="num"><pre>169</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>170</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>	def __init__(self, names, values, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>172</pre></span><pre>		&quot;&quot;&quot;The arguments needed to construct this class are a list of</pre></div>
<div class="cov"><span class="num"><pre>173</pre></span><pre>		element names (which must be unique strings), and element values</pre></div>
<div class="cov"><span class="num"><pre>174</pre></span><pre>		(which can be any type of value). If you don't have special needs,</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>		then it's recommended that you use Element instances for the values.</pre></div>
<div class="skip"><span class="num"><pre>176</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>		This constructor is normally called through the create factory (which</pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>		will create Elements for you), but that is not a requirement.</pre></div>
<div class="cov"><span class="num"><pre>179</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>180</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>181</pre></span><pre>		assert len(names) == len(values)</pre></div>
<div class="skip"><span class="num"><pre>182</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>183</pre></span><pre>		# We are a tuple of our values, plus more....</pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>		tuple.__init__(self)</pre></div>
<div class="skip"><span class="num"><pre>185</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>186</pre></span><pre>		self._nameMap = {}</pre></div>
<div class="cov"><span class="num"><pre>187</pre></span><pre>		self._valueMap = {}</pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>		self._supports_bitflags = kwargs.get( &quot;_is_bitflag&quot;, False )		# insurance for bitflags</pre></div>
<div class="skip"><span class="num"><pre>189</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>190</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>191</pre></span><pre>		for i in xrange(len(names)):</pre></div>
<div class="cov"><span class="num"><pre>192</pre></span><pre>			name = names[i]</pre></div>
<div class="cov"><span class="num"><pre>193</pre></span><pre>			value = values[i]</pre></div>
<div class="skip"><span class="num"><pre>194</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>195</pre></span><pre>			# Tell the elements which enumeration they belong too</pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>			if isinstance( value, Element ):</pre></div>
<div class="cov"><span class="num"><pre>197</pre></span><pre>				value.enumeration = self</pre></div>
<div class="skip"><span class="num"><pre>198</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre>			# Prove that all names are unique</pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>			assert not name in self._nameMap</pre></div>
<div class="skip"><span class="num"><pre>201</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>202</pre></span><pre>			# create mappings from name to value, and vice versa</pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>			self._nameMap[name] = value</pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>			self._valueMap[value] = name</pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>206</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>207</pre></span><pre>	def valueFromName(self, name):</pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>		&quot;&quot;&quot;Look up the enumeration value for a given element name.</pre></div>
<div class="skip"><span class="num"><pre>209</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>		:raise ValueError:&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>212</pre></span><pre>			return self._nameMap[name]</pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>			raise ValueError(&quot;Name %r not found in enumeration, pick one of %s&quot; % (name, ', '.join(str(e) for e in self)))</pre></div>
<div class="skip"><span class="num"><pre>215</pre></span><pre>		# END exception handling</pre></div>
<div class="skip"><span class="num"><pre>216</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>	def nameFromValue(self, value):</pre></div>
<div class="cov"><span class="num"><pre>218</pre></span><pre>		&quot;&quot;&quot;Look up the name of an enumeration element, given it's value.</pre></div>
<div class="skip"><span class="num"><pre>219</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>		If there are multiple elements with the same value, you will only</pre></div>
<div class="cov"><span class="num"><pre>221</pre></span><pre>		get a single matching name back. Which name is undefined.</pre></div>
<div class="skip"><span class="num"><pre>222</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>223</pre></span><pre>		:raise ValueError: if value is not a part of our enumeration&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>224</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>225</pre></span><pre>			return self._valueMap[value]</pre></div>
<div class="cov"><span class="num"><pre>226</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>227</pre></span><pre>			raise ValueError(&quot;Value %r is not a member of this enumeration&quot; % value)</pre></div>
<div class="skip"><span class="num"><pre>228</pre></span><pre>		# END exception handling  </pre></div>
<div class="skip"><span class="num"><pre>229</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>230</pre></span><pre>	def _nextOrPrevious( self, element, direction, wrap_around ):</pre></div>
<div class="cov"><span class="num"><pre>231</pre></span><pre>		&quot;&quot;&quot;do-it method, see `next` and `previous`</pre></div>
<div class="skip"><span class="num"><pre>232</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>233</pre></span><pre>		:param direction: -1 = previous, 1 = next &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>234</pre></span><pre>		curindex = -1</pre></div>
<div class="cov"><span class="num"><pre>235</pre></span><pre>		for i,elm in enumerate( self ):</pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>			if elm == element:</pre></div>
<div class="cov"><span class="num"><pre>237</pre></span><pre>				curindex = i</pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>				break</pre></div>
<div class="skip"><span class="num"><pre>239</pre></span><pre>			# END if elms match</pre></div>
<div class="skip"><span class="num"><pre>240</pre></span><pre>		# END for each element</pre></div>
<div class="skip"><span class="num"><pre>241</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>		assert curindex != -1</pre></div>
<div class="skip"><span class="num"><pre>243</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>		nextindex = curindex + direction</pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>		validnextindex = nextindex</pre></div>
<div class="skip"><span class="num"><pre>246</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>247</pre></span><pre>		if nextindex &gt;= len( self ):</pre></div>
<div class="cov"><span class="num"><pre>248</pre></span><pre>			validnextindex = 0</pre></div>
<div class="cov"><span class="num"><pre>249</pre></span><pre>		elif nextindex &lt; 0:</pre></div>
<div class="cov"><span class="num"><pre>250</pre></span><pre>			validnextindex = len( self ) - 1</pre></div>
<div class="skip"><span class="num"><pre>251</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>252</pre></span><pre>		if not wrap_around and ( validnextindex != nextindex ):</pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>			raise ValueError( &quot;'%s' has no element in direction %i&quot; % ( element, direction ) )</pre></div>
<div class="skip"><span class="num"><pre>254</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>		return self[ validnextindex ]</pre></div>
<div class="skip"><span class="num"><pre>256</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>257</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>258</pre></span><pre>	def next( self, element, wrap_around = False ):</pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>		&quot;&quot;&quot;:return: element following after given element</pre></div>
<div class="cov"><span class="num"><pre>260</pre></span><pre>		:param element: element whose successor to return</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>		:param wrap_around: if True, the first Element will be returned if there is</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>			no next element</pre></div>
<div class="cov"><span class="num"><pre>263</pre></span><pre>		:raise ValueError: if wrap_around is False and there is no next element&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>264</pre></span><pre>		return self._nextOrPrevious( element, 1, wrap_around )</pre></div>
<div class="skip"><span class="num"><pre>265</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>266</pre></span><pre>	def previous( self, element, wrap_around = False ):</pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>		&quot;&quot;&quot;:return: element coming before the given element</pre></div>
<div class="cov"><span class="num"><pre>268</pre></span><pre>		:param element: element whose predecessor to return</pre></div>
<div class="cov"><span class="num"><pre>269</pre></span><pre>		:param wrap_around: see `next`</pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>		:raise ValueError: if wrap_around is False and there is no previous element&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>		return self._nextOrPrevious( element, -1, wrap_around )</pre></div>
<div class="skip"><span class="num"><pre>272</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>	__call__ = valueFromName</pre></div>
<div class="skip"><span class="num"><pre>274</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>276</pre></span><pre>def create(*elements, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>277</pre></span><pre>	&quot;&quot;&quot;Factory method for Enumerations. Accepts of list of values that</pre></div>
<div class="cov"><span class="num"><pre>278</pre></span><pre>	can either be strings or (name, value) tuple pairs. Strings will</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>	have an Element created for use as their value.</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>	If you provide elements, the member returned when you access the enumeration</pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>	will be the element itself.</pre></div>
<div class="skip"><span class="num"><pre>282</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>	Example:  Enumeration.create('fred', 'bob', ('joe', 42))</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>	Example:  Enumeration.create('fred', cls = EnumerationSubClass )</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>	Example:  Enumeration.create(Element('fred', Marge), ...)</pre></div>
<div class="skip"><span class="num"><pre>286</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>287</pre></span><pre>	:param kwargs: </pre></div>
<div class="cov"><span class="num"><pre>288</pre></span><pre>		 * cls: The class to create an enumeration with, must be an instance of Enumeration</pre></div>
<div class="cov"><span class="num"><pre>289</pre></span><pre>		 * elmcls: The class to create elements from, must be instance of Element</pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>		 * bitflag: if True, default False, the values created will be suitable as bitflags.</pre></div>
<div class="cov"><span class="num"><pre>291</pre></span><pre>					This will fail if you passed more items in than supported by the OS ( 32 , 64, etc ) or if</pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>					you pass in tuples and thus define the values yourself.</pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>	:raise TypeError,ValueError: if bitflags cannot be supported in your case&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>	cls = kwargs.pop( &quot;cls&quot;, Enumeration )</pre></div>
<div class="cov"><span class="num"><pre>295</pre></span><pre>	elmcls = kwargs.pop( &quot;elmcls&quot;, Element )</pre></div>
<div class="cov"><span class="num"><pre>296</pre></span><pre>	bitflag = kwargs.pop( &quot;bitflag&quot;, False )</pre></div>
<div class="skip"><span class="num"><pre>297</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>298</pre></span><pre>	assert elements</pre></div>
<div class="cov"><span class="num"><pre>299</pre></span><pre>	assert Enumeration in cls.mro()</pre></div>
<div class="cov"><span class="num"><pre>300</pre></span><pre>	assert Element in elmcls.mro()</pre></div>
<div class="skip"><span class="num"><pre>301</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>302</pre></span><pre>	# check range</pre></div>
<div class="cov"><span class="num"><pre>303</pre></span><pre>	if bitflag:</pre></div>
<div class="cov"><span class="num"><pre>304</pre></span><pre>		maxbits = int( platform.architecture()[0][:-3] )</pre></div>
<div class="cov"><span class="num"><pre>305</pre></span><pre>		if maxbits &lt; len( elements ):</pre></div>
<div class="cov"><span class="num"><pre>306</pre></span><pre>			raise ValueError( &quot;You system can only represent %i bits in one integer, %i tried&quot; % ( maxbits, len( elements ) ) )</pre></div>
<div class="skip"><span class="num"><pre>307</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>308</pre></span><pre>		# prepare enum args</pre></div>
<div class="cov"><span class="num"><pre>309</pre></span><pre>		kwargs[ '_is_bitflag' ] = True</pre></div>
<div class="skip"><span class="num"><pre>310</pre></span><pre>	# END bitflag assertion</pre></div>
<div class="skip"><span class="num"><pre>311</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>312</pre></span><pre>	names = list()</pre></div>
<div class="cov"><span class="num"><pre>313</pre></span><pre>	values = list()</pre></div>
<div class="skip"><span class="num"><pre>314</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>	for element in elements:</pre></div>
<div class="skip"><span class="num"><pre>316</pre></span><pre>		# we explicitly check this per element !</pre></div>
<div class="cov"><span class="num"><pre>317</pre></span><pre>		if isinstance( element, tuple ):</pre></div>
<div class="cov"><span class="num"><pre>318</pre></span><pre>			assert len(element) == 2</pre></div>
<div class="cov"><span class="num"><pre>319</pre></span><pre>			if bitflag:</pre></div>
<div class="cov"><span class="num"><pre>320</pre></span><pre>				raise TypeError( &quot;If bitflag support is required, tuples are not allowed: %s&quot; % str( element ) )</pre></div>
<div class="skip"><span class="num"><pre>321</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>322</pre></span><pre>			names.append(element[0])</pre></div>
<div class="cov"><span class="num"><pre>323</pre></span><pre>			values.append(element[1])</pre></div>
<div class="skip"><span class="num"><pre>324</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>325</pre></span><pre>		elif isinstance( element, basestring ):</pre></div>
<div class="cov"><span class="num"><pre>326</pre></span><pre>			val = len( names )</pre></div>
<div class="cov"><span class="num"><pre>327</pre></span><pre>			if bitflag:</pre></div>
<div class="cov"><span class="num"><pre>328</pre></span><pre>				val = 2 ** val</pre></div>
<div class="skip"><span class="num"><pre>329</pre></span><pre>			# END bitflag value generation</pre></div>
<div class="cov"><span class="num"><pre>330</pre></span><pre>			values.append( elmcls( element, val ) )		# zero based ids</pre></div>
<div class="cov"><span class="num"><pre>331</pre></span><pre>			names.append(element)</pre></div>
<div class="cov"><span class="num"><pre>332</pre></span><pre>		elif isinstance(element, elmcls):</pre></div>
<div class="cov"><span class="num"><pre>333</pre></span><pre>			values.append(element)</pre></div>
<div class="cov"><span class="num"><pre>334</pre></span><pre>			names.append(element.name())</pre></div>
<div class="nocov"><span class="num"><pre>335</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>336</pre></span><pre>			raise &quot;Unsupported element type: %s&quot; % type( element )</pre></div>
<div class="skip"><span class="num"><pre>337</pre></span><pre>	# END for each element</pre></div>
<div class="skip"><span class="num"><pre>338</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>339</pre></span><pre>	return cls( names, values, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>340</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>341</pre></span><pre></pre></div>
</div>
</body>
</html>
