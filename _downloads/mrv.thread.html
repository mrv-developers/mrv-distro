<html>
<head>
<title>mrv.thread</title>
</head>
<body>
mrv.thread
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 114 lines<br/>
Missed: 46 lines<br/>
Skipped 60 lines<br/>
Percent: 71 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;Module with threading utilities&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>import threading</pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>import inspect</pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>import Queue</pre></div>
<div class="skip"><span class="num"><pre>  7</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  8</pre></span><pre>#{ Decorators</pre></div>
<div class="skip"><span class="num"><pre>  9</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>def do_terminate_threads(whitelist=list()):</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>	&quot;&quot;&quot;Simple function which terminates all of our threads</pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>	:param whitelist: If whitelist is given, only the given threads will be terminated&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>	for t in threading.enumerate():</pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>		if not isinstance(t, TerminatableThread):</pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>			continue</pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>		if whitelist and t not in whitelist:</pre></div>
<div class="nocov"><span class="num"><pre> 17</pre></span><pre>			continue</pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>		t.schedule_termination()</pre></div>
<div class="cov"><span class="num"><pre> 19</pre></span><pre>		if isinstance(t, WorkerThread):</pre></div>
<div class="cov"><span class="num"><pre> 20</pre></span><pre>			t.inq.put(t.quit)</pre></div>
<div class="skip"><span class="num"><pre> 21</pre></span><pre>		# END worker special handling</pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>		t.stop_and_join()</pre></div>
<div class="skip"><span class="num"><pre> 23</pre></span><pre>	# END for each thread</pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>def terminate_threads( func ):</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>	&quot;&quot;&quot;Kills all worker threads the method has created by sending the quit signal.</pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>	This takes over in case of an error in the main function&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>	def wrapper(*args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>		cur_threads = set(threading.enumerate())</pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>			return func(*args, **kwargs)</pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>		finally:</pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>			do_terminate_threads(set(threading.enumerate()) - cur_threads)</pre></div>
<div class="skip"><span class="num"><pre> 34</pre></span><pre>		# END finally shutdown threads</pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre>	# END wrapper </pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>	wrapper.__name__ = func.__name__</pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>	return wrapper</pre></div>
<div class="skip"><span class="num"><pre> 38</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 39</pre></span><pre>#} END decorators</pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 41</pre></span><pre>#{ Classes</pre></div>
<div class="skip"><span class="num"><pre> 42</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>class TerminatableThread(threading.Thread):</pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>	&quot;&quot;&quot;A simple thread able to terminate itself on behalf of the user.</pre></div>
<div class="skip"><span class="num"><pre> 45</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 46</pre></span><pre>	Terminate a thread as follows:</pre></div>
<div class="skip"><span class="num"><pre> 47</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>	t.stop_and_join()</pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>	Derived classes call _should_terminate() to determine whether they should </pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>	abort gracefully</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>	__slots__ = '_terminate'</pre></div>
<div class="skip"><span class="num"><pre> 54</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>	def __init__(self, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>		super(TerminatableThread, self).__init__(*args, **kwargs)</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>		self._terminate = False</pre></div>
<div class="skip"><span class="num"><pre> 58</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 59</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 60</pre></span><pre>	#{ Subclass Interface</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>	def _should_terminate(self):</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>		&quot;&quot;&quot;:return: True if this thread should terminate its operation immediately&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>		return self._terminate</pre></div>
<div class="skip"><span class="num"><pre> 64</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>	def _terminated(self):</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>		&quot;&quot;&quot;Called once the thread terminated. Its called in the main thread</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>		and may perform cleanup operations</pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>		:note: in the current implementation, this method will only be called if </pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>			the thread was stopped by ``stop_and_join``. If you have very important</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>			cleanup to do, you should do it before you exit your run method&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>		pass</pre></div>
<div class="skip"><span class="num"><pre> 72</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 73</pre></span><pre>	def start(self):</pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>		&quot;&quot;&quot;Start the thread and return self&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>		super(TerminatableThread, self).start()</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre> 77</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 78</pre></span><pre>	#} END subclass interface</pre></div>
<div class="skip"><span class="num"><pre> 79</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 80</pre></span><pre>	#{ Interface </pre></div>
<div class="skip"><span class="num"><pre> 81</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 82</pre></span><pre>	def schedule_termination(self):</pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>		&quot;&quot;&quot;Schedule this thread to be terminated as soon as possible.</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>		:note: this method does not block.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>		self._terminate = True</pre></div>
<div class="skip"><span class="num"><pre> 86</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	def stop_and_join(self):</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>		&quot;&quot;&quot;Ask the thread to stop its operation and wait for it to terminate</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>		:note: Depending on the implenetation, this might block a moment&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 90</pre></span><pre>		self._terminate = True</pre></div>
<div class="nocov"><span class="num"><pre> 91</pre></span><pre>		self.join()</pre></div>
<div class="nocov"><span class="num"><pre> 92</pre></span><pre>		self._terminated()</pre></div>
<div class="skip"><span class="num"><pre> 93</pre></span><pre>	#} END interface</pre></div>
<div class="skip"><span class="num"><pre> 94</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 95</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>class WorkerThread(TerminatableThread):</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>	This base allows to call functions on class instances natively and retrieve</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>	their results asynchronously using a queue.</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>	The thread runs forever unless it receives the terminate signal using </pre></div>
<div class="cov"><span class="num"><pre>101</pre></span><pre>	its task queue.</pre></div>
<div class="skip"><span class="num"><pre>102</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>	Tasks could be anything, but should usually be class methods and arguments to</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>	allow the following:</pre></div>
<div class="skip"><span class="num"><pre>105</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>	inq = Queue()</pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>	outq = Queue()</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>	w = WorkerThread(inq, outq)</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>	w.start()</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>	inq.put((WorkerThread.&lt;method&gt;, args, kwargs))</pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>	res = outq.get()</pre></div>
<div class="skip"><span class="num"><pre>112</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>	finally we call quit to terminate asap.</pre></div>
<div class="skip"><span class="num"><pre>114</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>	alternatively, you can make a call more intuitively - the output is the output queue</pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>	allowing you to get the result right away or later</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>	w.call(arg, kwarg='value').get()</pre></div>
<div class="skip"><span class="num"><pre>118</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>	inq.put(WorkerThread.quit)</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>	w.join()</pre></div>
<div class="skip"><span class="num"><pre>121</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>	You may provide the following tuples as task:</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>	t[0] = class method, function or instance method</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>	t[1] = optional, tuple or list of arguments to pass to the routine</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>	t[2] = optional, dictionary of keyword arguments to pass to the routine</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>127</pre></span><pre>	__slots__ = ('inq', 'outq')</pre></div>
<div class="skip"><span class="num"><pre>128</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>	class InvalidRoutineError(Exception):</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>		&quot;&quot;&quot;Class sent as return value in case of an error&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>131</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>	def __init__(self, inq = None, outq = None):</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>		super(WorkerThread, self).__init__()</pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>		self.inq = inq or Queue.Queue()</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>		self.outq = outq or Queue.Queue()</pre></div>
<div class="skip"><span class="num"><pre>136</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>	def call(self, function, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>		&quot;&quot;&quot;Method that makes the call to the worker using the input queue, </pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>		returning our output queue</pre></div>
<div class="skip"><span class="num"><pre>140</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>		:param funciton: can be a standalone function unrelated to this class, </pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>			a class method of this class or any instance method.</pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>			If it is a string, it will be considered a function residing on this instance</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>		:param args: arguments to pass to function</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>		:parma **kwargs: kwargs to pass to function&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>		self.inq.put((function, args, kwargs))</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>		return self.outq</pre></div>
<div class="skip"><span class="num"><pre>148</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>	def wait_until_idle(self):</pre></div>
<div class="cov"><span class="num"><pre>150</pre></span><pre>		&quot;&quot;&quot;wait until the input queue is empty, in the meanwhile, take all </pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>		results off the output queue.&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>152</pre></span><pre>		while not self.inq.empty():</pre></div>
<div class="nocov"><span class="num"><pre>153</pre></span><pre>			try:</pre></div>
<div class="nocov"><span class="num"><pre>154</pre></span><pre>				self.outq.get(False)</pre></div>
<div class="nocov"><span class="num"><pre>155</pre></span><pre>			except Queue.Empty:</pre></div>
<div class="nocov"><span class="num"><pre>156</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>157</pre></span><pre>		# END while there are tasks on the queue</pre></div>
<div class="skip"><span class="num"><pre>158</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>	def stop_and_join(self):</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>		&quot;&quot;&quot;Send the stop signal to terminate, then join&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>		self._terminate = True</pre></div>
<div class="cov"><span class="num"><pre>162</pre></span><pre>		self.inq.put(self.quit)</pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>		self.join()</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>		self._terminated()</pre></div>
<div class="skip"><span class="num"><pre>165</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>166</pre></span><pre>	def run(self):</pre></div>
<div class="cov"><span class="num"><pre>167</pre></span><pre>		&quot;&quot;&quot;Process input tasks until we receive the quit signal&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>168</pre></span><pre>		while True:</pre></div>
<div class="nocov"><span class="num"><pre>169</pre></span><pre>			if self._should_terminate():</pre></div>
<div class="nocov"><span class="num"><pre>170</pre></span><pre>				break</pre></div>
<div class="skip"><span class="num"><pre>171</pre></span><pre>			# END check for stop request</pre></div>
<div class="nocov"><span class="num"><pre>172</pre></span><pre>			routine = self.__class__.quit</pre></div>
<div class="nocov"><span class="num"><pre>173</pre></span><pre>			args = tuple()</pre></div>
<div class="nocov"><span class="num"><pre>174</pre></span><pre>			kwargs = dict()</pre></div>
<div class="nocov"><span class="num"><pre>175</pre></span><pre>			tasktuple = self.inq.get()</pre></div>
<div class="skip"><span class="num"><pre>176</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>177</pre></span><pre>			if isinstance(tasktuple, (tuple, list)):</pre></div>
<div class="nocov"><span class="num"><pre>178</pre></span><pre>				if len(tasktuple) == 3:</pre></div>
<div class="nocov"><span class="num"><pre>179</pre></span><pre>					routine, args, kwargs = tasktuple</pre></div>
<div class="nocov"><span class="num"><pre>180</pre></span><pre>				elif len(tasktuple) == 2:</pre></div>
<div class="nocov"><span class="num"><pre>181</pre></span><pre>					routine, args = tasktuple</pre></div>
<div class="nocov"><span class="num"><pre>182</pre></span><pre>				elif len(tasktuple) == 1:</pre></div>
<div class="nocov"><span class="num"><pre>183</pre></span><pre>					routine = tasktuple[0]</pre></div>
<div class="skip"><span class="num"><pre>184</pre></span><pre>				# END tasktuple length check</pre></div>
<div class="nocov"><span class="num"><pre>185</pre></span><pre>			elif inspect.isroutine(tasktuple):</pre></div>
<div class="nocov"><span class="num"><pre>186</pre></span><pre>				routine = tasktuple</pre></div>
<div class="skip"><span class="num"><pre>187</pre></span><pre>			# END tasktuple handling</pre></div>
<div class="skip"><span class="num"><pre>188</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>189</pre></span><pre>			try:</pre></div>
<div class="nocov"><span class="num"><pre>190</pre></span><pre>				rval = None</pre></div>
<div class="nocov"><span class="num"><pre>191</pre></span><pre>				if inspect.ismethod(routine):</pre></div>
<div class="nocov"><span class="num"><pre>192</pre></span><pre>					if routine.im_self is None:</pre></div>
<div class="nocov"><span class="num"><pre>193</pre></span><pre>						rval = routine(self, *args, **kwargs)</pre></div>
<div class="nocov"><span class="num"><pre>194</pre></span><pre>					else:</pre></div>
<div class="nocov"><span class="num"><pre>195</pre></span><pre>						rval = routine(*args, **kwargs)</pre></div>
<div class="nocov"><span class="num"><pre>196</pre></span><pre>				elif inspect.isroutine(routine):</pre></div>
<div class="nocov"><span class="num"><pre>197</pre></span><pre>					rval = routine(*args, **kwargs)</pre></div>
<div class="nocov"><span class="num"><pre>198</pre></span><pre>				elif isinstance(routine, basestring) and hasattr(self, routine):</pre></div>
<div class="nocov"><span class="num"><pre>199</pre></span><pre>					rval = getattr(self, routine)(*args, **kwargs)</pre></div>
<div class="nocov"><span class="num"><pre>200</pre></span><pre>				else:</pre></div>
<div class="skip"><span class="num"><pre>201</pre></span><pre>					# ignore unknown items</pre></div>
<div class="nocov"><span class="num"><pre>202</pre></span><pre>					print &quot;%s: task %s was not understood - terminating&quot; % (self.getName(), str(tasktuple))</pre></div>
<div class="nocov"><span class="num"><pre>203</pre></span><pre>					self.outq.put(self.InvalidRoutineError(routine))</pre></div>
<div class="nocov"><span class="num"><pre>204</pre></span><pre>					break</pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre>				# END make routine call</pre></div>
<div class="nocov"><span class="num"><pre>206</pre></span><pre>				self.outq.put(rval)</pre></div>
<div class="nocov"><span class="num"><pre>207</pre></span><pre>			except StopIteration:</pre></div>
<div class="nocov"><span class="num"><pre>208</pre></span><pre>				break</pre></div>
<div class="nocov"><span class="num"><pre>209</pre></span><pre>			except Exception,e:</pre></div>
<div class="nocov"><span class="num"><pre>210</pre></span><pre>				print &quot;%s: Task %s raised unhandled exception: %s&quot; % (self.getName(), str(tasktuple), str(e))</pre></div>
<div class="nocov"><span class="num"><pre>211</pre></span><pre>				self.outq.put(e)</pre></div>
<div class="skip"><span class="num"><pre>212</pre></span><pre>			# END routine exception handling</pre></div>
<div class="skip"><span class="num"><pre>213</pre></span><pre>		# END endless loop</pre></div>
<div class="skip"><span class="num"><pre>214</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>215</pre></span><pre>	def quit(self):</pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>		raise StopIteration</pre></div>
<div class="skip"><span class="num"><pre>217</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>218</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>219</pre></span><pre>#} END classes</pre></div>
<div class="skip"><span class="num"><pre>220</pre></span><pre></pre></div>
</div>
</body>
</html>
