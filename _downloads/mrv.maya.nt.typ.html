<html>
<head>
<title>mrv.maya.nt.typ</title>
</head>
<body>
mrv.maya.nt.typ
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 241 lines<br/>
Missed: 54 lines<br/>
Skipped 196 lines<br/>
Percent: 81 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>Houses the MetaClass able to setup new types to work within the system. This can </pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>be considered the heart of the node wrapping engine, but it plays together with </pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>the implementation in the `base` module.</pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>  8</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>from mrv.maya.util import MetaClassCreator</pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>from mrv.maya.util import MEnumeration</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>import mrv.maya as mrvmaya</pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>import mrv.maya.mdb as mdb</pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>from mrv.util import uncapitalize, capitalize</pre></div>
<div class="skip"><span class="num"><pre> 14</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 15</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>import maya.OpenMaya as api</pre></div>
<div class="skip"><span class="num"><pre> 17</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>from new import instancemethod</pre></div>
<div class="cov"><span class="num"><pre> 19</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre> 20</pre></span><pre>log = logging.getLogger(&quot;mrv.maya.nt.typ&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 21</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>__all__ = (&quot;MetaClassCreatorNodes&quot;, )</pre></div>
<div class="skip"><span class="num"><pre> 23</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre>#{ Caches</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>_nodesdict = None					# to be set during initialization</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>nodeTypeTree = None</pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>nodeTypeToMfnClsMap = dict()		# allows to see the most specialized compatible mfn cls for a given node type</pre></div>
<div class="skip"><span class="num"><pre> 28</pre></span><pre>#} END caches</pre></div>
<div class="skip"><span class="num"><pre> 29</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 30</pre></span><pre>#{Globals</pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>targetModule = None				# must be set in intialization to tell this class where to put newly created classes</pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>mfnclsattr = '_mfncls'</pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>mfndbattr = '_mfndb'</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>apiobjattr = '_apiobj'</pre></div>
<div class="cov"><span class="num"><pre> 35</pre></span><pre>getattrorigname = '__getattr_orig'</pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>codegen = None		# python code generator, to be set during initialization</pre></div>
<div class="skip"><span class="num"><pre> 37</pre></span><pre>#} END globals</pre></div>
<div class="skip"><span class="num"><pre> 38</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 39</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre>#{ Metaclasses</pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>class MetaClassCreatorNodes( MetaClassCreator ):</pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>	&quot;&quot;&quot;Builds the base hierarchy for the given classname based on our typetree</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>	:todo: build classes with slots only as members are pretermined&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 44</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 45</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre> 46</pre></span><pre>	def _fetchMfnDB( cls, newcls, mfncls, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>		&quot;&quot;&quot;Return the mfndb for the given mfncls as existing on newcls. </pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>		If it does not yet exist, it will be created and attached first</pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>		:param kwargs: passed to MMemberMap initializer&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>			return newcls.__dict__[ mfndbattr ]</pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>			mfndbpath = mdb.mfnDBPath(mfncls.__name__)</pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>				mfndb = mdb.MMemberMap(mfndbpath, **kwargs)</pre></div>
<div class="nocov"><span class="num"><pre> 57</pre></span><pre>			except IOError:</pre></div>
<div class="nocov"><span class="num"><pre> 58</pre></span><pre>				print IOError(&quot;Could not create MFnDB for file at %s&quot; % mfndbpath)</pre></div>
<div class="nocov"><span class="num"><pre> 59</pre></span><pre>				raise</pre></div>
<div class="skip"><span class="num"><pre> 60</pre></span><pre>			# END handle mmap reading</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>			type.__setattr__( newcls, mfndbattr, mfndb )</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>			return mfndb</pre></div>
<div class="skip"><span class="num"><pre> 63</pre></span><pre>		# END mfndb handling</pre></div>
<div class="skip"><span class="num"><pre> 64</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>	def _wrapStaticMembers( cls, newcls, mfncls ):</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>		&quot;&quot;&quot;Find static mfnmethods - if these are available, initialize the </pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>		mfn database for the given function set ( ``mfncls`` ) and create properly </pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>		wrapped methods. </pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>		Additionally check for enumerations, and generate the respective enumeration</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>		instances</pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>		:note: As all types are initialized on startup, the staticmethods check </pre></div>
<div class="cov"><span class="num"><pre> 73</pre></span><pre>			will load in quite a few function sets databases as many will have static </pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>			methods. There is no real way around it, but one could introduce 'packs'</pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>			to bundle these together and load them only once. Probably the performance</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>			hit is not noticeable, but lets just say that I am aware of it</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>		:note: Currently method aliases are not implemented for statics !&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 78</pre></span><pre>		fstatic, finst = mdb.extractMFnFunctions(mfncls)</pre></div>
<div class="cov"><span class="num"><pre> 79</pre></span><pre>		hasEnum = mdb.hasMEnumeration(mfncls)</pre></div>
<div class="cov"><span class="num"><pre> 80</pre></span><pre>		if not fstatic and not hasEnum:</pre></div>
<div class="cov"><span class="num"><pre> 81</pre></span><pre>			return</pre></div>
<div class="skip"><span class="num"><pre> 82</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>		mfndb = cls._fetchMfnDB(newcls, mfncls, parse_enums=hasEnum)</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>		if fstatic:</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>			mfnname = mfncls.__name__</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>			for fs in fstatic:</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>				fn = fs.__name__</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>				if fn.startswith(mfnname):</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>					fn = fn[len(mfnname)+1:]	# cut MFnName_methodName</pre></div>
<div class="skip"><span class="num"><pre> 90</pre></span><pre>				# END handle name prefix</pre></div>
<div class="skip"><span class="num"><pre> 91</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>				static_function = cls._wrapMfnFunc(newcls, mfncls, fn, mfndb)</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>				type.__setattr__(newcls, fn, staticmethod(static_function))</pre></div>
<div class="skip"><span class="num"><pre> 94</pre></span><pre>			# END for each static method</pre></div>
<div class="skip"><span class="num"><pre> 95</pre></span><pre>		# END handle static functions</pre></div>
<div class="skip"><span class="num"><pre> 96</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 97</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>		if hasEnum:</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>			for ed in mfndb.enums:</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>				type.__setattr__(newcls, ed.name, MEnumeration.create(ed, mfncls))</pre></div>
<div class="skip"><span class="num"><pre>101</pre></span><pre>			# END for each enum desriptor</pre></div>
<div class="skip"><span class="num"><pre>102</pre></span><pre>		# END handle enumerations</pre></div>
<div class="skip"><span class="num"><pre>103</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>104</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>	def _wrapMfnFunc( cls, newcls, mfncls, funcname, mfndb, addFlags=0 ):</pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>		&quot;&quot;&quot;Create a function that makes a Node natively use its associated Maya</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>		function set on calls.</pre></div>
<div class="skip"><span class="num"><pre>109</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>		The created function will use the api object of the instance of the call to initialize</pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>		a function set of type mfncls and execute the function in question.</pre></div>
<div class="skip"><span class="num"><pre>112</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>		The method mutation database allows to adjust the way a method is being wrapped</pre></div>
<div class="skip"><span class="num"><pre>114</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>		:param mfncls: Maya function set class from which to take the functions</pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>		:param funcname: name of the function set function to be wrapped.</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>		:param mfndb: `mdb.MMemberMap` </pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>		:param addFlags: If set, these flags define how the method will be generated.</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>		:raise KeyError: if the given function does not exist in mfncls</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>		:note: if the called function starts with _api_*, a special accellerated method</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>			will be returned and created allowing direct access to the mfn instance method.</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>			This is unsafe if the same api object is being renamed. Also it will only be faster if</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>			the same method is actually called multiple times. It can be great for speed sensitive code</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>			where where the same method(s) are called repeatedly on the same set of objects</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>		:return:  wrapped function or None if it was deleted&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>		flags = mfndb.flags|addFlags</pre></div>
<div class="cov"><span class="num"><pre>127</pre></span><pre>		funcname_orig = funcname	# store the original for later use</pre></div>
<div class="skip"><span class="num"><pre>128</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>129</pre></span><pre>		# rewrite the function name to use the actual one</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>		if funcname.startswith( &quot;_api_&quot; ):</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>			flags |= mdb.PythonMFnCodeGenerator.kDirectCall</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>			funcname = funcname[ len( &quot;_api_&quot; ) : ]</pre></div>
<div class="skip"><span class="num"><pre>133</pre></span><pre>		# END is special api function is requested</pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>		mfnfuncname = funcname		# method could be remapped - if so we need to lookup the real name</pre></div>
<div class="skip"><span class="num"><pre>135</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>136</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>		method_descriptor = None</pre></div>
<div class="skip"><span class="num"><pre>138</pre></span><pre>		# adjust function according to DB</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>			mfnfuncname, method_descriptor = mfndb.methodByName( funcname )</pre></div>
<div class="skip"><span class="num"><pre>141</pre></span><pre>			# delete function ?</pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>			if method_descriptor.flag == mdb.MMemberMap.kDelete:</pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>				return None</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>		except KeyError:</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>			pass # could just be working</pre></div>
<div class="skip"><span class="num"><pre>146</pre></span><pre>		# END if entry available</pre></div>
<div class="skip"><span class="num"><pre>147</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>		if method_descriptor is None:</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>			method_descriptor = mdb.MMethodDescriptor()</pre></div>
<div class="skip"><span class="num"><pre>150</pre></span><pre>		# END assure method descriptor is set</pre></div>
<div class="skip"><span class="num"><pre>151</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>152</pre></span><pre>		# access it directly from the class, ignoring inheritance. If the class</pre></div>
<div class="skip"><span class="num"><pre>153</pre></span><pre>		# would have overridden the function, we would get it. If it does not do that, </pre></div>
<div class="skip"><span class="num"><pre>154</pre></span><pre>		# we will end up with the first superclass implementing it. </pre></div>
<div class="skip"><span class="num"><pre>155</pre></span><pre>		# This is what we want as more specialized Function sets will do more checks</pre></div>
<div class="skip"><span class="num"><pre>156</pre></span><pre>		# hence will be slower to create. Also in case of geometry, the python api </pre></div>
<div class="skip"><span class="num"><pre>157</pre></span><pre>		# is a real bitch with empty shapes on which it does not want to operate at all</pre></div>
<div class="skip"><span class="num"><pre>158</pre></span><pre>		# as opposed to behaviour of the API.</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>		mfnfunc = mfncls.__dict__[ mfnfuncname ]			# will just raise on error</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>		if isinstance(mfnfunc, staticmethod):</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>			flags |= mdb.PythonMFnCodeGenerator.kIsStatic</pre></div>
<div class="skip"><span class="num"><pre>162</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>163</pre></span><pre>			# convert static method to real method</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>			mfnfunc = type.__getattribute__(mfncls, mfnfuncname)</pre></div>
<div class="skip"><span class="num"><pre>165</pre></span><pre>		# END handle </pre></div>
<div class="skip"><span class="num"><pre>166</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>167</pre></span><pre>		# finish compile flags</pre></div>
<div class="cov"><span class="num"><pre>168</pre></span><pre>		if api.MFnDagNode in mfncls.mro():</pre></div>
<div class="cov"><span class="num"><pre>169</pre></span><pre>			flags |= mdb.PythonMFnCodeGenerator.kIsDagNode</pre></div>
<div class="cov"><span class="num"><pre>170</pre></span><pre>		if api.MObject in newcls.mro():</pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>			flags |= mdb.PythonMFnCodeGenerator.kIsMObject</pre></div>
<div class="skip"><span class="num"><pre>172</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>173</pre></span><pre>		# could be cached, but we need to wait until the dict is initialized, </pre></div>
<div class="skip"><span class="num"><pre>174</pre></span><pre>		# TODO: To be done in __init__ together with the nodedict</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>		newfunc = codegen.generateMFnClsMethodWrapperMethod(funcname_orig, funcname, mfncls, mfnfunc, method_descriptor, flags)</pre></div>
<div class="skip"><span class="num"><pre>176</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>		if not flags &amp; mdb.PythonMFnCodeGenerator.kIsStatic: </pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>			newfunc.__name__ = funcname			# rename the method</pre></div>
<div class="skip"><span class="num"><pre>179</pre></span><pre>		# END handle renames</pre></div>
<div class="cov"><span class="num"><pre>180</pre></span><pre>		return newfunc</pre></div>
<div class="skip"><span class="num"><pre>181</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>182</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>183</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>	def _wrapLazyGetAttr( thiscls, newcls ):</pre></div>
<div class="cov"><span class="num"><pre>185</pre></span><pre>		&quot;&quot;&quot; Attach the lazy getattr wrapper to newcls &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>186</pre></span><pre>		# keep the original getattr</pre></div>
<div class="cov"><span class="num"><pre>187</pre></span><pre>		if hasattr( newcls, '__getattr__' ):</pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>			getattrorig =  newcls.__dict__.get( '__getattr__', None )</pre></div>
<div class="cov"><span class="num"><pre>189</pre></span><pre>			if getattrorig:</pre></div>
<div class="cov"><span class="num"><pre>190</pre></span><pre>				getattrorig.__name__ = getattrorigname</pre></div>
<div class="cov"><span class="num"><pre>191</pre></span><pre>				setattr( newcls, getattrorigname, getattrorig )</pre></div>
<div class="skip"><span class="num"><pre>192</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre>		# CREATE GET ATTR CUSTOM FUNC</pre></div>
<div class="skip"><span class="num"><pre>194</pre></span><pre>		# called if the given attribute is not available in class</pre></div>
<div class="cov"><span class="num"><pre>195</pre></span><pre>		def meta_getattr_lazy( self, attr ):</pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>			actualcls = None										# the class finally used to store located functions</pre></div>
<div class="skip"><span class="num"><pre>197</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>198</pre></span><pre>			# MFN ATTRTIBUTE HANDLING</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre>			############################</pre></div>
<div class="skip"><span class="num"><pre>200</pre></span><pre>			# check all bases for and their mfncls for a suitable function</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>			newclsfunc = newinstfunc = None							# try to fill these</pre></div>
<div class="cov"><span class="num"><pre>202</pre></span><pre>			for basecls in newcls.mro():</pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>				if not hasattr( basecls, mfnclsattr ):			# could be object too or user defined cls</pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>206</pre></span><pre>				mfncls = getattr( basecls, mfnclsattr )</pre></div>
<div class="cov"><span class="num"><pre>207</pre></span><pre>				if not mfncls:</pre></div>
<div class="nocov"><span class="num"><pre>208</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>209</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>210</pre></span><pre>				# get function as well as its possibly changed name</pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>				try:</pre></div>
<div class="cov"><span class="num"><pre>212</pre></span><pre>					mfndb = thiscls._fetchMfnDB(basecls, mfncls)</pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>					newclsfunc = thiscls._wrapMfnFunc( newcls, mfncls, attr, mfndb )</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>					if not newclsfunc: # Function %s has been deleted - ignore</pre></div>
<div class="cov"><span class="num"><pre>215</pre></span><pre>						continue</pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>				except KeyError:  		# function not available in this mfn - ignore</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>					continue</pre></div>
<div class="cov"><span class="num"><pre>218</pre></span><pre>				newinstfunc = instancemethod( newclsfunc, self, basecls )	# create the respective instance method !</pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>				actualcls = basecls</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>				break					# stop here - we found it</pre></div>
<div class="skip"><span class="num"><pre>221</pre></span><pre>			# END for each basecls ( searching for mfn func )</pre></div>
<div class="skip"><span class="num"><pre>222</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>223</pre></span><pre>			# STORE MFN FUNC ( if available )</pre></div>
<div class="skip"><span class="num"><pre>224</pre></span><pre>			# store the new function on instance level !</pre></div>
<div class="skip"><span class="num"><pre>225</pre></span><pre>			# ... and on class level</pre></div>
<div class="cov"><span class="num"><pre>226</pre></span><pre>			if newclsfunc:</pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>				# assure we do not call overwridden functions</pre></div>
<div class="cov"><span class="num"><pre>228</pre></span><pre>				object.__setattr__( self, attr, newinstfunc )</pre></div>
<div class="cov"><span class="num"><pre>229</pre></span><pre>				type.__setattr__( actualcls, attr, newclsfunc )		# setattr would do too, but its more dramatic this way :)</pre></div>
<div class="cov"><span class="num"><pre>230</pre></span><pre>				return newinstfunc</pre></div>
<div class="skip"><span class="num"><pre>231</pre></span><pre>			# END newclsfunc exists</pre></div>
<div class="skip"><span class="num"><pre>232</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>233</pre></span><pre>			# ORIGINAL ATTRIBUTE HANDLING</pre></div>
<div class="skip"><span class="num"><pre>234</pre></span><pre>			###############################</pre></div>
<div class="skip"><span class="num"><pre>235</pre></span><pre>			# still no funcion ? Continue with non-mfn search routine )</pre></div>
<div class="skip"><span class="num"><pre>236</pre></span><pre>			# try to find orignal getattrs in our base classes - if we have overwritten</pre></div>
<div class="skip"><span class="num"><pre>237</pre></span><pre>			# them we find them under a backup attribute, otherwise we check the name of the</pre></div>
<div class="skip"><span class="num"><pre>238</pre></span><pre>			# original method for our lazy tag ( we never want to call our own counterpart on a</pre></div>
<div class="skip"><span class="num"><pre>239</pre></span><pre>			# base class</pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>			getattrorigfunc = None</pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>			for basecls in newcls.mro():</pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>				if hasattr( basecls, getattrorigname ):</pre></div>
<div class="cov"><span class="num"><pre>243</pre></span><pre>					getattrorigfunc = getattr( basecls, getattrorigname )</pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>					break</pre></div>
<div class="skip"><span class="num"><pre>245</pre></span><pre>				# END orig getattr method check</pre></div>
<div class="skip"><span class="num"><pre>246</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>247</pre></span><pre>				# check if the getattr function itself is us or not</pre></div>
<div class="nocov"><span class="num"><pre>248</pre></span><pre>				if hasattr( basecls, '__getattr__' ):</pre></div>
<div class="nocov"><span class="num"><pre>249</pre></span><pre>					getattrfunc = getattr( basecls, '__getattr__' )</pre></div>
<div class="nocov"><span class="num"><pre>250</pre></span><pre>					if getattrfunc.func_name != &quot;meta_getattr_lazy&quot;:</pre></div>
<div class="nocov"><span class="num"><pre>251</pre></span><pre>						getattrorigfunc = getattrfunc</pre></div>
<div class="nocov"><span class="num"><pre>252</pre></span><pre>						break</pre></div>
<div class="skip"><span class="num"><pre>253</pre></span><pre>				# END default getattr method check</pre></div>
<div class="skip"><span class="num"><pre>254</pre></span><pre>			# END for each base ( searching for getattr_orig or nonoverwritten getattr )</pre></div>
<div class="skip"><span class="num"><pre>255</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>256</pre></span><pre>			if not getattrorigfunc:</pre></div>
<div class="nocov"><span class="num"><pre>257</pre></span><pre>				raise AttributeError( &quot;Could not find mfn function for attribute '%s'&quot; % attr )</pre></div>
<div class="skip"><span class="num"><pre>258</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>259</pre></span><pre>			# pass on the call - if this method produces an output, its responsible for caching</pre></div>
<div class="skip"><span class="num"><pre>260</pre></span><pre>			# it in the instance dict</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>			return getattrorigfunc( self, attr )</pre></div>
<div class="skip"><span class="num"><pre>262</pre></span><pre>			# EMD orig getattr handling</pre></div>
<div class="skip"><span class="num"><pre>263</pre></span><pre>		# END getattr_lazy func definition</pre></div>
<div class="skip"><span class="num"><pre>264</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>265</pre></span><pre>		# STORE LAZY GETATTR</pre></div>
<div class="skip"><span class="num"><pre>266</pre></span><pre>		# identification !</pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>		setattr( newcls, &quot;__getattr__&quot;, meta_getattr_lazy )</pre></div>
<div class="skip"><span class="num"><pre>268</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>269</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>	def __new__( metacls, name, bases, clsdict ):</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>		&quot;&quot;&quot; Called to create the class with name &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>272</pre></span><pre>		# will be used later</pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>		def func_nameToTree( name ):</pre></div>
<div class="skip"><span class="num"><pre>274</pre></span><pre>			# first check whether an uncapitalized name is known, if not, check </pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre>			# the capitalized version ( for special cases ), finalyl return</pre></div>
<div class="skip"><span class="num"><pre>276</pre></span><pre>			# the uncapitalized version which is the default</pre></div>
<div class="cov"><span class="num"><pre>277</pre></span><pre>			name = uncapitalize(name)</pre></div>
<div class="cov"><span class="num"><pre>278</pre></span><pre>			if nodeTypeTree.has_node(name):</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>				return name</pre></div>
<div class="skip"><span class="num"><pre>280</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>			capname = capitalize(name)</pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>			if nodeTypeTree.has_node(capname):</pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>				return capname</pre></div>
<div class="skip"><span class="num"><pre>284</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>			return name</pre></div>
<div class="skip"><span class="num"><pre>286</pre></span><pre>		# END utility</pre></div>
<div class="skip"><span class="num"><pre>287</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>288</pre></span><pre>		# ATTACH MFNCLS</pre></div>
<div class="skip"><span class="num"><pre>289</pre></span><pre>		#################</pre></div>
<div class="skip"><span class="num"><pre>290</pre></span><pre>		# ask our NodeType to MfnSet database and attach it to the cls dict</pre></div>
<div class="skip"><span class="num"><pre>291</pre></span><pre>		# ( if not yet there ). By convention, there is only one mfn per class</pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>		mfncls = None</pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>		needs_static_method_initialization = False</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>		if not clsdict.has_key( mfnclsattr ):</pre></div>
<div class="cov"><span class="num"><pre>295</pre></span><pre>			treeNodeTypeName = func_nameToTree( name )</pre></div>
<div class="cov"><span class="num"><pre>296</pre></span><pre>			if nodeTypeToMfnClsMap.has_key( treeNodeTypeName ):</pre></div>
<div class="cov"><span class="num"><pre>297</pre></span><pre>				mfncls = nodeTypeToMfnClsMap[ treeNodeTypeName ]</pre></div>
<div class="cov"><span class="num"><pre>298</pre></span><pre>				clsdict[ mfnclsattr ] = mfncls</pre></div>
<div class="skip"><span class="num"><pre>299</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>300</pre></span><pre>				# attach static mfn methods directly.</pre></div>
<div class="cov"><span class="num"><pre>301</pre></span><pre>				needs_static_method_initialization = True</pre></div>
<div class="skip"><span class="num"><pre>302</pre></span><pre>			# END attach mfncls to type</pre></div>
<div class="nocov"><span class="num"><pre>303</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>304</pre></span><pre>			mfncls = clsdict[ mfnclsattr ]</pre></div>
<div class="skip"><span class="num"><pre>305</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>306</pre></span><pre>		# do not store any mfn if there is none set - this would override mfns of</pre></div>
<div class="skip"><span class="num"><pre>307</pre></span><pre>		# base classes although the super class is compatible to it</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>		if mfncls:</pre></div>
<div class="cov"><span class="num"><pre>309</pre></span><pre>			clsdict[ mfnclsattr ] = mfncls			# we have at least a None mfn</pre></div>
<div class="cov"><span class="num"><pre>310</pre></span><pre>		clsdict[ apiobjattr ] = None			# always have an api obj</pre></div>
<div class="skip"><span class="num"><pre>311</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>312</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>313</pre></span><pre>		# CREATE CLS</pre></div>
<div class="skip"><span class="num"><pre>314</pre></span><pre>		#################</pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>		newcls = super( MetaClassCreatorNodes, metacls ).__new__( nodeTypeTree, targetModule,</pre></div>
<div class="cov"><span class="num"><pre>316</pre></span><pre>																metacls, name, bases, clsdict,</pre></div>
<div class="cov"><span class="num"><pre>317</pre></span><pre>																nameToTreeFunc = func_nameToTree )</pre></div>
<div class="skip"><span class="num"><pre>318</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>319</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>320</pre></span><pre>		# LAZY MFN WRAPPING</pre></div>
<div class="skip"><span class="num"><pre>321</pre></span><pre>		#####################</pre></div>
<div class="skip"><span class="num"><pre>322</pre></span><pre>		# Functions from mfn should be wrapped on demand to the respective classes as they</pre></div>
<div class="skip"><span class="num"><pre>323</pre></span><pre>		# should be generated only when used</pre></div>
<div class="skip"><span class="num"><pre>324</pre></span><pre>		# Wrap the existing __getattr__ method in an own one linking mfn methods if possible</pre></div>
<div class="skip"><span class="num"><pre>325</pre></span><pre>		# Additionally, precreate static methods</pre></div>
<div class="cov"><span class="num"><pre>326</pre></span><pre>		if mfncls:</pre></div>
<div class="cov"><span class="num"><pre>327</pre></span><pre>			metacls._wrapLazyGetAttr( newcls )</pre></div>
<div class="skip"><span class="num"><pre>328</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>329</pre></span><pre>			if needs_static_method_initialization:</pre></div>
<div class="cov"><span class="num"><pre>330</pre></span><pre>				metacls._wrapStaticMembers(newcls, mfncls)</pre></div>
<div class="skip"><span class="num"><pre>331</pre></span><pre>		# END if mfncls defined</pre></div>
<div class="skip"><span class="num"><pre>332</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>333</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>334</pre></span><pre>		return newcls</pre></div>
<div class="skip"><span class="num"><pre>335</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>336</pre></span><pre>	# END __new__</pre></div>
<div class="skip"><span class="num"><pre>337</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>338</pre></span><pre>#} END metaclasses</pre></div>
<div class="skip"><span class="num"><pre>339</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>340</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>341</pre></span><pre>#{ Utilities</pre></div>
<div class="skip"><span class="num"><pre>342</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>def prefetchMFnMethods():</pre></div>
<div class="cov"><span class="num"><pre>344</pre></span><pre>	&quot;&quot;&quot;Fetch and install all mfn methods on all types supporting a function set.</pre></div>
<div class="cov"><span class="num"><pre>345</pre></span><pre>	This should only be done to help interactive mode, but makes absolutely no </pre></div>
<div class="cov"><span class="num"><pre>346</pre></span><pre>	sense in the default mode of operation when everything is produced on demand.</pre></div>
<div class="skip"><span class="num"><pre>347</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>348</pre></span><pre>	:note: Attaches docstrings as well</pre></div>
<div class="cov"><span class="num"><pre>349</pre></span><pre>	:return: integer representing the number of generated methods&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>350</pre></span><pre>	log.info(&quot;Prefetching all MFnMethods&quot;)</pre></div>
<div class="skip"><span class="num"><pre>351</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>352</pre></span><pre>	num_fetched = 0</pre></div>
<div class="nocov"><span class="num"><pre>353</pre></span><pre>	for typename, mfncls in nodeTypeToMfnClsMap.iteritems():</pre></div>
<div class="nocov"><span class="num"><pre>354</pre></span><pre>		try:</pre></div>
<div class="nocov"><span class="num"><pre>355</pre></span><pre>			nodetype = _nodesdict[capitalize(typename)]</pre></div>
<div class="nocov"><span class="num"><pre>356</pre></span><pre>		except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>357</pre></span><pre>			log.debug(&quot;MFn methods for %s exists, but type was not found in nt&quot; % typename)</pre></div>
<div class="nocov"><span class="num"><pre>358</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre>359</pre></span><pre>		# END handle type exceptions</pre></div>
<div class="skip"><span class="num"><pre>360</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>361</pre></span><pre>		mfnname = mfncls.__name__</pre></div>
<div class="nocov"><span class="num"><pre>362</pre></span><pre>		mfndb = MetaClassCreatorNodes._fetchMfnDB(nodetype, mfncls)</pre></div>
<div class="nocov"><span class="num"><pre>363</pre></span><pre>		fstatic, finst = mdb.extractMFnFunctions(mfncls)</pre></div>
<div class="skip"><span class="num"><pre>364</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>365</pre></span><pre>		def set_method_if_possible(cls, fn, f):</pre></div>
<div class="nocov"><span class="num"><pre>366</pre></span><pre>			if not hasattr(cls, fn):</pre></div>
<div class="nocov"><span class="num"><pre>367</pre></span><pre>				type.__setattr__(cls, fn, f)</pre></div>
<div class="skip"><span class="num"><pre>368</pre></span><pre>			# END overwrite protection</pre></div>
<div class="skip"><span class="num"><pre>369</pre></span><pre>		# END utility </pre></div>
<div class="skip"><span class="num"><pre>370</pre></span><pre>		</pre></div>
<div class="nocov"><span class="num"><pre>371</pre></span><pre>		for f in finst:</pre></div>
<div class="nocov"><span class="num"><pre>372</pre></span><pre>			fn = f.__name__</pre></div>
<div class="nocov"><span class="num"><pre>373</pre></span><pre>			if fn.startswith(mfnname):</pre></div>
<div class="nocov"><span class="num"><pre>374</pre></span><pre>				fn = fn[len(mfnname)+1:]</pre></div>
<div class="skip"><span class="num"><pre>375</pre></span><pre>			# END handle prefixed names</pre></div>
<div class="skip"><span class="num"><pre>376</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>377</pre></span><pre>			fna = fn		# alias for method </pre></div>
<div class="nocov"><span class="num"><pre>378</pre></span><pre>			try:</pre></div>
<div class="nocov"><span class="num"><pre>379</pre></span><pre>				origname, entry = mfndb.methodByName(fn)</pre></div>
<div class="nocov"><span class="num"><pre>380</pre></span><pre>				fna = entry.newname</pre></div>
<div class="nocov"><span class="num"><pre>381</pre></span><pre>			except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>382</pre></span><pre>				pass</pre></div>
<div class="skip"><span class="num"><pre>383</pre></span><pre>			# END get alias metadata</pre></div>
<div class="skip"><span class="num"><pre>384</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>385</pre></span><pre>			fwrapped = MetaClassCreatorNodes._wrapMfnFunc(nodetype, mfncls, fn, mfndb, mdb.PythonMFnCodeGenerator.kWithDocs)</pre></div>
<div class="skip"><span class="num"><pre>386</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>387</pre></span><pre>			# could have been deleted</pre></div>
<div class="nocov"><span class="num"><pre>388</pre></span><pre>			if fwrapped is None:</pre></div>
<div class="nocov"><span class="num"><pre>389</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>390</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>391</pre></span><pre>			set_method_if_possible(nodetype, fn, fwrapped)</pre></div>
<div class="nocov"><span class="num"><pre>392</pre></span><pre>			if fna != fn:</pre></div>
<div class="nocov"><span class="num"><pre>393</pre></span><pre>				set_method_if_possible(nodetype, fna, fwrapped)</pre></div>
<div class="skip"><span class="num"><pre>394</pre></span><pre>			# END handle aliases</pre></div>
<div class="skip"><span class="num"><pre>395</pre></span><pre>			</pre></div>
<div class="nocov"><span class="num"><pre>396</pre></span><pre>			num_fetched += 1</pre></div>
<div class="skip"><span class="num"><pre>397</pre></span><pre>		# END for each instance function</pre></div>
<div class="skip"><span class="num"><pre>398</pre></span><pre>	# END for each type/mfncls pair</pre></div>
<div class="skip"><span class="num"><pre>399</pre></span><pre>	</pre></div>
<div class="nocov"><span class="num"><pre>400</pre></span><pre>	return num_fetched</pre></div>
<div class="skip"><span class="num"><pre>401</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>402</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>403</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>404</pre></span><pre>#} END utilities</pre></div>
<div class="skip"><span class="num"><pre>405</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>406</pre></span><pre>#{ Initialization</pre></div>
<div class="skip"><span class="num"><pre>407</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>408</pre></span><pre>def _addCustomType( targetmoduledict, parentclsname, newclsname,</pre></div>
<div class="cov"><span class="num"><pre>409</pre></span><pre>				   	metaclass=MetaClassCreatorNodes, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>410</pre></span><pre>	&quot;&quot;&quot;Add a custom type to the system such that a node with the given type will</pre></div>
<div class="cov"><span class="num"><pre>411</pre></span><pre>	automatically be wrapped with the corresponding class name</pre></div>
<div class="skip"><span class="num"><pre>412</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>413</pre></span><pre>	:param targetmoduledict: the module's dict to which standin classes are supposed to be added</pre></div>
<div class="cov"><span class="num"><pre>414</pre></span><pre>	:param parentclsname: the name of the parent node type - if your new class</pre></div>
<div class="cov"><span class="num"><pre>415</pre></span><pre>		has several parents, you have to add the new types beginning at the first exsiting parent</pre></div>
<div class="cov"><span class="num"><pre>416</pre></span><pre>		as written in the maya/cache/nodeHierarchy.html file</pre></div>
<div class="cov"><span class="num"><pre>417</pre></span><pre>	:param newclsname: the new name of your class - it must exist targetmodule</pre></div>
<div class="cov"><span class="num"><pre>418</pre></span><pre>	:param metaclass: meta class object to be called to modify your type upon creation</pre></div>
<div class="cov"><span class="num"><pre>419</pre></span><pre>		It will not be called if the class already exist in targetModule. Its recommended to derive it</pre></div>
<div class="cov"><span class="num"><pre>420</pre></span><pre>		from the metaclass given as default value.</pre></div>
<div class="cov"><span class="num"><pre>421</pre></span><pre>	:raise KeyError: if the parentclsname does not exist&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>422</pre></span><pre>	# add new type into the type hierarchy #</pre></div>
<div class="cov"><span class="num"><pre>423</pre></span><pre>	parentclsname = uncapitalize( parentclsname )</pre></div>
<div class="cov"><span class="num"><pre>424</pre></span><pre>	newclsname = uncapitalize( newclsname )</pre></div>
<div class="cov"><span class="num"><pre>425</pre></span><pre>	nodeTypeTree.add_edge( parentclsname, newclsname )</pre></div>
<div class="skip"><span class="num"><pre>426</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>427</pre></span><pre>	# create wrapper ( in case newclsname does not yet exist in target module )</pre></div>
<div class="cov"><span class="num"><pre>428</pre></span><pre>	mrvmaya.initWrappers( targetmoduledict, [ newclsname ], metaclass, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>429</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>430</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>431</pre></span><pre>def _removeCustomType( targetmoduledict, customTypeName ):</pre></div>
<div class="cov"><span class="num"><pre>432</pre></span><pre>	&quot;&quot;&quot;Remove the given typename from the given target module's dictionary as </pre></div>
<div class="cov"><span class="num"><pre>433</pre></span><pre>	well as from internal caches</pre></div>
<div class="skip"><span class="num"><pre>434</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>435</pre></span><pre>	:note: does nothing if the type does not exist</pre></div>
<div class="cov"><span class="num"><pre>436</pre></span><pre>	:param targetmoduledict: dict of your module to remove the type from</pre></div>
<div class="cov"><span class="num"><pre>437</pre></span><pre>	:param customTypeName: name of the type to be removed, its expected</pre></div>
<div class="cov"><span class="num"><pre>438</pre></span><pre>		to be capitalized&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>439</pre></span><pre>	try:</pre></div>
<div class="cov"><span class="num"><pre>440</pre></span><pre>		del(targetmoduledict[customTypeName])</pre></div>
<div class="nocov"><span class="num"><pre>441</pre></span><pre>	except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>442</pre></span><pre>		pass</pre></div>
<div class="skip"><span class="num"><pre>443</pre></span><pre>	# END remove from dictionary</pre></div>
<div class="skip"><span class="num"><pre>444</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>445</pre></span><pre>	customTypeName = uncapitalize(customTypeName)</pre></div>
<div class="cov"><span class="num"><pre>446</pre></span><pre>	if nodeTypeTree.has_node(customTypeName):</pre></div>
<div class="cov"><span class="num"><pre>447</pre></span><pre>		nodeTypeTree.remove_node(customTypeName)</pre></div>
<div class="skip"><span class="num"><pre>448</pre></span><pre>	# END remove from type tree</pre></div>
<div class="skip"><span class="num"><pre>449</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>450</pre></span><pre>def _addCustomTypeFromDagtree( targetmoduledict, dagtree, metaclass=MetaClassCreatorNodes,</pre></div>
<div class="cov"><span class="num"><pre>451</pre></span><pre>							  	force_creation=False, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>452</pre></span><pre>	&quot;&quot;&quot;As `_addCustomType`, but allows to enter the type relations using a</pre></div>
<div class="cov"><span class="num"><pre>453</pre></span><pre>	`mrv.util.DAGTree` instead of individual names. Thus multiple edges can be added at once</pre></div>
<div class="skip"><span class="num"><pre>454</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>455</pre></span><pre>	:note: special care is being taken to make force_creation work - first all the standind classes</pre></div>
<div class="cov"><span class="num"><pre>456</pre></span><pre>		are needed, then we can create them - just iterating the nodes in undefined order will not work</pre></div>
<div class="cov"><span class="num"><pre>457</pre></span><pre>		as a parent node might not be created yet</pre></div>
<div class="cov"><span class="num"><pre>458</pre></span><pre>	:note: node names in dagtree must be uncapitalized&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>459</pre></span><pre>	# add edges - have to start at root</pre></div>
<div class="nocov"><span class="num"><pre>460</pre></span><pre>	rootnode = dagtree.get_root()</pre></div>
<div class="nocov"><span class="num"><pre>461</pre></span><pre>	def recurseOutEdges( node ):		# postorder</pre></div>
<div class="nocov"><span class="num"><pre>462</pre></span><pre>		for child in dagtree.children_iter( node ):</pre></div>
<div class="nocov"><span class="num"><pre>463</pre></span><pre>			yield (node,child)</pre></div>
<div class="nocov"><span class="num"><pre>464</pre></span><pre>			for edge in recurseOutEdges( child ):	# step down the hierarchy</pre></div>
<div class="nocov"><span class="num"><pre>465</pre></span><pre>				yield edge</pre></div>
<div class="skip"><span class="num"><pre>466</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>467</pre></span><pre>	nodeTypeTree.add_edges_from( recurseOutEdges( rootnode ) )</pre></div>
<div class="nocov"><span class="num"><pre>468</pre></span><pre>	mrvmaya.initWrappers( targetmoduledict, dagtree.nodes_iter(), metaclass, force_creation = force_creation, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>469</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>470</pre></span><pre>def initTypeNameToMfnClsMap( ):</pre></div>
<div class="cov"><span class="num"><pre>471</pre></span><pre>	&quot;&quot;&quot;Fill the cache map supplying additional information about the MFNClass to use</pre></div>
<div class="cov"><span class="num"><pre>472</pre></span><pre>	when creating the classes&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>473</pre></span><pre>	global nodeTypeToMfnClsMap</pre></div>
<div class="cov"><span class="num"><pre>474</pre></span><pre>	nodeTypeToMfnClsMap = mdb.createTypeNameToMfnClsMap()</pre></div>
<div class="skip"><span class="num"><pre>475</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>476</pre></span><pre>def initNodeHierarchy( ):</pre></div>
<div class="cov"><span class="num"><pre>477</pre></span><pre>	&quot;&quot;&quot;Initialize the global tree of types, providing a hierarchical relationship between </pre></div>
<div class="cov"><span class="num"><pre>478</pre></span><pre>	the node typename strings&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>479</pre></span><pre>	global nodeTypeTree</pre></div>
<div class="cov"><span class="num"><pre>480</pre></span><pre>	nodeTypeTree = mdb.createDagNodeHierarchy()</pre></div>
<div class="skip"><span class="num"><pre>481</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>482</pre></span><pre>def initWrappers( targetmoduledict ):</pre></div>
<div class="cov"><span class="num"><pre>483</pre></span><pre>	&quot;&quot;&quot;Create Standin Classes that will delay the creation of the actual class till</pre></div>
<div class="cov"><span class="num"><pre>484</pre></span><pre>	the first instance is requested</pre></div>
<div class="skip"><span class="num"><pre>485</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>486</pre></span><pre>	:param targetmoduledict: the module's dictionary (globals()) to which to put the wrappers&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>487</pre></span><pre>	global nodeTypeTree</pre></div>
<div class="cov"><span class="num"><pre>488</pre></span><pre>	mrvmaya.initWrappers( targetmoduledict, nodeTypeTree.nodes_iter(), MetaClassCreatorNodes )</pre></div>
<div class="skip"><span class="num"><pre>489</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>490</pre></span><pre>#} END initialization</pre></div>
<div class="skip"><span class="num"><pre>491</pre></span><pre></pre></div>
</div>
</body>
</html>
