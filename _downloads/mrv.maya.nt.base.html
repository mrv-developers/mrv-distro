<html>
<head>
<title>mrv.maya.nt.base</title>
</head>
<body>
mrv.maya.nt.base
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 1714 lines<br/>
Missed: 104 lines<br/>
Skipped 999 lines<br/>
Percent: 94 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>   1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>   2</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>   3</pre></span><pre>Contains some basic  classes that are required to run the nodes system</pre></div>
<div class="skip"><span class="num"><pre>   4</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>   5</pre></span><pre>All classes defined here can replace classes in the node type hierarachy if the name</pre></div>
<div class="cov"><span class="num"><pre>   6</pre></span><pre>matches. This allows to create hand-implemented types.</pre></div>
<div class="cov"><span class="num"><pre>   7</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>   8</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>   9</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  10</pre></span><pre>from typ import nodeTypeToMfnClsMap, nodeTypeTree, MetaClassCreatorNodes, _addCustomType</pre></div>
<div class="cov"><span class="num"><pre>  11</pre></span><pre>from mrv.util import uncapitalize, capitalize, pythonIndex, Call </pre></div>
<div class="cov"><span class="num"><pre>  12</pre></span><pre>from mrv.interface import iDuplicatable, iDagItem</pre></div>
<div class="cov"><span class="num"><pre>  13</pre></span><pre>from mrv.maya.util import StandinClass</pre></div>
<div class="cov"><span class="num"><pre>  14</pre></span><pre>import maya.OpenMaya as api</pre></div>
<div class="cov"><span class="num"><pre>  15</pre></span><pre>import maya.cmds as cmds</pre></div>
<div class="cov"><span class="num"><pre>  16</pre></span><pre>import mrv.maya.ns as nsm</pre></div>
<div class="cov"><span class="num"><pre>  17</pre></span><pre>import mrv.maya.undo as undo</pre></div>
<div class="cov"><span class="num"><pre>  18</pre></span><pre>from new import instancemethod</pre></div>
<div class="cov"><span class="num"><pre>  19</pre></span><pre>from util import in_double3_out_vector, undoable_in_double3_as_vector</pre></div>
<div class="cov"><span class="num"><pre>  20</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre>  21</pre></span><pre>log = logging.getLogger(&quot;mrv.maya.nt.base&quot;)</pre></div>
<div class="skip"><span class="num"><pre>  22</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  23</pre></span><pre># direct import to safe api. lookup</pre></div>
<div class="cov"><span class="num"><pre>  24</pre></span><pre>from maya.OpenMaya import MFnDagNode, MDagPath, MObject, MObjectHandle</pre></div>
<div class="skip"><span class="num"><pre>  25</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  26</pre></span><pre>from itertools import chain</pre></div>
<div class="cov"><span class="num"><pre>  27</pre></span><pre>import sys</pre></div>
<div class="skip"><span class="num"><pre>  28</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  29</pre></span><pre>_nodesdict = None				# will be set during maya.nt initialization</pre></div>
<div class="skip"><span class="num"><pre>  30</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  31</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  32</pre></span><pre>__all__ = (&quot;nodeTypeToNodeTypeCls&quot;, &quot;isAbsolutePath&quot;, &quot;toApiobj&quot;, &quot;toApiobjOrDagPath&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  33</pre></span><pre>           &quot;toSelectionList&quot;, &quot;toComponentSelectionList&quot;, &quot;toSelectionListFromNames&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  34</pre></span><pre>           &quot;fromSelectionList&quot;, &quot;toNodesFromNames&quot;, &quot;findByName&quot;, &quot;objExists&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  35</pre></span><pre>           &quot;delete&quot;, &quot;selection&quot;, &quot;activeSelectionList&quot;, &quot;iterSelection&quot;, &quot;select&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  36</pre></span><pre>           &quot;createNode&quot;, &quot;SetFilter&quot;, &quot;Node&quot;, &quot;NodeFromObj&quot;, &quot;NodeFromStr&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  37</pre></span><pre>           &quot;DependNode&quot;, &quot;Entity&quot;, &quot;DagNode&quot;, &quot;Attribute&quot;, &quot;UnitAttribute&quot;, &quot;TypedAttribute&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  38</pre></span><pre>           &quot;NumericAttribute&quot;, &quot;MessageAttribute&quot;, &quot;MatrixAttribute&quot;, &quot;LightDataAttribute&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  39</pre></span><pre>           &quot;GenericAttribute&quot;, &quot;EnumAttribute&quot;, &quot;CompoundAttribute&quot;, &quot;Data&quot;, &quot;VectorArrayData&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  40</pre></span><pre>           &quot;UInt64ArrayData&quot;, &quot;StringData&quot;, &quot;StringArrayData&quot;, &quot;SphereData&quot;, &quot;PointArrayData&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  41</pre></span><pre>           &quot;PluginData&quot;, &quot;NumericData&quot;, &quot;NObjectData&quot;, &quot;MatrixData&quot;, &quot;IntArrayData&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  42</pre></span><pre>           &quot;GeometryData&quot;, &quot;SubdData&quot;, &quot;NurbsSurfaceData&quot;, &quot;NurbsCurveData&quot;, &quot;MeshData&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  43</pre></span><pre>           &quot;LatticeData&quot;, &quot;DynSweptGeometryData&quot;, &quot;DoubleArrayData&quot;, &quot;ComponentListData&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  44</pre></span><pre>           &quot;ArrayAttrsData&quot;, &quot;Component&quot;, &quot;SingleIndexedComponent&quot;, &quot;DoubleIndexedComponent&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  45</pre></span><pre>           &quot;TripleIndexedComponent&quot;, &quot;MDagPathUtil&quot;, &quot;Reference&quot;, &quot;Transform&quot;, &quot;Shape&quot; )</pre></div>
<div class="skip"><span class="num"><pre>  46</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  47</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  48</pre></span><pre>############################</pre></div>
<div class="skip"><span class="num"><pre>  49</pre></span><pre>#### Cache 			  	####</pre></div>
<div class="skip"><span class="num"><pre>  50</pre></span><pre>##########################</pre></div>
<div class="skip"><span class="num"><pre>  51</pre></span><pre># to prevent always creating instances of the same class per call</pre></div>
<div class="cov"><span class="num"><pre>  52</pre></span><pre>_nameToApiSelList = api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre>  53</pre></span><pre>_mfndep = api.MFnDependencyNode()</pre></div>
<div class="cov"><span class="num"><pre>  54</pre></span><pre>_mfndag = api.MFnDagNode()</pre></div>
<div class="skip"><span class="num"><pre>  55</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  56</pre></span><pre># cache functions</pre></div>
<div class="cov"><span class="num"><pre>  57</pre></span><pre>_mfndep_setobject = _mfndep.setObject</pre></div>
<div class="cov"><span class="num"><pre>  58</pre></span><pre>_mfndag_setObject = _mfndag.setObject</pre></div>
<div class="cov"><span class="num"><pre>  59</pre></span><pre>_mfndep_typename = _mfndep.typeName</pre></div>
<div class="cov"><span class="num"><pre>  60</pre></span><pre>_mfndag_typename = _mfndag.typeName</pre></div>
<div class="cov"><span class="num"><pre>  61</pre></span><pre>_mfndep_name = _mfndep.name</pre></div>
<div class="skip"><span class="num"><pre>  62</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  63</pre></span><pre>_api_mdagpath_node = MDagPath.node</pre></div>
<div class="cov"><span class="num"><pre>  64</pre></span><pre>_apitype_to_name = dict()			# [int] - &gt; type name string</pre></div>
<div class="skip"><span class="num"><pre>  65</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  66</pre></span><pre>_plugin_type_ids = (	api.MFn.kPluginDeformerNode, </pre></div>
<div class="cov"><span class="num"><pre>  67</pre></span><pre>							api.MFn.kPluginDependNode,</pre></div>
<div class="cov"><span class="num"><pre>  68</pre></span><pre>							api.MFn.kPluginEmitterNode, </pre></div>
<div class="cov"><span class="num"><pre>  69</pre></span><pre>							api.MFn.kPluginFieldNode,</pre></div>
<div class="cov"><span class="num"><pre>  70</pre></span><pre>							api.MFn.kPluginHwShaderNode,</pre></div>
<div class="cov"><span class="num"><pre>  71</pre></span><pre>							api.MFn.kPluginIkSolver,</pre></div>
<div class="cov"><span class="num"><pre>  72</pre></span><pre>							api.MFn.kPluginImagePlaneNode,</pre></div>
<div class="cov"><span class="num"><pre>  73</pre></span><pre>							api.MFn.kPluginLocatorNode,</pre></div>
<div class="cov"><span class="num"><pre>  74</pre></span><pre>							api.MFn.kPluginManipContainer,</pre></div>
<div class="cov"><span class="num"><pre>  75</pre></span><pre>							api.MFn.kPluginObjectSet, </pre></div>
<div class="cov"><span class="num"><pre>  76</pre></span><pre>							api.MFn.kPluginParticleAttributeMapperNode, </pre></div>
<div class="cov"><span class="num"><pre>  77</pre></span><pre>							api.MFn.kPluginShape,</pre></div>
<div class="cov"><span class="num"><pre>  78</pre></span><pre>							api.MFn.kPluginSpringNode,</pre></div>
<div class="cov"><span class="num"><pre>  79</pre></span><pre>							api.MFn.kPluginTransformNode )</pre></div>
<div class="skip"><span class="num"><pre>  80</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  81</pre></span><pre>_plugin_type_ids_lut = set(_plugin_type_ids)</pre></div>
<div class="skip"><span class="num"><pre>  82</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  83</pre></span><pre>_plugin_type_to_node_type_name = dict(zip((_plugin_type_ids), (&quot;UnknownPluginDeformerNode&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  84</pre></span><pre>																&quot;UnknownPluginDependNode&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  85</pre></span><pre>																&quot;UnknownPluginEmitterNode&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  86</pre></span><pre>																&quot;UnknownPluginFieldNode&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  87</pre></span><pre>																&quot;UnknownPluginHwShaderNode&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  88</pre></span><pre>																&quot;UnknownPluginIkSolver&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  89</pre></span><pre>																&quot;UnknownPluginImagePlaneNode&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  90</pre></span><pre>																&quot;UnknownPluginLocatorNode&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  91</pre></span><pre>																&quot;UnknownPluginManipContainer&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  92</pre></span><pre>																&quot;UnknownPluginObjectSet&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  93</pre></span><pre>																&quot;UnknownPluginParticleAttributeMapperNode&quot;, </pre></div>
<div class="cov"><span class="num"><pre>  94</pre></span><pre>																&quot;UnknownPluginShape&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  95</pre></span><pre>																&quot;UnknownPluginSpringNode&quot;,</pre></div>
<div class="cov"><span class="num"><pre>  96</pre></span><pre>																&quot;UnknownPluginTransformNode&quot; )))</pre></div>
<div class="skip"><span class="num"><pre>  97</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  98</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>  99</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 100</pre></span><pre>############################</pre></div>
<div class="skip"><span class="num"><pre> 101</pre></span><pre>#### Methods 		  	####</pre></div>
<div class="skip"><span class="num"><pre> 102</pre></span><pre>##########################</pre></div>
<div class="skip"><span class="num"><pre> 103</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 104</pre></span><pre>#{ Conversions</pre></div>
<div class="skip"><span class="num"><pre> 105</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 106</pre></span><pre>def nodeTypeToNodeTypeCls( nodeTypeName, apiobj ):</pre></div>
<div class="cov"><span class="num"><pre> 107</pre></span><pre>	&quot;&quot;&quot; Convert the given  node type (str) to the respective python node type class</pre></div>
<div class="skip"><span class="num"><pre> 108</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 109</pre></span><pre>	:param nodeTypeName: the type name you which to have the actual class for</pre></div>
<div class="cov"><span class="num"><pre> 110</pre></span><pre>	:param apiobj: source api object, its apiType is used as fallback in case we </pre></div>
<div class="cov"><span class="num"><pre> 111</pre></span><pre>		don't know the node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 112</pre></span><pre>	try:</pre></div>
<div class="cov"><span class="num"><pre> 113</pre></span><pre>		nodeTypeCls = _nodesdict[capitalize( nodeTypeName )]</pre></div>
<div class="cov"><span class="num"><pre> 114</pre></span><pre>	except KeyError:</pre></div>
<div class="skip"><span class="num"><pre> 115</pre></span><pre>		# assume its a plugin node - in that case the parent will be nicely defined</pre></div>
<div class="skip"><span class="num"><pre> 116</pre></span><pre>		# and helps us to figure out that its a default dummy</pre></div>
<div class="cov"><span class="num"><pre> 117</pre></span><pre>		parentclsname = _plugin_type_to_node_type_name.get(apiobj.apiType(), (isinstance(apiobj, MDagPath) and 'UnknownDag') or 'Unknown')</pre></div>
<div class="cov"><span class="num"><pre> 118</pre></span><pre>		_addCustomType(_nodesdict, parentclsname, nodeTypeName)</pre></div>
<div class="cov"><span class="num"><pre> 119</pre></span><pre>		nodeTypeCls = _nodesdict[capitalize(nodeTypeName)]</pre></div>
<div class="skip"><span class="num"><pre> 120</pre></span><pre>	# END exception handling</pre></div>
<div class="skip"><span class="num"><pre> 121</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 122</pre></span><pre>	if isinstance( nodeTypeCls, StandinClass ):</pre></div>
<div class="cov"><span class="num"><pre> 123</pre></span><pre>		nodeTypeCls = nodeTypeCls.createCls( )</pre></div>
<div class="skip"><span class="num"><pre> 124</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 125</pre></span><pre>	return nodeTypeCls</pre></div>
<div class="skip"><span class="num"><pre> 126</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 127</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 128</pre></span><pre>def _makeAbsolutePath( nodename ):</pre></div>
<div class="skip"><span class="num"><pre> 129</pre></span><pre>	# if dag paths are passed in, we do nothing as a dag object is obviously meant.</pre></div>
<div class="skip"><span class="num"><pre> 130</pre></span><pre>	# Otherwise prepend a '|' to make it a dag object - the calling method will deal</pre></div>
<div class="skip"><span class="num"><pre> 131</pre></span><pre>	# with it accordingly</pre></div>
<div class="cov"><span class="num"><pre> 132</pre></span><pre>	if nodename.count( '|' )  == 0:</pre></div>
<div class="cov"><span class="num"><pre> 133</pre></span><pre>		return '|' + nodename</pre></div>
<div class="cov"><span class="num"><pre> 134</pre></span><pre>	return nodename</pre></div>
<div class="skip"><span class="num"><pre> 135</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 136</pre></span><pre>def isAbsolutePath( nodename ):</pre></div>
<div class="nocov"><span class="num"><pre> 137</pre></span><pre>	return nodename.startswith( '|' )</pre></div>
<div class="skip"><span class="num"><pre> 138</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 139</pre></span><pre>def toDagPath( apiobj ):</pre></div>
<div class="cov"><span class="num"><pre> 140</pre></span><pre>	&quot;&quot;&quot;Find ONE valid dag path to the given dag api object&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 141</pre></span><pre>	dagpath = MDagPath( )</pre></div>
<div class="nocov"><span class="num"><pre> 142</pre></span><pre>	MFnDagNode( apiobj ).getPath( dagpath )</pre></div>
<div class="nocov"><span class="num"><pre> 143</pre></span><pre>	return dagpath</pre></div>
<div class="skip"><span class="num"><pre> 144</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 145</pre></span><pre>def toApiobj( nodename ):</pre></div>
<div class="cov"><span class="num"><pre> 146</pre></span><pre>	&quot;&quot;&quot; Convert the given nodename to the respective MObject</pre></div>
<div class="skip"><span class="num"><pre> 147</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 148</pre></span><pre>	:note: uses unique names only, and will fail if a non-unique path is given, which is</pre></div>
<div class="cov"><span class="num"><pre> 149</pre></span><pre>		as selection lists do not work properly with partial names !</pre></div>
<div class="cov"><span class="num"><pre> 150</pre></span><pre>	:note: even dag objects will end up as MObject</pre></div>
<div class="cov"><span class="num"><pre> 151</pre></span><pre>	:note: code repeats partly in toApiobjOrDagPath as its supposed to be as fast</pre></div>
<div class="cov"><span class="num"><pre> 152</pre></span><pre>		as possible - this method gets called quite a few times in benchmarks&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 153</pre></span><pre>	_nameToApiSelList.clear()</pre></div>
<div class="skip"><span class="num"><pre> 154</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 155</pre></span><pre>	nodename = _makeAbsolutePath( nodename )</pre></div>
<div class="skip"><span class="num"><pre> 156</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 157</pre></span><pre>	objnamelist = [ nodename ]</pre></div>
<div class="cov"><span class="num"><pre> 158</pre></span><pre>	if nodename.startswith( &quot;|&quot; ) and nodename.count( '|' ) == 1:</pre></div>
<div class="cov"><span class="num"><pre> 159</pre></span><pre>		objnamelist.append( nodename[1:] )</pre></div>
<div class="skip"><span class="num"><pre> 160</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 161</pre></span><pre>	for name in objnamelist:</pre></div>
<div class="cov"><span class="num"><pre> 162</pre></span><pre>		try:	# DEPEND NODE ?</pre></div>
<div class="cov"><span class="num"><pre> 163</pre></span><pre>			_nameToApiSelList.add( name )</pre></div>
<div class="cov"><span class="num"><pre> 164</pre></span><pre>		except:</pre></div>
<div class="cov"><span class="num"><pre> 165</pre></span><pre>			continue</pre></div>
<div class="cov"><span class="num"><pre> 166</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 167</pre></span><pre>			obj = MObject()</pre></div>
<div class="cov"><span class="num"><pre> 168</pre></span><pre>			_nameToApiSelList.getDependNode( 0, obj )</pre></div>
<div class="skip"><span class="num"><pre> 169</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 170</pre></span><pre>			# if we requested a dg node, but got a dag node, fail</pre></div>
<div class="cov"><span class="num"><pre> 171</pre></span><pre>			if name.count( '|' ) == 0 and obj.hasFn( api.MFn.kDagNode ):</pre></div>
<div class="cov"><span class="num"><pre> 172</pre></span><pre>				log.warn(&quot;Skipped %s as a dependency node was expected, but got a dag node&quot; % name)</pre></div>
<div class="cov"><span class="num"><pre> 173</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre> 174</pre></span><pre>			# END dag/dg inconsistency handling</pre></div>
<div class="skip"><span class="num"><pre> 175</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 176</pre></span><pre>			return obj</pre></div>
<div class="skip"><span class="num"><pre> 177</pre></span><pre>		# END if no exception on selectionList.add</pre></div>
<div class="skip"><span class="num"><pre> 178</pre></span><pre>	# END for each test-object</pre></div>
<div class="cov"><span class="num"><pre> 179</pre></span><pre>	return None</pre></div>
<div class="skip"><span class="num"><pre> 180</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 181</pre></span><pre>def toApiobjOrDagPath( nodename ):</pre></div>
<div class="cov"><span class="num"><pre> 182</pre></span><pre>	&quot;&quot;&quot;Convert the given nodename to the respective MObject or MDagPath</pre></div>
<div class="skip"><span class="num"><pre> 183</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 184</pre></span><pre>	:note: we treat &quot;nodename&quot; and &quot;\|nodename&quot; as the same objects as they occupy the</pre></div>
<div class="cov"><span class="num"><pre> 185</pre></span><pre>		same namespace - one time a dep node is meant, the other time a dag node.</pre></div>
<div class="cov"><span class="num"><pre> 186</pre></span><pre>		If querying a dag node, the dep node with the same name is not found, although it is in</pre></div>
<div class="cov"><span class="num"><pre> 187</pre></span><pre>		the same freaking namespace ! IMHO this is a big bug !&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 188</pre></span><pre>	_nameToApiSelList.clear()</pre></div>
<div class="skip"><span class="num"><pre> 189</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 190</pre></span><pre>	nodename = _makeAbsolutePath( nodename )</pre></div>
<div class="skip"><span class="num"><pre> 191</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 192</pre></span><pre>	objnamelist = [ nodename ]</pre></div>
<div class="cov"><span class="num"><pre> 193</pre></span><pre>	if nodename.startswith( &quot;|&quot; ) and nodename.count( '|' ) == 1:	# check dep node too !	 ( &quot;|nodename&quot;, but &quot;nodename&quot; could exist too, occupying the &quot;|nodename&quot; name !</pre></div>
<div class="cov"><span class="num"><pre> 194</pre></span><pre>		objnamelist.append( nodename[1:] )</pre></div>
<div class="skip"><span class="num"><pre> 195</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 196</pre></span><pre>	for name in objnamelist:</pre></div>
<div class="cov"><span class="num"><pre> 197</pre></span><pre>		try:	# DEPEND NODE ?</pre></div>
<div class="cov"><span class="num"><pre> 198</pre></span><pre>			_nameToApiSelList.add( name )</pre></div>
<div class="cov"><span class="num"><pre> 199</pre></span><pre>		except:</pre></div>
<div class="cov"><span class="num"><pre> 200</pre></span><pre>			continue</pre></div>
<div class="cov"><span class="num"><pre> 201</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 202</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 203</pre></span><pre>				dag = MDagPath()</pre></div>
<div class="cov"><span class="num"><pre> 204</pre></span><pre>				_nameToApiSelList.getDagPath( 0 , dag )</pre></div>
<div class="cov"><span class="num"><pre> 205</pre></span><pre>				return dag</pre></div>
<div class="cov"><span class="num"><pre> 206</pre></span><pre>			except RuntimeError:</pre></div>
<div class="cov"><span class="num"><pre> 207</pre></span><pre>				obj = MObject()</pre></div>
<div class="cov"><span class="num"><pre> 208</pre></span><pre>				_nameToApiSelList.getDependNode( 0, obj )</pre></div>
<div class="skip"><span class="num"><pre> 209</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 210</pre></span><pre>				# if we requested a dg node, but got a dag node, fail</pre></div>
<div class="cov"><span class="num"><pre> 211</pre></span><pre>				if name.count( '|' ) == 0 and obj.hasFn( api.MFn.kDagNode ):</pre></div>
<div class="nocov"><span class="num"><pre> 212</pre></span><pre>					log.warn(&quot;Skipped %s as a dependency node was expected, but got a dag node&quot; % name)</pre></div>
<div class="nocov"><span class="num"><pre> 213</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre> 214</pre></span><pre>				# END dag/dg inconsistency handling</pre></div>
<div class="skip"><span class="num"><pre> 215</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 216</pre></span><pre>				return obj</pre></div>
<div class="skip"><span class="num"><pre> 217</pre></span><pre>		# END if no exception on selectionList.add</pre></div>
<div class="skip"><span class="num"><pre> 218</pre></span><pre>	# END for each object name</pre></div>
<div class="cov"><span class="num"><pre> 219</pre></span><pre>	return None</pre></div>
<div class="skip"><span class="num"><pre> 220</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 221</pre></span><pre>def toSelectionList( nodeList, mergeWithExisting = False ):</pre></div>
<div class="cov"><span class="num"><pre> 222</pre></span><pre>	&quot;&quot;&quot;Convert an iterable filled with Nodes to a selection list</pre></div>
<div class="skip"><span class="num"><pre> 223</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 224</pre></span><pre>	:param nodeList: iterable filled with dg and dag nodes as well as plugs, dagpaths or mobjects or strings</pre></div>
<div class="cov"><span class="num"><pre> 225</pre></span><pre>	:param mergeWithExisting: if true, the selection list will not allow dupliacates , but adding objects</pre></div>
<div class="cov"><span class="num"><pre> 226</pre></span><pre>		also takes ( much )  longer, depending on the size of the list</pre></div>
<div class="cov"><span class="num"><pre> 227</pre></span><pre>	:return: selection list filled with objects from node list&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 228</pre></span><pre>	if isinstance( nodeList, api.MSelectionList ):		# sanity check</pre></div>
<div class="cov"><span class="num"><pre> 229</pre></span><pre>		return nodeList</pre></div>
<div class="skip"><span class="num"><pre> 230</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 231</pre></span><pre>	sellist = api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre> 232</pre></span><pre>	for node in nodeList:</pre></div>
<div class="cov"><span class="num"><pre> 233</pre></span><pre>		if isinstance( node, DagNode ):</pre></div>
<div class="cov"><span class="num"><pre> 234</pre></span><pre>			sellist.add( node.dagPath(), MObject(), mergeWithExisting )</pre></div>
<div class="cov"><span class="num"><pre> 235</pre></span><pre>		elif isinstance( node, DependNode ):</pre></div>
<div class="cov"><span class="num"><pre> 236</pre></span><pre>			sellist.add( node.object(), mergeWithExisting )</pre></div>
<div class="cov"><span class="num"><pre> 237</pre></span><pre>		else: # probably plug or something else like an mobject or dagpath</pre></div>
<div class="skip"><span class="num"><pre> 238</pre></span><pre>			# cannot properly apply our flag here without intensive checking</pre></div>
<div class="skip"><span class="num"><pre> 239</pre></span><pre>			# TODO: probably put in the instance checks !</pre></div>
<div class="cov"><span class="num"><pre> 240</pre></span><pre>			sellist.add( node )</pre></div>
<div class="skip"><span class="num"><pre> 241</pre></span><pre>	# END for each item in input array</pre></div>
<div class="cov"><span class="num"><pre> 242</pre></span><pre>	return sellist</pre></div>
<div class="skip"><span class="num"><pre> 243</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 244</pre></span><pre>def toComponentSelectionList( nodeCompList, mergeWithExisting = False ):</pre></div>
<div class="cov"><span class="num"><pre> 245</pre></span><pre>	&quot;&quot;&quot;As above, but only works on DagNodes having components - the components</pre></div>
<div class="cov"><span class="num"><pre> 246</pre></span><pre>	can be a nullObject though to add the whole object after all.</pre></div>
<div class="skip"><span class="num"><pre> 247</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 248</pre></span><pre>	:param nodeCompList: list of tuple( DagNode, Component ), Component can be</pre></div>
<div class="cov"><span class="num"><pre> 249</pre></span><pre>		filled component or null MObject&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 250</pre></span><pre>	if isinstance( nodeCompList, api.MSelectionList ):		# sanity check</pre></div>
<div class="nocov"><span class="num"><pre> 251</pre></span><pre>		return nodeList</pre></div>
<div class="skip"><span class="num"><pre> 252</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 253</pre></span><pre>	sellist = api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre> 254</pre></span><pre>	for node, component in nodeCompList:</pre></div>
<div class="cov"><span class="num"><pre> 255</pre></span><pre>		sellist.add( node.dagPath(), component, mergeWithExisting )</pre></div>
<div class="skip"><span class="num"><pre> 256</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 257</pre></span><pre>	return sellist</pre></div>
<div class="skip"><span class="num"><pre> 258</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 259</pre></span><pre>def toSelectionListFromNames( nodenames ):</pre></div>
<div class="cov"><span class="num"><pre> 260</pre></span><pre>	&quot;&quot;&quot;Convert the given iterable of nodenames to a selection list</pre></div>
<div class="skip"><span class="num"><pre> 261</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 262</pre></span><pre>	:return: MSelectionList, use `iterSelectionList` to retrieve the objects&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 263</pre></span><pre>	sellist = api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre> 264</pre></span><pre>	for name in nodenames:</pre></div>
<div class="cov"><span class="num"><pre> 265</pre></span><pre>		sellist.add( name )</pre></div>
<div class="skip"><span class="num"><pre> 266</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 267</pre></span><pre>	return sellist</pre></div>
<div class="skip"><span class="num"><pre> 268</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 269</pre></span><pre>def fromSelectionList( sellist, handlePlugs=1, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 270</pre></span><pre>	&quot;&quot;&quot;:return: list of Nodes and MPlugs stored in the given selection list</pre></div>
<div class="cov"><span class="num"><pre> 271</pre></span><pre>	:param kwargs: passed to selectionListIterator&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 272</pre></span><pre>	kwargs['asNode'] = 1</pre></div>
<div class="cov"><span class="num"><pre> 273</pre></span><pre>	kwargs['handlePlugs'] = handlePlugs</pre></div>
<div class="cov"><span class="num"><pre> 274</pre></span><pre>	return list(sellist.mtoIter(**kwargs))</pre></div>
<div class="skip"><span class="num"><pre> 275</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 276</pre></span><pre>def toNodesFromNames( nodenames, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 277</pre></span><pre>	&quot;&quot;&quot;:return: list of wrapped nodes from the given list of node names</pre></div>
<div class="cov"><span class="num"><pre> 278</pre></span><pre>	:note: this function is supposed to be faster for multiple nodes compared to</pre></div>
<div class="cov"><span class="num"><pre> 279</pre></span><pre>		just creating a Node directly as we optimize the process due to the intermediate</pre></div>
<div class="cov"><span class="num"><pre> 280</pre></span><pre>		selection list getting the api objects for the given names</pre></div>
<div class="cov"><span class="num"><pre> 281</pre></span><pre>	:param kwargs: passed to `fromSelectionList`&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 282</pre></span><pre>	return fromSelectionList( toSelectionListFromNames( nodenames ), **kwargs )</pre></div>
<div class="skip"><span class="num"><pre> 283</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 284</pre></span><pre>def findByName( name , **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 285</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 286</pre></span><pre>	:return: list of node matching name, whereas simple regex using ``*`` can be used</pre></div>
<div class="cov"><span class="num"><pre> 287</pre></span><pre>		to describe a pattern</pre></div>
<div class="cov"><span class="num"><pre> 288</pre></span><pre>	:param name: string like pcube, or pcube*, or ``pcube*|*Shape``</pre></div>
<div class="cov"><span class="num"><pre> 289</pre></span><pre>	:param kwargs: passed to `fromSelectionList`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 290</pre></span><pre>	sellist = api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre> 291</pre></span><pre>	api.MGlobal.getSelectionListByName( name, sellist )</pre></div>
<div class="skip"><span class="num"><pre> 292</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 293</pre></span><pre>	return fromSelectionList( sellist, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre> 294</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 295</pre></span><pre>#} END conversions</pre></div>
<div class="skip"><span class="num"><pre> 296</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 297</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 298</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 299</pre></span><pre>#{ Base</pre></div>
<div class="skip"><span class="num"><pre> 300</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 301</pre></span><pre>def objExists( objectname ):</pre></div>
<div class="cov"><span class="num"><pre> 302</pre></span><pre>	&quot;&quot;&quot;:return: True if given object exists, false otherwise</pre></div>
<div class="cov"><span class="num"><pre> 303</pre></span><pre>	:param objectname: we always use absolute paths to have a unique name</pre></div>
<div class="cov"><span class="num"><pre> 304</pre></span><pre>	:note: perfer this method over mel as the API is used directly as we have some special</pre></div>
<div class="cov"><span class="num"><pre> 305</pre></span><pre>		handling to assure we get the right nodes&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 306</pre></span><pre>	return toApiobj( objectname ) is not None</pre></div>
<div class="skip"><span class="num"><pre> 307</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 308</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 309</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre> 310</pre></span><pre>def delete( *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 311</pre></span><pre>	&quot;&quot;&quot;Delete the given nodes</pre></div>
<div class="skip"><span class="num"><pre> 312</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 313</pre></span><pre>	:param args: Node instances, MObjects, MDagPaths or strings to delete</pre></div>
<div class="cov"><span class="num"><pre> 314</pre></span><pre>	:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre> 315</pre></span><pre>		 * presort: </pre></div>
<div class="cov"><span class="num"><pre> 316</pre></span><pre>		 	if True, default False, will do alot of pre-work to actually</pre></div>
<div class="cov"><span class="num"><pre> 317</pre></span><pre>		 	make the deletion work properly using  the UI, thus we sort dag nodes</pre></div>
<div class="cov"><span class="num"><pre> 318</pre></span><pre>		 	by dag path token length to delete top level ones first and individually, </pre></div>
<div class="cov"><span class="num"><pre> 319</pre></span><pre>		 	to finally delete all dependency nodes in a bunch</pre></div>
<div class="skip"><span class="num"><pre> 320</pre></span><pre>		 </pre></div>
<div class="cov"><span class="num"><pre> 321</pre></span><pre>		Using this flag will be slower, but yields much better results if deleting complex</pre></div>
<div class="cov"><span class="num"><pre> 322</pre></span><pre>		dag and dependency trees with locked attributes, conversion nodes, transforms and shapes</pre></div>
<div class="cov"><span class="num"><pre> 323</pre></span><pre>	:note: in general , no matter which options have been chosen , api deletion does not work well</pre></div>
<div class="cov"><span class="num"><pre> 324</pre></span><pre>		as the used algorithm is totally different and inferior to the mel implementaiton</pre></div>
<div class="cov"><span class="num"><pre> 325</pre></span><pre>	:note: will not raise in case of an error, but print a notification message</pre></div>
<div class="cov"><span class="num"><pre> 326</pre></span><pre>	:note: all deletions will be stored on one undo operation&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 327</pre></span><pre>	presort = kwargs.get( &quot;presort&quot;, False )</pre></div>
<div class="skip"><span class="num"><pre> 328</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 329</pre></span><pre>	# presort - this allows objects high up in the hierarchy to be deleted first</pre></div>
<div class="skip"><span class="num"><pre> 330</pre></span><pre>	# Otherwise we might have trouble deleting the ones lower in the hierarchy</pre></div>
<div class="skip"><span class="num"><pre> 331</pre></span><pre>	# We are basically reimplementing the MEL command 'delete' which does the</pre></div>
<div class="skip"><span class="num"><pre> 332</pre></span><pre>	# same thing internally I assume</pre></div>
<div class="cov"><span class="num"><pre> 333</pre></span><pre>	nodes = toSelectionList(args).mtoList()</pre></div>
<div class="cov"><span class="num"><pre> 334</pre></span><pre>	if presort:</pre></div>
<div class="nocov"><span class="num"><pre> 335</pre></span><pre>		depnodes = list()</pre></div>
<div class="nocov"><span class="num"><pre> 336</pre></span><pre>		dagnodes = list()</pre></div>
<div class="nocov"><span class="num"><pre> 337</pre></span><pre>		for node in nodes:</pre></div>
<div class="nocov"><span class="num"><pre> 338</pre></span><pre>			if isinstance( node, DagNode ):</pre></div>
<div class="nocov"><span class="num"><pre> 339</pre></span><pre>				dagnodes.append( node )</pre></div>
<div class="nocov"><span class="num"><pre> 340</pre></span><pre>			else:</pre></div>
<div class="nocov"><span class="num"><pre> 341</pre></span><pre>				depnodes.append( node )</pre></div>
<div class="skip"><span class="num"><pre> 342</pre></span><pre>		# END for each node in nodes for categorizing</pre></div>
<div class="skip"><span class="num"><pre> 343</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 344</pre></span><pre>		# long paths first</pre></div>
<div class="nocov"><span class="num"><pre> 345</pre></span><pre>		dagnodes.sort( key = lambda n: len( str( n ).split( '|' ) ), reverse = True )</pre></div>
<div class="skip"><span class="num"><pre> 346</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 347</pre></span><pre>		# use all of these in order</pre></div>
<div class="nocov"><span class="num"><pre> 348</pre></span><pre>		nodes = chain( dagnodes, depnodes )</pre></div>
<div class="skip"><span class="num"><pre> 349</pre></span><pre>	# END presorting</pre></div>
<div class="skip"><span class="num"><pre> 350</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 351</pre></span><pre>	# NOTE: objects really want to be deleted individually - otherwise</pre></div>
<div class="skip"><span class="num"><pre> 352</pre></span><pre>	# maya might just crash for some reason !!</pre></div>
<div class="cov"><span class="num"><pre> 353</pre></span><pre>	for node in nodes:</pre></div>
<div class="cov"><span class="num"><pre> 354</pre></span><pre>		if not node.isValid():</pre></div>
<div class="nocov"><span class="num"><pre> 355</pre></span><pre>			continue</pre></div>
<div class="skip"><span class="num"><pre> 356</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 357</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 358</pre></span><pre>			node.delete()</pre></div>
<div class="nocov"><span class="num"><pre> 359</pre></span><pre>		except RuntimeError:</pre></div>
<div class="nocov"><span class="num"><pre> 360</pre></span><pre>			log.error(&quot;Deletion of %s failed&quot; % node)</pre></div>
<div class="skip"><span class="num"><pre> 361</pre></span><pre>		# END exception handling</pre></div>
<div class="skip"><span class="num"><pre> 362</pre></span><pre>	# END for each node to delete</pre></div>
<div class="skip"><span class="num"><pre> 363</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 364</pre></span><pre>def selection( filterType=api.MFn.kInvalid, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 365</pre></span><pre>	&quot;&quot;&quot;:return: list of Nodes from the current selection</pre></div>
<div class="cov"><span class="num"><pre> 366</pre></span><pre>	:param filterType: The type of nodes to return exclusively. Defaults to </pre></div>
<div class="cov"><span class="num"><pre> 367</pre></span><pre>		returning all nodes.</pre></div>
<div class="cov"><span class="num"><pre> 368</pre></span><pre>	:param kwargs: passed to `fromSelectionList`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 369</pre></span><pre>	kwargs['filterType'] = filterType</pre></div>
<div class="cov"><span class="num"><pre> 370</pre></span><pre>	return fromSelectionList( activeSelectionList(), **kwargs )</pre></div>
<div class="skip"><span class="num"><pre> 371</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 372</pre></span><pre>def activeSelectionList( ):</pre></div>
<div class="cov"><span class="num"><pre> 373</pre></span><pre>	&quot;&quot;&quot;:return: MSelectionList of the current selection list&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 374</pre></span><pre>	sellist = api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre> 375</pre></span><pre>	api.MGlobal.getActiveSelectionList( sellist )</pre></div>
<div class="cov"><span class="num"><pre> 376</pre></span><pre>	return sellist</pre></div>
<div class="skip"><span class="num"><pre> 377</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 378</pre></span><pre>def iterSelection(filterType=api.MFn.kInvalid, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre> 379</pre></span><pre>	&quot;&quot;&quot;:return: iterator over current scene selection</pre></div>
<div class="cov"><span class="num"><pre> 380</pre></span><pre>	:param filterType: MFn type specifying the node type to iterate upon. Defaults</pre></div>
<div class="cov"><span class="num"><pre> 381</pre></span><pre>		to all node types.</pre></div>
<div class="cov"><span class="num"><pre> 382</pre></span><pre>	:param kwargs: passed to `it.iterSelectionList`</pre></div>
<div class="cov"><span class="num"><pre> 383</pre></span><pre>	:note: This iterator will always return Nodes&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 384</pre></span><pre>	kwargs['asNode'] = 1	# remove our overridden warg</pre></div>
<div class="cov"><span class="num"><pre> 385</pre></span><pre>	kwargs['filterType'] = filterType</pre></div>
<div class="cov"><span class="num"><pre> 386</pre></span><pre>	return activeSelectionList().mtoIter(**kwargs)</pre></div>
<div class="skip"><span class="num"><pre> 387</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 388</pre></span><pre>def select( *nodesOrSelectionList , **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 389</pre></span><pre>	&quot;&quot;&quot;Select the given list of wrapped nodes or selection list in maya</pre></div>
<div class="skip"><span class="num"><pre> 390</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 391</pre></span><pre>	:param nodesOrSelectionList: single selection list or multiple wrapped nodes</pre></div>
<div class="cov"><span class="num"><pre> 392</pre></span><pre>		, or multiple names</pre></div>
<div class="cov"><span class="num"><pre> 393</pre></span><pre>	:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre> 394</pre></span><pre>		 * listAdjustment: default api.MGlobal.kReplaceList</pre></div>
<div class="cov"><span class="num"><pre> 395</pre></span><pre>	:note: as this is a convenience function that is not required by the api itself,</pre></div>
<div class="cov"><span class="num"><pre> 396</pre></span><pre>		but for interactive sessions, it will be undoable</pre></div>
<div class="cov"><span class="num"><pre> 397</pre></span><pre>	:note: Components are only supported if a selection list is given</pre></div>
<div class="cov"><span class="num"><pre> 398</pre></span><pre>	:note: This method is implicitly undoable&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 399</pre></span><pre>	nodenames = list()</pre></div>
<div class="cov"><span class="num"><pre> 400</pre></span><pre>	other = list()</pre></div>
<div class="skip"><span class="num"><pre> 401</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 402</pre></span><pre>	for item in nodesOrSelectionList:</pre></div>
<div class="cov"><span class="num"><pre> 403</pre></span><pre>		if isinstance( item, basestring ):</pre></div>
<div class="cov"><span class="num"><pre> 404</pre></span><pre>			nodenames.append( item )</pre></div>
<div class="cov"><span class="num"><pre> 405</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 406</pre></span><pre>			other.append( item )</pre></div>
<div class="skip"><span class="num"><pre> 407</pre></span><pre>		# END handel item type</pre></div>
<div class="skip"><span class="num"><pre> 408</pre></span><pre>	# END for each item</pre></div>
<div class="skip"><span class="num"><pre> 409</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 410</pre></span><pre>	if len( other ) == 1 and isinstance( other[0], api.MSelectionList ):</pre></div>
<div class="cov"><span class="num"><pre> 411</pre></span><pre>		other = other[0]</pre></div>
<div class="skip"><span class="num"><pre> 412</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 413</pre></span><pre>	sellist = toSelectionList( other )</pre></div>
<div class="skip"><span class="num"><pre> 414</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 415</pre></span><pre>	if nodenames:</pre></div>
<div class="cov"><span class="num"><pre> 416</pre></span><pre>		sellistnames = toSelectionListFromNames( nodenames )</pre></div>
<div class="cov"><span class="num"><pre> 417</pre></span><pre>		sellist.merge( sellistnames )</pre></div>
<div class="skip"><span class="num"><pre> 418</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 419</pre></span><pre>	adjustment = kwargs.get( &quot;listAdjustment&quot;, api.MGlobal.kReplaceList )</pre></div>
<div class="cov"><span class="num"><pre> 420</pre></span><pre>	api.MGlobal.selectCommand( sellist , adjustment )</pre></div>
<div class="skip"><span class="num"><pre> 421</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 422</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 423</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre> 424</pre></span><pre>def createNode( nodename, nodetype, autocreateNamespace=True, renameOnClash = True,</pre></div>
<div class="cov"><span class="num"><pre> 425</pre></span><pre>			     forceNewLeaf=True , maxShapesPerTransform = 0 ):</pre></div>
<div class="cov"><span class="num"><pre> 426</pre></span><pre>	&quot;&quot;&quot;Create a new node of nodetype with given nodename</pre></div>
<div class="skip"><span class="num"><pre> 427</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 428</pre></span><pre>	:param nodename: like ``mynode``or ``namespace:mynode`` or ``|parent|mynode`` or</pre></div>
<div class="cov"><span class="num"><pre> 429</pre></span><pre>		``|ns1:parent|ns1:ns2:parent|ns3:mynode``. The name may contain any amount of parents</pre></div>
<div class="cov"><span class="num"><pre> 430</pre></span><pre>		and/or namespaces.</pre></div>
<div class="cov"><span class="num"><pre> 431</pre></span><pre>	:note: For reasons of safety, dag nodes must use absolute paths like ``|parent|child`` -</pre></div>
<div class="cov"><span class="num"><pre> 432</pre></span><pre>		otherwise names might be ambiguous ! This method will assume absolute paths !</pre></div>
<div class="cov"><span class="num"><pre> 433</pre></span><pre>	:param nodetype: a nodetype known to maya to be created accordingly</pre></div>
<div class="cov"><span class="num"><pre> 434</pre></span><pre>	:param autocreateNamespace: if True, namespaces given in the nodename will be created</pre></div>
<div class="cov"><span class="num"><pre> 435</pre></span><pre>		if required</pre></div>
<div class="cov"><span class="num"><pre> 436</pre></span><pre>	:param renameOnClash: if True, nameclashes will automatcially be resolved by creating a unique</pre></div>
<div class="cov"><span class="num"><pre> 437</pre></span><pre>		name - this only happens if a dependency node has the same name as a dag node</pre></div>
<div class="cov"><span class="num"><pre> 438</pre></span><pre>	:param forceNewLeaf: if True, nodes will be created anyway if a node with the same name</pre></div>
<div class="cov"><span class="num"><pre> 439</pre></span><pre>		already exists - this will recreate the leaf portion of the given paths. Implies renameOnClash</pre></div>
<div class="cov"><span class="num"><pre> 440</pre></span><pre>		If False, you will receive an already existing node if the name and type matches.</pre></div>
<div class="cov"><span class="num"><pre> 441</pre></span><pre>	:param maxShapesPerTransform: only used when renameOnClash is True, defining the number of</pre></div>
<div class="cov"><span class="num"><pre> 442</pre></span><pre>		shapes you may have below a transform. If the number would be exeeded by the creation of</pre></div>
<div class="cov"><span class="num"><pre> 443</pre></span><pre>		a shape below a given transform, a new auto-renamed transform will be created automatically.</pre></div>
<div class="cov"><span class="num"><pre> 444</pre></span><pre>		This transform is garantueed to be new and will be used as new parent for the shape.</pre></div>
<div class="cov"><span class="num"><pre> 445</pre></span><pre>	:raise RuntimeError: If nodename contains namespaces or parents that may not be created</pre></div>
<div class="cov"><span class="num"><pre> 446</pre></span><pre>	:raise NameError: If name of desired node clashes as existing node has different type</pre></div>
<div class="cov"><span class="num"><pre> 447</pre></span><pre>	:note: As this method is checking a lot and tries to be smart, its relatively slow ( creates ~1200 nodes / s )</pre></div>
<div class="cov"><span class="num"><pre> 448</pre></span><pre>	:return: the newly create Node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 449</pre></span><pre>	if nodename in ( '|', '' ):</pre></div>
<div class="cov"><span class="num"><pre> 450</pre></span><pre>		raise RuntimeError( &quot;Cannot create '|' or ''&quot; )</pre></div>
<div class="skip"><span class="num"><pre> 451</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 452</pre></span><pre>	subpaths = nodename.split( '|' )</pre></div>
<div class="skip"><span class="num"><pre> 453</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 454</pre></span><pre>	parentnode = None</pre></div>
<div class="cov"><span class="num"><pre> 455</pre></span><pre>	createdNode = None</pre></div>
<div class="cov"><span class="num"><pre> 456</pre></span><pre>	lenSubpaths = len( subpaths )</pre></div>
<div class="cov"><span class="num"><pre> 457</pre></span><pre>	start_index = 1</pre></div>
<div class="skip"><span class="num"><pre> 458</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 459</pre></span><pre>	# SANITY CHECK ! Must use absolute dag paths</pre></div>
<div class="cov"><span class="num"><pre> 460</pre></span><pre>	if  nodename[0] != '|':</pre></div>
<div class="cov"><span class="num"><pre> 461</pre></span><pre>		nodename = &quot;|&quot; + nodename				# update with pipe</pre></div>
<div class="cov"><span class="num"><pre> 462</pre></span><pre>		subpaths.insert( 0, '' )</pre></div>
<div class="cov"><span class="num"><pre> 463</pre></span><pre>		lenSubpaths += 1</pre></div>
<div class="skip"><span class="num"><pre> 464</pre></span><pre>	# END special handling</pre></div>
<div class="skip"><span class="num"><pre> 465</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 466</pre></span><pre>	added_operation = False</pre></div>
<div class="cov"><span class="num"><pre> 467</pre></span><pre>	is_transform_type = nodetype == 'transform'</pre></div>
<div class="cov"><span class="num"><pre> 468</pre></span><pre>	is_shape = False</pre></div>
<div class="cov"><span class="num"><pre> 469</pre></span><pre>	if not is_transform_type and nodeTypeTree.has_node(nodetype):</pre></div>
<div class="cov"><span class="num"><pre> 470</pre></span><pre>		parents = list(nodeTypeTree.parent_iter(nodetype))</pre></div>
<div class="cov"><span class="num"><pre> 471</pre></span><pre>		is_transform_type = 'transform' in parents</pre></div>
<div class="cov"><span class="num"><pre> 472</pre></span><pre>		is_shape = 'shape' in parents</pre></div>
<div class="skip"><span class="num"><pre> 473</pre></span><pre>	# END do more intense inheritance query</pre></div>
<div class="skip"><span class="num"><pre> 474</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 475</pre></span><pre>	do_existence_checks = True</pre></div>
<div class="cov"><span class="num"><pre> 476</pre></span><pre>	dgmod = None</pre></div>
<div class="cov"><span class="num"><pre> 477</pre></span><pre>	dagmod = None</pre></div>
<div class="cov"><span class="num"><pre> 478</pre></span><pre>	for i in xrange( start_index, lenSubpaths ):						# first token always pipe, need absolute paths</pre></div>
<div class="cov"><span class="num"><pre> 479</pre></span><pre>		nodepartialname = '|'.join( subpaths[ 0 : i+1 ] )				# full path to the node so far</pre></div>
<div class="cov"><span class="num"><pre> 480</pre></span><pre>		is_last_iteration = i == lenSubpaths - 1</pre></div>
<div class="skip"><span class="num"><pre> 481</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 482</pre></span><pre>		# DAG ITEM EXISTS ?</pre></div>
<div class="skip"><span class="num"><pre> 483</pre></span><pre>		######################</pre></div>
<div class="skip"><span class="num"><pre> 484</pre></span><pre>		# if it doesn't exist the first time, we can save all other checks as we </pre></div>
<div class="skip"><span class="num"><pre> 485</pre></span><pre>		# will start creating it from now on</pre></div>
<div class="cov"><span class="num"><pre> 486</pre></span><pre>		if do_existence_checks:</pre></div>
<div class="cov"><span class="num"><pre> 487</pre></span><pre>			nodeapiobj = toApiobj( nodepartialname )</pre></div>
<div class="cov"><span class="num"><pre> 488</pre></span><pre>			if nodeapiobj is not None:</pre></div>
<div class="skip"><span class="num"><pre> 489</pre></span><pre>				# could be that the node already existed, but with an incorrect type</pre></div>
<div class="cov"><span class="num"><pre> 490</pre></span><pre>				if is_last_iteration:				# in the last iteration</pre></div>
<div class="cov"><span class="num"><pre> 491</pre></span><pre>					if not forceNewLeaf:</pre></div>
<div class="cov"><span class="num"><pre> 492</pre></span><pre>						parentnode = createdNode = nodeapiobj</pre></div>
<div class="cov"><span class="num"><pre> 493</pre></span><pre>						_mfndep_setobject(createdNode)</pre></div>
<div class="cov"><span class="num"><pre> 494</pre></span><pre>						existing_node_type = uncapitalize( _mfndep_typename() )</pre></div>
<div class="cov"><span class="num"><pre> 495</pre></span><pre>						nodetypecmp = uncapitalize( nodetype )</pre></div>
<div class="cov"><span class="num"><pre> 496</pre></span><pre>						if nodetypecmp != existing_node_type:</pre></div>
<div class="skip"><span class="num"><pre> 497</pre></span><pre>							# allow more specialized types, but not less specialized ones</pre></div>
<div class="cov"><span class="num"><pre> 498</pre></span><pre>							if nodetypecmp not in nodeTypeTree.parent_iter( existing_node_type ):</pre></div>
<div class="cov"><span class="num"><pre> 499</pre></span><pre>								msg = &quot;node %s did already exist, its type %s is incompatible with the requested type %s&quot; % ( nodepartialname, existing_node_type, nodetype )</pre></div>
<div class="cov"><span class="num"><pre> 500</pre></span><pre>								raise NameError( msg )</pre></div>
<div class="skip"><span class="num"><pre> 501</pre></span><pre>						# END nodetypes different</pre></div>
<div class="skip"><span class="num"><pre> 502</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 503</pre></span><pre>						continue</pre></div>
<div class="skip"><span class="num"><pre> 504</pre></span><pre>					# END force new leaf handling</pre></div>
<div class="cov"><span class="num"><pre> 505</pre></span><pre>					else:</pre></div>
<div class="skip"><span class="num"><pre> 506</pre></span><pre>						# just go ahead, but create a new node</pre></div>
<div class="cov"><span class="num"><pre> 507</pre></span><pre>						renameOnClash = True		# allow clashes and rename</pre></div>
<div class="skip"><span class="num"><pre> 508</pre></span><pre>				# END leaf path handling</pre></div>
<div class="cov"><span class="num"><pre> 509</pre></span><pre>				else:</pre></div>
<div class="skip"><span class="num"><pre> 510</pre></span><pre>					# remember what we have done so far and continue</pre></div>
<div class="cov"><span class="num"><pre> 511</pre></span><pre>					parentnode = createdNode = nodeapiobj</pre></div>
<div class="cov"><span class="num"><pre> 512</pre></span><pre>					continue</pre></div>
<div class="cov"><span class="num"><pre> 513</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre> 514</pre></span><pre>				do_existence_checks = False</pre></div>
<div class="skip"><span class="num"><pre> 515</pre></span><pre>			# END node item exists handling</pre></div>
<div class="skip"><span class="num"><pre> 516</pre></span><pre>		# END do existence checks</pre></div>
<div class="skip"><span class="num"><pre> 517</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre> 518</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 519</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 520</pre></span><pre>		# it does not exist, check the namespace</pre></div>
<div class="cov"><span class="num"><pre> 521</pre></span><pre>		dagtoken = '|'.join( subpaths[ i : i+1 ] )</pre></div>
<div class="skip"><span class="num"><pre> 522</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 523</pre></span><pre>		if autocreateNamespace:</pre></div>
<div class="cov"><span class="num"><pre> 524</pre></span><pre>			nsm.createNamespace( &quot;:&quot;.join( dagtoken.split( &quot;:&quot; )[0:-1] ) )	# will resolve to root namespace at least</pre></div>
<div class="skip"><span class="num"><pre> 525</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 526</pre></span><pre>		# see whether we have to create a transform or the actual nodetype</pre></div>
<div class="cov"><span class="num"><pre> 527</pre></span><pre>		actualtype = &quot;transform&quot;</pre></div>
<div class="cov"><span class="num"><pre> 528</pre></span><pre>		if is_last_iteration:</pre></div>
<div class="cov"><span class="num"><pre> 529</pre></span><pre>			actualtype = nodetype</pre></div>
<div class="skip"><span class="num"><pre> 530</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 531</pre></span><pre>		# create the node - either with or without parent</pre></div>
<div class="skip"><span class="num"><pre> 532</pre></span><pre>		# The actual node needs to be created with a matching modifier, dag nodes</pre></div>
<div class="skip"><span class="num"><pre> 533</pre></span><pre>		# with the DagMofier, dg nodes with the dg modifier</pre></div>
<div class="skip"><span class="num"><pre> 534</pre></span><pre>		# The user currently has to specify a proper path.</pre></div>
<div class="cov"><span class="num"><pre> 535</pre></span><pre>		if parentnode or actualtype == &quot;transform&quot; or (is_last_iteration and is_transform_type):</pre></div>
<div class="cov"><span class="num"><pre> 536</pre></span><pre>			if dagmod is None:</pre></div>
<div class="cov"><span class="num"><pre> 537</pre></span><pre>				dagmod = api.MDagModifier()</pre></div>
<div class="skip"><span class="num"><pre> 538</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre> 539</pre></span><pre>			# create dag node</pre></div>
<div class="cov"><span class="num"><pre> 540</pre></span><pre>			newapiobj = None</pre></div>
<div class="cov"><span class="num"><pre> 541</pre></span><pre>			if parentnode:		# use parent</pre></div>
<div class="cov"><span class="num"><pre> 542</pre></span><pre>				newapiobj = dagmod.createNode( actualtype, parentnode )		# create with parent</pre></div>
<div class="cov"><span class="num"><pre> 543</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre> 544</pre></span><pre>				newapiobj = dagmod.createNode( actualtype )							# create</pre></div>
<div class="skip"><span class="num"><pre> 545</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 546</pre></span><pre>			dagmod.renameNode( newapiobj, dagtoken )									# rename</pre></div>
<div class="skip"><span class="num"><pre> 547</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 548</pre></span><pre>			parentnode = createdNode = newapiobj				# update parent</pre></div>
<div class="cov"><span class="num"><pre> 549</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 550</pre></span><pre>			if dgmod is None:</pre></div>
<div class="cov"><span class="num"><pre> 551</pre></span><pre>				dgmod = api.MDGModifier()</pre></div>
<div class="skip"><span class="num"><pre> 552</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre> 553</pre></span><pre>			# create dg node - really have to check for clashes afterwards</pre></div>
<div class="skip"><span class="num"><pre> 554</pre></span><pre>			# It may also be that the user passed in a name which didn't </pre></div>
<div class="skip"><span class="num"><pre> 555</pre></span><pre>			# show that we want a dag node - hence we have to check for failure</pre></div>
<div class="skip"><span class="num"><pre> 556</pre></span><pre>			# and recover</pre></div>
<div class="cov"><span class="num"><pre> 557</pre></span><pre>			mod = dgmod</pre></div>
<div class="cov"><span class="num"><pre> 558</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 559</pre></span><pre>				newapiobj = dgmod.createNode( actualtype )								# create</pre></div>
<div class="cov"><span class="num"><pre> 560</pre></span><pre>			except RuntimeError:</pre></div>
<div class="cov"><span class="num"><pre> 561</pre></span><pre>				if dagmod is None:</pre></div>
<div class="cov"><span class="num"><pre> 562</pre></span><pre>					dagmod = api.MDagModifier()</pre></div>
<div class="cov"><span class="num"><pre> 563</pre></span><pre>				mod = dagmod</pre></div>
<div class="skip"><span class="num"><pre> 564</pre></span><pre>				# even though it could be a transform derived type which can be </pre></div>
<div class="skip"><span class="num"><pre> 565</pre></span><pre>				# created right away without an explicit parent, we don't know that, </pre></div>
<div class="skip"><span class="num"><pre> 566</pre></span><pre>				# if we would know, we wouldn't be here.</pre></div>
<div class="skip"><span class="num"><pre> 567</pre></span><pre>				# In case its not transform derived, a parent node would be created</pre></div>
<div class="skip"><span class="num"><pre> 568</pre></span><pre>				# automatically. Problem is that this node is returned instead of </pre></div>
<div class="skip"><span class="num"><pre> 569</pre></span><pre>				# the node we requested ( logic bug if you ask me ! ), and we don't </pre></div>
<div class="skip"><span class="num"><pre> 570</pre></span><pre>				# want to return a node type the caller didn't order.</pre></div>
<div class="skip"><span class="num"><pre> 571</pre></span><pre>				# This is why we explicitly create a transform, to have the parent </pre></div>
<div class="skip"><span class="num"><pre> 572</pre></span><pre>				# under our control. This will put even a transform derived type</pre></div>
<div class="skip"><span class="num"><pre> 573</pre></span><pre>				# under an extra transform, which in that case would not be required.</pre></div>
<div class="skip"><span class="num"><pre> 574</pre></span><pre>				# But here we are, and it cannot be helped.</pre></div>
<div class="cov"><span class="num"><pre> 575</pre></span><pre>				if is_shape:</pre></div>
<div class="cov"><span class="num"><pre> 576</pre></span><pre>					trans = dagmod.createNode(&quot;transform&quot;)</pre></div>
<div class="cov"><span class="num"><pre> 577</pre></span><pre>					newapiobj = dagmod.createNode(actualtype, trans)</pre></div>
<div class="nocov"><span class="num"><pre> 578</pre></span><pre>				else:</pre></div>
<div class="nocov"><span class="num"><pre> 579</pre></span><pre>					newapiobj = dagmod.createNode(actualtype)</pre></div>
<div class="skip"><span class="num"><pre> 580</pre></span><pre>				# END shape handling</pre></div>
<div class="skip"><span class="num"><pre> 581</pre></span><pre>			# END handle dag node</pre></div>
<div class="cov"><span class="num"><pre> 582</pre></span><pre>			mod.renameNode( newapiobj, dagtoken )									# rename</pre></div>
<div class="cov"><span class="num"><pre> 583</pre></span><pre>			createdNode = newapiobj</pre></div>
<div class="skip"><span class="num"><pre> 584</pre></span><pre>		# END (partial) node creation</pre></div>
<div class="skip"><span class="num"><pre> 585</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 586</pre></span><pre>		# CLASHING CHECK ( and name update ) !</pre></div>
<div class="skip"><span class="num"><pre> 587</pre></span><pre>		# PROBLEM: if a dep node with name of dagtoken already exists, it will</pre></div>
<div class="skip"><span class="num"><pre> 588</pre></span><pre>		# rename the newly created (sub) node although it is not the same !</pre></div>
<div class="cov"><span class="num"><pre> 589</pre></span><pre>		_mfndep_setobject( newapiobj )</pre></div>
<div class="cov"><span class="num"><pre> 590</pre></span><pre>		actualname = _mfndep_name()</pre></div>
<div class="cov"><span class="num"><pre> 591</pre></span><pre>		if actualname != dagtoken:</pre></div>
<div class="skip"><span class="num"><pre> 592</pre></span><pre>			# Is it a renamed node because because a dep node of the same name existed ?</pre></div>
<div class="skip"><span class="num"><pre> 593</pre></span><pre>			# Could be that a child of the same name existed too</pre></div>
<div class="cov"><span class="num"><pre> 594</pre></span><pre>			if not renameOnClash:</pre></div>
<div class="cov"><span class="num"><pre> 595</pre></span><pre>				msg = &quot;named %s did already exist - cannot create a dag node with same name due to maya limitation&quot; % nodepartialname</pre></div>
<div class="cov"><span class="num"><pre> 596</pre></span><pre>				raise NameError( msg )</pre></div>
<div class="cov"><span class="num"><pre> 597</pre></span><pre>			else:</pre></div>
<div class="skip"><span class="num"><pre> 598</pre></span><pre>				# update the tokens and use the new path</pre></div>
<div class="cov"><span class="num"><pre> 599</pre></span><pre>				subpaths[ i ] =  actualname</pre></div>
<div class="cov"><span class="num"><pre> 600</pre></span><pre>				nodepartialname = '|'.join( subpaths[ 0 : i+1 ] )</pre></div>
<div class="skip"><span class="num"><pre> 601</pre></span><pre>		# END dag token renamed</pre></div>
<div class="skip"><span class="num"><pre> 602</pre></span><pre>	# END for each partial path</pre></div>
<div class="skip"><span class="num"><pre> 603</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 604</pre></span><pre>	# add the modifiers to the undo stack</pre></div>
<div class="cov"><span class="num"><pre> 605</pre></span><pre>	op = undo.GenericOperationStack()</pre></div>
<div class="cov"><span class="num"><pre> 606</pre></span><pre>	if dgmod is not None:</pre></div>
<div class="cov"><span class="num"><pre> 607</pre></span><pre>		op.addCmd(dgmod.doIt, dgmod.undoIt)</pre></div>
<div class="cov"><span class="num"><pre> 608</pre></span><pre>	if dagmod is not None:</pre></div>
<div class="cov"><span class="num"><pre> 609</pre></span><pre>		op.addCmd(dagmod.doIt, dagmod.undoIt)</pre></div>
<div class="cov"><span class="num"><pre> 610</pre></span><pre>	op.doIt()</pre></div>
<div class="skip"><span class="num"><pre> 611</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 612</pre></span><pre>	if createdNode is None:</pre></div>
<div class="nocov"><span class="num"><pre> 613</pre></span><pre>		raise RuntimeError( &quot;Failed to create %s ( %s )&quot; % ( nodename, nodetype ) )</pre></div>
<div class="skip"><span class="num"><pre> 614</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 615</pre></span><pre>	return NodeFromObj( createdNode )</pre></div>
<div class="skip"><span class="num"><pre> 616</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 617</pre></span><pre>#} END base</pre></div>
<div class="skip"><span class="num"><pre> 618</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 619</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 620</pre></span><pre>def _checkedInstanceCreationDagPathSupport( mobject_or_mdagpath, clsToBeCreated, basecls ):</pre></div>
<div class="cov"><span class="num"><pre> 621</pre></span><pre>	&quot;&quot;&quot;Same purpose and attribtues as `_checkedInstanceCreation`, but supports</pre></div>
<div class="cov"><span class="num"><pre> 622</pre></span><pre>	dagPaths as input as well&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 623</pre></span><pre>	apiobj = mobject_or_mdagpath</pre></div>
<div class="cov"><span class="num"><pre> 624</pre></span><pre>	dagpath = None</pre></div>
<div class="cov"><span class="num"><pre> 625</pre></span><pre>	if isinstance( mobject_or_mdagpath, MDagPath ):</pre></div>
<div class="cov"><span class="num"><pre> 626</pre></span><pre>		dagpath = mobject_or_mdagpath</pre></div>
<div class="skip"><span class="num"><pre> 627</pre></span><pre>	# END if we have a dag path</pre></div>
<div class="skip"><span class="num"><pre> 628</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 629</pre></span><pre>	clsinstance = _checkedInstanceCreation( mobject_or_mdagpath, _lookup_type(mobject_or_mdagpath), clsToBeCreated, basecls )</pre></div>
<div class="cov"><span class="num"><pre> 630</pre></span><pre>	if isinstance( clsinstance, DagNode ):</pre></div>
<div class="cov"><span class="num"><pre> 631</pre></span><pre>		_setupDagNodeDelayedMethods( clsinstance, apiobj, dagpath )</pre></div>
<div class="skip"><span class="num"><pre> 632</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 633</pre></span><pre>	return clsinstance</pre></div>
<div class="skip"><span class="num"><pre> 634</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 635</pre></span><pre>def _checkedInstanceCreation( apiobj, typeName, clsToBeCreated, basecls ):</pre></div>
<div class="cov"><span class="num"><pre> 636</pre></span><pre>	&quot;&quot;&quot;Utiliy method creating a new class instance according to additional type information</pre></div>
<div class="cov"><span class="num"><pre> 637</pre></span><pre>	Its used by __new__ constructors to finalize class creation</pre></div>
<div class="skip"><span class="num"><pre> 638</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 639</pre></span><pre>	:param apiobj: the MObject or MDagPath of object to wrap</pre></div>
<div class="cov"><span class="num"><pre> 640</pre></span><pre>	:param typeName: the name of the node type to be created</pre></div>
<div class="cov"><span class="num"><pre> 641</pre></span><pre>	:param clsToBeCreated: the cls object as passed in to __new__</pre></div>
<div class="cov"><span class="num"><pre> 642</pre></span><pre>	:param basecls: the class of the caller containing the __new__ method</pre></div>
<div class="cov"><span class="num"><pre> 643</pre></span><pre>	:return: create clsinstance if the proper type ( according to nodeTypeTree )&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 644</pre></span><pre>	# get the node type class for the api type object</pre></div>
<div class="skip"><span class="num"><pre> 645</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 646</pre></span><pre>	nodeTypeCls = nodeTypeToNodeTypeCls( typeName, apiobj )</pre></div>
<div class="skip"><span class="num"><pre> 647</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 648</pre></span><pre>	# NON-MAYA NODE Type</pre></div>
<div class="skip"><span class="num"><pre> 649</pre></span><pre>	# if an explicit type was requested, assure we are at least compatible with</pre></div>
<div class="skip"><span class="num"><pre> 650</pre></span><pre>	# the given cls type - our node type is supposed to be the most specialized one</pre></div>
<div class="skip"><span class="num"><pre> 651</pre></span><pre>	# cls is either of the same type as ours, or is a superclass.</pre></div>
<div class="skip"><span class="num"><pre> 652</pre></span><pre>	# It is also okay if the user provided a class which is a subclass of the most </pre></div>
<div class="skip"><span class="num"><pre> 653</pre></span><pre>	# suitable class we know, which acts like a virtal specialization</pre></div>
<div class="cov"><span class="num"><pre> 654</pre></span><pre>	if clsToBeCreated is not basecls and clsToBeCreated is not nodeTypeCls:</pre></div>
<div class="cov"><span class="num"><pre> 655</pre></span><pre>		vclass_attr = '__mrv_virtual_subtype__'</pre></div>
<div class="skip"><span class="num"><pre> 656</pre></span><pre>		# If the class is a virtual subtype and indeed a subclass of our best known type,  </pre></div>
<div class="skip"><span class="num"><pre> 657</pre></span><pre>		# its a valid class</pre></div>
<div class="cov"><span class="num"><pre> 658</pre></span><pre>		if not issubclass( nodeTypeCls, clsToBeCreated ) and \</pre></div>
<div class="cov"><span class="num"><pre> 659</pre></span><pre>			not ( hasattr(clsToBeCreated, vclass_attr) and issubclass(clsToBeCreated, nodeTypeCls) ):</pre></div>
<div class="cov"><span class="num"><pre> 660</pre></span><pre>			raise TypeError( &quot;Explicit class %r must be %r or a superclass of it. Consider setting the %s attribute to indicate you are a virtual subtype.&quot; % ( clsToBeCreated, nodeTypeCls, vclass_attr ) )</pre></div>
<div class="cov"><span class="num"><pre> 661</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 662</pre></span><pre>			nodeTypeCls = clsToBeCreated						# respect the wish of the client</pre></div>
<div class="skip"><span class="num"><pre> 663</pre></span><pre>	# END if explicit class given</pre></div>
<div class="skip"><span class="num"><pre> 664</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 665</pre></span><pre>	# FINISH INSTANCE</pre></div>
<div class="skip"><span class="num"><pre> 666</pre></span><pre>	# At this point, we only support type as we expect ourselves to be lowlevel</pre></div>
<div class="cov"><span class="num"><pre> 667</pre></span><pre>	clsinstance = object.__new__( nodeTypeCls )</pre></div>
<div class="skip"><span class="num"><pre> 668</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 669</pre></span><pre>	object.__setattr__( clsinstance, '_apiobj',  apiobj )</pre></div>
<div class="cov"><span class="num"><pre> 670</pre></span><pre>	return clsinstance</pre></div>
<div class="skip"><span class="num"><pre> 671</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 672</pre></span><pre>def _setupDagNodeDelayedMethods( dagnode, mobject, mdagpath ):</pre></div>
<div class="cov"><span class="num"><pre> 673</pre></span><pre>	&quot;&quot;&quot;Setup the given dagnode with the instance methods it needs to handle the gven </pre></div>
<div class="cov"><span class="num"><pre> 674</pre></span><pre>	mobject OR mdagpath accordingly, one of them may be None&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 675</pre></span><pre>	instcls = type(dagnode)</pre></div>
<div class="cov"><span class="num"><pre> 676</pre></span><pre>	if mdagpath is None:</pre></div>
<div class="skip"><span class="num"><pre> 677</pre></span><pre>		# next time the MDagPath is accessed, we retrieve it from the MObject</pre></div>
<div class="cov"><span class="num"><pre> 678</pre></span><pre>		object.__setattr__(dagnode, 'dagPath', instancemethod(instcls._dagPath_delayed, dagnode, instcls))</pre></div>
<div class="cov"><span class="num"><pre> 679</pre></span><pre>		object.__setattr__(dagnode, 'object', instancemethod(instcls._object_cached, dagnode, instcls))</pre></div>
<div class="cov"><span class="num"><pre> 680</pre></span><pre>	else:</pre></div>
<div class="skip"><span class="num"><pre> 681</pre></span><pre>		# MObject has to be retrieved on demand</pre></div>
<div class="skip"><span class="num"><pre> 682</pre></span><pre>		# this is the default</pre></div>
<div class="cov"><span class="num"><pre> 683</pre></span><pre>		object.__setattr__( dagnode, '_apidagpath', mdagpath )</pre></div>
<div class="skip"><span class="num"><pre> 684</pre></span><pre>	# END handle missing MDagPath or MObject</pre></div>
<div class="skip"><span class="num"><pre> 685</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 686</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 687</pre></span><pre>def _createInstByPredicate( apiobj, cls, basecls, predicate ):</pre></div>
<div class="cov"><span class="num"><pre> 688</pre></span><pre>	&quot;&quot;&quot;Allows to wrap objects around MObjects where the actual compatabilty</pre></div>
<div class="cov"><span class="num"><pre> 689</pre></span><pre>	cannot be determined by some nodetypename, but by the function set itself.</pre></div>
<div class="cov"><span class="num"><pre> 690</pre></span><pre>	Thus it uses the nodeTypeToMfnClsMap to get mfn cls for testing</pre></div>
<div class="skip"><span class="num"><pre> 691</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 692</pre></span><pre>	:param cls: the class to be created</pre></div>
<div class="cov"><span class="num"><pre> 693</pre></span><pre>	:param basecls: the class where __new__ has actually been called</pre></div>
<div class="cov"><span class="num"><pre> 694</pre></span><pre>	:param predicate: returns true if the given nodetypename is valid, and its mfn</pre></div>
<div class="cov"><span class="num"><pre> 695</pre></span><pre>		should be taken for tests</pre></div>
<div class="cov"><span class="num"><pre> 696</pre></span><pre>	:return: new class instance, or None if no mfn matched the apiobject&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 697</pre></span><pre>	# try which node type fits</pre></div>
<div class="skip"><span class="num"><pre> 698</pre></span><pre>	# All attribute instances end with attribute</pre></div>
<div class="skip"><span class="num"><pre> 699</pre></span><pre>	# NOTE: the capital case 'A' assure we do not get this base class as option - this would</pre></div>
<div class="skip"><span class="num"><pre> 700</pre></span><pre>	# be bad as it is compatible with all classes</pre></div>
<div class="cov"><span class="num"><pre> 701</pre></span><pre>	attrtypekeys = [ a for a in nodeTypeToMfnClsMap.keys() if predicate( a ) ]</pre></div>
<div class="skip"><span class="num"><pre> 702</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 703</pre></span><pre>	for attrtype in attrtypekeys:</pre></div>
<div class="cov"><span class="num"><pre> 704</pre></span><pre>		attrmfncls = nodeTypeToMfnClsMap[ attrtype ]</pre></div>
<div class="cov"><span class="num"><pre> 705</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 706</pre></span><pre>			mfn = attrmfncls( apiobj )</pre></div>
<div class="cov"><span class="num"><pre> 707</pre></span><pre>		except RuntimeError:</pre></div>
<div class="cov"><span class="num"><pre> 708</pre></span><pre>			continue</pre></div>
<div class="cov"><span class="num"><pre> 709</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 710</pre></span><pre>			newinst = _checkedInstanceCreation( apiobj, attrtype, cls, basecls )		# lookup in node tree</pre></div>
<div class="cov"><span class="num"><pre> 711</pre></span><pre>			return newinst</pre></div>
<div class="skip"><span class="num"><pre> 712</pre></span><pre>	# END for each known attr type</pre></div>
<div class="nocov"><span class="num"><pre> 713</pre></span><pre>	return None</pre></div>
<div class="skip"><span class="num"><pre> 714</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 715</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 716</pre></span><pre>def _getUniqueName( dagpath ):</pre></div>
<div class="cov"><span class="num"><pre> 717</pre></span><pre>	&quot;&quot;&quot;Create a unique name based on the given dagpath by appending numbers&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 718</pre></span><pre>	copynumber = 1</pre></div>
<div class="cov"><span class="num"><pre> 719</pre></span><pre>	newpath = str( dagpath )</pre></div>
<div class="cov"><span class="num"><pre> 720</pre></span><pre>	while cmds.objExists( newpath ):</pre></div>
<div class="cov"><span class="num"><pre> 721</pre></span><pre>		newpath = &quot;%s%i&quot; % ( dagpath, copynumber )</pre></div>
<div class="cov"><span class="num"><pre> 722</pre></span><pre>		copynumber += 1</pre></div>
<div class="skip"><span class="num"><pre> 723</pre></span><pre>	# END while dagpath does exist</pre></div>
<div class="cov"><span class="num"><pre> 724</pre></span><pre>	return newpath</pre></div>
<div class="skip"><span class="num"><pre> 725</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 726</pre></span><pre>############################</pre></div>
<div class="skip"><span class="num"><pre> 727</pre></span><pre>#### Classes		  	####</pre></div>
<div class="skip"><span class="num"><pre> 728</pre></span><pre>##########################</pre></div>
<div class="skip"><span class="num"><pre> 729</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 730</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 731</pre></span><pre>#{ Utilities</pre></div>
<div class="cov"><span class="num"><pre> 732</pre></span><pre>class SetFilter( tuple ):</pre></div>
<div class="cov"><span class="num"><pre> 733</pre></span><pre>	&quot;&quot;&quot;Utility Class  returning True or False on call, latter one if</pre></div>
<div class="cov"><span class="num"><pre> 734</pre></span><pre>	the passed object does not match the filter&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 735</pre></span><pre>	def __new__( cls, apitype, exactTypeFlag, deformerSet ):</pre></div>
<div class="cov"><span class="num"><pre> 736</pre></span><pre>		return tuple.__new__( cls, ( apitype, exactTypeFlag, deformerSet ) )</pre></div>
<div class="skip"><span class="num"><pre> 737</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 738</pre></span><pre>	def __call__( self, apiobj ):</pre></div>
<div class="cov"><span class="num"><pre> 739</pre></span><pre>		&quot;&quot;&quot;:return: True if given api object matches our specifications &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 740</pre></span><pre>		if self[ 2 ]:			# deformer sets</pre></div>
<div class="cov"><span class="num"><pre> 741</pre></span><pre>			setnode = NodeFromObj( apiobj )</pre></div>
<div class="cov"><span class="num"><pre> 742</pre></span><pre>			for elmplug in setnode.usedBy:	# find connected deformer</pre></div>
<div class="cov"><span class="num"><pre> 743</pre></span><pre>				iplug = elmplug.minput()</pre></div>
<div class="cov"><span class="num"><pre> 744</pre></span><pre>				if iplug.isNull():</pre></div>
<div class="nocov"><span class="num"><pre> 745</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre> 746</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 747</pre></span><pre>				if iplug.node().hasFn( api.MFn.kGeometryFilt ):</pre></div>
<div class="cov"><span class="num"><pre> 748</pre></span><pre>					return True</pre></div>
<div class="skip"><span class="num"><pre> 749</pre></span><pre>			# END for each connected plug in usedBy array</pre></div>
<div class="skip"><span class="num"><pre> 750</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 751</pre></span><pre>			return False		# no deformer found</pre></div>
<div class="skip"><span class="num"><pre> 752</pre></span><pre>		# deformer set handling</pre></div>
<div class="skip"><span class="num"><pre> 753</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 754</pre></span><pre>		if self[ 1 ]:			# exact type</pre></div>
<div class="cov"><span class="num"><pre> 755</pre></span><pre>			return apiobj.apiType() == self[ 0 ]</pre></div>
<div class="skip"><span class="num"><pre> 756</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 757</pre></span><pre>		# not exact type</pre></div>
<div class="cov"><span class="num"><pre> 758</pre></span><pre>		return apiobj.hasFn( self[ 0 ] )</pre></div>
<div class="skip"><span class="num"><pre> 759</pre></span><pre>	# END SetFilter</pre></div>
<div class="skip"><span class="num"><pre> 760</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 761</pre></span><pre>#} END utilities</pre></div>
<div class="skip"><span class="num"><pre> 762</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 763</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 764</pre></span><pre>#{ Base</pre></div>
<div class="skip"><span class="num"><pre> 765</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 766</pre></span><pre>class Node( object ):</pre></div>
<div class="cov"><span class="num"><pre> 767</pre></span><pre>	&quot;&quot;&quot;Common base for all maya nodes, providing access to the maya internal object</pre></div>
<div class="cov"><span class="num"><pre> 768</pre></span><pre>	representation</pre></div>
<div class="cov"><span class="num"><pre> 769</pre></span><pre>	Use this class to directly create a maya node of the required type&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 770</pre></span><pre>	__metaclass__ = MetaClassCreatorNodes</pre></div>
<div class="cov"><span class="num"><pre> 771</pre></span><pre>	__api_type_tuple = ( MObject, MDagPath )</pre></div>
<div class="skip"><span class="num"><pre> 772</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 773</pre></span><pre>	def __new__ ( cls, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 774</pre></span><pre>		&quot;&quot;&quot;return the proper class for the given object</pre></div>
<div class="skip"><span class="num"><pre> 775</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 776</pre></span><pre>		:param args: arg[0] is the node to be wrapped</pre></div>
<div class="skip"><span class="num"><pre> 777</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 778</pre></span><pre>			 * string: wrap the API object with the respective name</pre></div>
<div class="cov"><span class="num"><pre> 779</pre></span><pre>			 * MObject</pre></div>
<div class="cov"><span class="num"><pre> 780</pre></span><pre>			 * MObjectHandle</pre></div>
<div class="cov"><span class="num"><pre> 781</pre></span><pre>			 * MDagPath</pre></div>
<div class="skip"><span class="num"><pre> 782</pre></span><pre>			 </pre></div>
<div class="cov"><span class="num"><pre> 783</pre></span><pre>			If args is empty, a new node of the given type will be created within</pre></div>
<div class="cov"><span class="num"><pre> 784</pre></span><pre>			maya. Shapes will automatically receive a parent transform. </pre></div>
<div class="cov"><span class="num"><pre> 785</pre></span><pre>			kwargs will be passed to `createNode` in that case.</pre></div>
<div class="cov"><span class="num"><pre> 786</pre></span><pre>		:note: This multi-purpose constructor is not perfectly optimized for speed, </pre></div>
<div class="cov"><span class="num"><pre> 787</pre></span><pre>			consider using `NodeFromObj` instead&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 788</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 789</pre></span><pre>		if not args:</pre></div>
<div class="cov"><span class="num"><pre> 790</pre></span><pre>			if not issubclass(cls, DependNode): # cls can be DependNode as well</pre></div>
<div class="cov"><span class="num"><pre> 791</pre></span><pre>				raise TypeError(&quot;Can only create types being subclasses of Node, not %r&quot; % cls)</pre></div>
<div class="skip"><span class="num"><pre> 792</pre></span><pre>			# END handle invalid class</pre></div>
<div class="skip"><span class="num"><pre> 793</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 794</pre></span><pre>			typename = uncapitalize(cls.__name__)</pre></div>
<div class="cov"><span class="num"><pre> 795</pre></span><pre>			instname = typename</pre></div>
<div class="cov"><span class="num"><pre> 796</pre></span><pre>			if issubclass(cls, Shape):	# cls can be DagNode as well</pre></div>
<div class="cov"><span class="num"><pre> 797</pre></span><pre>				instname = &quot;%s|%sShape&quot; % (instname, instname)</pre></div>
<div class="skip"><span class="num"><pre> 798</pre></span><pre>			# END handle dag objects</pre></div>
<div class="skip"><span class="num"><pre> 799</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 800</pre></span><pre>			return createNode( instname, typename, **kwargs)</pre></div>
<div class="skip"><span class="num"><pre> 801</pre></span><pre>		# END handle creation mode</pre></div>
<div class="skip"><span class="num"><pre> 802</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 803</pre></span><pre>		objorname = args[0]</pre></div>
<div class="cov"><span class="num"><pre> 804</pre></span><pre>		mobject_or_mdagpath = None</pre></div>
<div class="skip"><span class="num"><pre> 805</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 806</pre></span><pre>		# GET AN API OBJECT</pre></div>
<div class="cov"><span class="num"><pre> 807</pre></span><pre>		if isinstance( objorname, cls.__api_type_tuple ):</pre></div>
<div class="cov"><span class="num"><pre> 808</pre></span><pre>			mobject_or_mdagpath = objorname</pre></div>
<div class="cov"><span class="num"><pre> 809</pre></span><pre>		elif isinstance( objorname, basestring ):</pre></div>
<div class="cov"><span class="num"><pre> 810</pre></span><pre>			if objorname.find( '.' ) != -1:</pre></div>
<div class="nocov"><span class="num"><pre> 811</pre></span><pre>				raise ValueError( &quot;%s cannot be handled - create a node, then access its attribute like Node('name').attr&quot; % objorname )</pre></div>
<div class="cov"><span class="num"><pre> 812</pre></span><pre>			mobject_or_mdagpath = toApiobjOrDagPath( objorname )</pre></div>
<div class="cov"><span class="num"><pre> 813</pre></span><pre>		elif isinstance( objorname, MObjectHandle ):</pre></div>
<div class="nocov"><span class="num"><pre> 814</pre></span><pre>			mobject_or_mdagpath = objorname.object()</pre></div>
<div class="cov"><span class="num"><pre> 815</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 816</pre></span><pre>			raise TypeError( &quot;Objects of type %s cannot be handled&quot; % type( objorname ) )</pre></div>
<div class="skip"><span class="num"><pre> 817</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 818</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 819</pre></span><pre>		skip_checks = ( len( args ) &gt; 1 and args[1] ) or False</pre></div>
<div class="cov"><span class="num"><pre> 820</pre></span><pre>		if ( not skip_checks and ( mobject_or_mdagpath is None</pre></div>
<div class="cov"><span class="num"><pre> 821</pre></span><pre>			or ( isinstance( mobject_or_mdagpath, MDagPath ) and not mobject_or_mdagpath.isValid() )</pre></div>
<div class="cov"><span class="num"><pre> 822</pre></span><pre>			or ( isinstance( mobject_or_mdagpath, MObject ) and mobject_or_mdagpath.isNull() ) ) ):</pre></div>
<div class="cov"><span class="num"><pre> 823</pre></span><pre>			raise ValueError( &quot;object does not exist: %s&quot; % objorname )</pre></div>
<div class="skip"><span class="num"><pre> 824</pre></span><pre>		# END evil validity checking</pre></div>
<div class="skip"><span class="num"><pre> 825</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 826</pre></span><pre>		# CREATE INSTANCE</pre></div>
<div class="cov"><span class="num"><pre> 827</pre></span><pre>		return _checkedInstanceCreationDagPathSupport( mobject_or_mdagpath, cls, Node )</pre></div>
<div class="skip"><span class="num"><pre> 828</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 829</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 830</pre></span><pre>	#{ Overridden Methods</pre></div>
<div class="cov"><span class="num"><pre> 831</pre></span><pre>	def __eq__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre> 832</pre></span><pre>		&quot;&quot;&quot;compare the nodes according to their api object.</pre></div>
<div class="cov"><span class="num"><pre> 833</pre></span><pre>		Valid inputs are other Node, MObject or MDagPath instances&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 834</pre></span><pre>		otherapiobj = None</pre></div>
<div class="cov"><span class="num"><pre> 835</pre></span><pre>		if not isinstance( other, Node ):</pre></div>
<div class="cov"><span class="num"><pre> 836</pre></span><pre>			otherapiobj = NodeFromObj(other).object()</pre></div>
<div class="cov"><span class="num"><pre> 837</pre></span><pre>		else: # assume Node</pre></div>
<div class="cov"><span class="num"><pre> 838</pre></span><pre>			otherapiobj = other.object()</pre></div>
<div class="skip"><span class="num"><pre> 839</pre></span><pre>		# END handle types</pre></div>
<div class="skip"><span class="num"><pre> 840</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 841</pre></span><pre>		return self.object() == otherapiobj		# does not appear to work as expected ...</pre></div>
<div class="skip"><span class="num"><pre> 842</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 843</pre></span><pre>	def __ne__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre> 844</pre></span><pre>		return not Node.__eq__( self, other )</pre></div>
<div class="skip"><span class="num"><pre> 845</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 846</pre></span><pre>	def __hash__( self ):</pre></div>
<div class="cov"><span class="num"><pre> 847</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 848</pre></span><pre>		:return: our name as hash - as python keeps a pool, each name will</pre></div>
<div class="cov"><span class="num"><pre> 849</pre></span><pre>			correspond to the exact object.</pre></div>
<div class="cov"><span class="num"><pre> 850</pre></span><pre>		:note: using asHashable of openMayaMPx did not work as it returns addresses</pre></div>
<div class="cov"><span class="num"><pre> 851</pre></span><pre>			to instances - this does not work for MObjects though</pre></div>
<div class="cov"><span class="num"><pre> 852</pre></span><pre>		:note: in maya2009 and newer, MObjectHandle.hashCode provides the information </pre></div>
<div class="cov"><span class="num"><pre> 853</pre></span><pre>			we need, faster&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 854</pre></span><pre>		return hash(str(self))</pre></div>
<div class="skip"><span class="num"><pre> 855</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 856</pre></span><pre>	if hasattr(api.MObjectHandle, 'hashCode'):</pre></div>
<div class="cov"><span class="num"><pre> 857</pre></span><pre>		def __hash_2009__(self):</pre></div>
<div class="cov"><span class="num"><pre> 858</pre></span><pre>			&quot;&quot;&quot;:return: hash of our object using MObjectHandle functionlity&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 859</pre></span><pre>			return MObjectHandle(self.object()).hashCode()</pre></div>
<div class="skip"><span class="num"><pre> 860</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 861</pre></span><pre>		__hash__ = __hash_2009__</pre></div>
<div class="cov"><span class="num"><pre> 862</pre></span><pre>		__hash__.__name__ = '__hash__'</pre></div>
<div class="skip"><span class="num"><pre> 863</pre></span><pre>	# END overwrite previous hash with faster version</pre></div>
<div class="skip"><span class="num"><pre> 864</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 865</pre></span><pre>	#} END overridden methods</pre></div>
<div class="skip"><span class="num"><pre> 866</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 867</pre></span><pre>	#{ Interface</pre></div>
<div class="cov"><span class="num"><pre> 868</pre></span><pre>	def apiObject( self ):</pre></div>
<div class="cov"><span class="num"><pre> 869</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 870</pre></span><pre>		:return: the highest qualified api object of the actual superclass,</pre></div>
<div class="cov"><span class="num"><pre> 871</pre></span><pre>			usually either MObject or MDagPath&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 872</pre></span><pre>		raise NotImplementedError( &quot;To be implemented in subclass&quot; )</pre></div>
<div class="skip"><span class="num"><pre> 873</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 874</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre> 875</pre></span><pre>	def getMFnClasses( cls ):</pre></div>
<div class="cov"><span class="num"><pre> 876</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 877</pre></span><pre>		:return: list of all function set classes this node supports, most derived</pre></div>
<div class="cov"><span class="num"><pre> 878</pre></span><pre>			function set comes first&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 879</pre></span><pre>		return [ mrocls._mfncls for mrocls in cls.mro() if '_mfncls' in mrocls.__dict__ ]</pre></div>
<div class="skip"><span class="num"><pre> 880</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 881</pre></span><pre>	def apiType( self ):</pre></div>
<div class="cov"><span class="num"><pre> 882</pre></span><pre>		&quot;&quot;&quot;:return: the MFn Type id of the wrapped object&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 883</pre></span><pre>		return self.apiObject().apiType()</pre></div>
<div class="skip"><span class="num"><pre> 884</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 885</pre></span><pre>	def hasFn( self, mfntype ):</pre></div>
<div class="cov"><span class="num"><pre> 886</pre></span><pre>		&quot;&quot;&quot;:return: True if our object supports the given function set type&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 887</pre></span><pre>		return self.apiObject().hasFn( mfntype )</pre></div>
<div class="skip"><span class="num"><pre> 888</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 889</pre></span><pre>	#} END interface</pre></div>
<div class="skip"><span class="num"><pre> 890</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 891</pre></span><pre>def _lookup_type( mobject_or_mdagpath ):</pre></div>
<div class="cov"><span class="num"><pre> 892</pre></span><pre>	&quot;&quot;&quot;:return: node type name of the given MObject or MDagPath</pre></div>
<div class="cov"><span class="num"><pre> 893</pre></span><pre>	:note: if we have a plugin type, we must use the 'slow' way</pre></div>
<div class="cov"><span class="num"><pre> 894</pre></span><pre>		as the type is the same for all plugin nodes&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 895</pre></span><pre>	apitype = mobject_or_mdagpath.apiType() </pre></div>
<div class="cov"><span class="num"><pre> 896</pre></span><pre>	try:</pre></div>
<div class="cov"><span class="num"><pre> 897</pre></span><pre>		if apitype in _plugin_type_ids_lut:</pre></div>
<div class="cov"><span class="num"><pre> 898</pre></span><pre>			raise KeyError</pre></div>
<div class="skip"><span class="num"><pre> 899</pre></span><pre>		# END force byName type check for plugin types</pre></div>
<div class="cov"><span class="num"><pre> 900</pre></span><pre>		return _apitype_to_name[apitype]</pre></div>
<div class="cov"><span class="num"><pre> 901</pre></span><pre>	except KeyError:</pre></div>
<div class="skip"><span class="num"><pre> 902</pre></span><pre>		# cache miss - fill in the type</pre></div>
<div class="cov"><span class="num"><pre> 903</pre></span><pre>		if isinstance(mobject_or_mdagpath, MDagPath):</pre></div>
<div class="cov"><span class="num"><pre> 904</pre></span><pre>			_mfndag_setObject(mobject_or_mdagpath)</pre></div>
<div class="cov"><span class="num"><pre> 905</pre></span><pre>			typename =_mfndag_typename()</pre></div>
<div class="cov"><span class="num"><pre> 906</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 907</pre></span><pre>			_mfndep_setobject(mobject_or_mdagpath)</pre></div>
<div class="cov"><span class="num"><pre> 908</pre></span><pre>			typename = _mfndep_typename()</pre></div>
<div class="skip"><span class="num"><pre> 909</pre></span><pre>		# END handle input type </pre></div>
<div class="cov"><span class="num"><pre> 910</pre></span><pre>		_apitype_to_name[mobject_or_mdagpath.apiType()] = typename</pre></div>
<div class="skip"><span class="num"><pre> 911</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 912</pre></span><pre>		return typename</pre></div>
<div class="skip"><span class="num"><pre> 913</pre></span><pre>	# END handle cache miss</pre></div>
<div class="skip"><span class="num"><pre> 914</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 915</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 916</pre></span><pre>class NodeFromObj( object ):</pre></div>
<div class="cov"><span class="num"><pre> 917</pre></span><pre>	&quot;&quot;&quot;Virtual Constructor, producing nodes as the `Node` does, but it will only</pre></div>
<div class="cov"><span class="num"><pre> 918</pre></span><pre>	accept MObjects or dagpaths which are expected to be valid. </pre></div>
<div class="cov"><span class="num"><pre> 919</pre></span><pre>	As no additional checking is performed, it might be more unsafe to use, but </pre></div>
<div class="cov"><span class="num"><pre> 920</pre></span><pre>	will be faster as it does not perform any runtime checks</pre></div>
<div class="skip"><span class="num"><pre> 921</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 922</pre></span><pre>	It duplicates code from `_checkedInstanceCreation` and `_checkedInstanceCreationDagPathSupport`</pre></div>
<div class="cov"><span class="num"><pre> 923</pre></span><pre>	to squeeze out the last tiny bit of performance as it can make quite a few more </pre></div>
<div class="cov"><span class="num"><pre> 924</pre></span><pre>	assumptions and reduces method calls.</pre></div>
<div class="skip"><span class="num"><pre> 925</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 926</pre></span><pre>	:note: Do not derive from this class, derive from `Node` instead</pre></div>
<div class="cov"><span class="num"><pre> 927</pre></span><pre>	:note: We will always create the node type as determined by the type hierarchy&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 928</pre></span><pre>	def __new__ ( cls, mobject_or_mdagpath ):</pre></div>
<div class="cov"><span class="num"><pre> 929</pre></span><pre>		apiobj = mobject_or_mdagpath</pre></div>
<div class="cov"><span class="num"><pre> 930</pre></span><pre>		dagpath = None</pre></div>
<div class="cov"><span class="num"><pre> 931</pre></span><pre>		if isinstance( mobject_or_mdagpath, MDagPath ):</pre></div>
<div class="cov"><span class="num"><pre> 932</pre></span><pre>			dagpath = mobject_or_mdagpath</pre></div>
<div class="skip"><span class="num"><pre> 933</pre></span><pre>		# END if we have a dag path</pre></div>
<div class="skip"><span class="num"><pre> 934</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 935</pre></span><pre>		clsinstance = object.__new__(nodeTypeToNodeTypeCls(_lookup_type(mobject_or_mdagpath), apiobj))</pre></div>
<div class="skip"><span class="num"><pre> 936</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 937</pre></span><pre>		# apiobj is None, or MObject, or MDagPath, but will be set to the proper type </pre></div>
<div class="skip"><span class="num"><pre> 938</pre></span><pre>		# later</pre></div>
<div class="cov"><span class="num"><pre> 939</pre></span><pre>		object.__setattr__( clsinstance, '_apiobj',  apiobj )</pre></div>
<div class="skip"><span class="num"><pre> 940</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 941</pre></span><pre>		# DagNode created from a MObject ?</pre></div>
<div class="cov"><span class="num"><pre> 942</pre></span><pre>		if isinstance( clsinstance, DagNode ):</pre></div>
<div class="cov"><span class="num"><pre> 943</pre></span><pre>			_setupDagNodeDelayedMethods( clsinstance, apiobj, dagpath )</pre></div>
<div class="skip"><span class="num"><pre> 944</pre></span><pre>		# END handel DagObjects</pre></div>
<div class="skip"><span class="num"><pre> 945</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 946</pre></span><pre>		# for some reason, we have to call init ourselves in that case, probably</pre></div>
<div class="skip"><span class="num"><pre> 947</pre></span><pre>		# since we are not afficliated with the actual instance we returned which </pre></div>
<div class="skip"><span class="num"><pre> 948</pre></span><pre>		# makes a little bit of sense.</pre></div>
<div class="cov"><span class="num"><pre> 949</pre></span><pre>		clsinstance.__init__(mobject_or_mdagpath)</pre></div>
<div class="cov"><span class="num"><pre> 950</pre></span><pre>		return clsinstance</pre></div>
<div class="skip"><span class="num"><pre> 951</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 952</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 953</pre></span><pre>class NodeFromStr( object ):</pre></div>
<div class="cov"><span class="num"><pre> 954</pre></span><pre>	&quot;&quot;&quot;Virtual constructor similar to `NodeFromObj`, but it will only accept strings</pre></div>
<div class="cov"><span class="num"><pre> 955</pre></span><pre>	to produce a wrapped node as fast as possible. Therefore, the error checking is </pre></div>
<div class="cov"><span class="num"><pre> 956</pre></span><pre>	left out.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 957</pre></span><pre>	def __new__ ( cls, node_string ):</pre></div>
<div class="cov"><span class="num"><pre> 958</pre></span><pre>		return NodeFromObj(toApiobjOrDagPath(node_string))</pre></div>
<div class="skip"><span class="num"><pre> 959</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 960</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 961</pre></span><pre>class DependNode( Node, iDuplicatable ):		# parent just for epydoc -</pre></div>
<div class="cov"><span class="num"><pre> 962</pre></span><pre>	&quot;&quot;&quot; Implements access to dependency nodes&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 963</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 964</pre></span><pre>	#{ Overridden Methods</pre></div>
<div class="cov"><span class="num"><pre> 965</pre></span><pre>	def __getattr__( self, attr ):</pre></div>
<div class="cov"><span class="num"><pre> 966</pre></span><pre>		&quot;&quot;&quot;Interpret attributes not in our dict as attributes on the wrapped node,</pre></div>
<div class="cov"><span class="num"><pre> 967</pre></span><pre>		create a plug for it and add it to our class dict, effectively caching the attribute&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 968</pre></span><pre>		base = super( DependNode, self )</pre></div>
<div class="cov"><span class="num"><pre> 969</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 970</pre></span><pre>			plug = self.findPlug( attr)</pre></div>
<div class="cov"><span class="num"><pre> 971</pre></span><pre>		except RuntimeError:		# perhaps a base class can handle it</pre></div>
<div class="cov"><span class="num"><pre> 972</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 973</pre></span><pre>				return base.__getattribute__( attr )</pre></div>
<div class="cov"><span class="num"><pre> 974</pre></span><pre>			except AttributeError:</pre></div>
<div class="cov"><span class="num"><pre> 975</pre></span><pre>				raise AttributeError( &quot;Attribute '%s' does not exist on '%s', neither as function not as attribute&quot; % ( attr, self.name() ) )</pre></div>
<div class="skip"><span class="num"><pre> 976</pre></span><pre>			# END try to get attribute by base class</pre></div>
<div class="skip"><span class="num"><pre> 977</pre></span><pre>		# END find plug exception handling </pre></div>
<div class="skip"><span class="num"><pre> 978</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 979</pre></span><pre>		# NOTE: Don't cache the plug on the instance, it might be too dangerous</pre></div>
<div class="skip"><span class="num"><pre> 980</pre></span><pre>		# in conjunction with changes to the DAG</pre></div>
<div class="skip"><span class="num"><pre> 981</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 982</pre></span><pre>		# and assure our class knows about it so in future the plug will be retrieved</pre></div>
<div class="skip"><span class="num"><pre> 983</pre></span><pre>		# right away, before having a function lookup miss</pre></div>
<div class="cov"><span class="num"><pre> 984</pre></span><pre>		attr = str(attr)</pre></div>
<div class="cov"><span class="num"><pre> 985</pre></span><pre>		setattr(type(self), attr, property(lambda self: self.findPlug(attr)))</pre></div>
<div class="skip"><span class="num"><pre> 986</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 987</pre></span><pre>		return plug</pre></div>
<div class="skip"><span class="num"><pre> 988</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 989</pre></span><pre>	def __str__( self ):</pre></div>
<div class="cov"><span class="num"><pre> 990</pre></span><pre>		&quot;&quot;&quot;:return: name of this object&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 991</pre></span><pre>		return self.name()</pre></div>
<div class="skip"><span class="num"><pre> 992</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 993</pre></span><pre>	def __repr__( self ):</pre></div>
<div class="cov"><span class="num"><pre> 994</pre></span><pre>		&quot;&quot;&quot;:return: class call syntax&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 995</pre></span><pre>		import traceback</pre></div>
<div class="cov"><span class="num"><pre> 996</pre></span><pre>		return '%s(&quot;%s&quot;)' % ( self.__class__.__name__, DependNode.__str__( self ) )</pre></div>
<div class="skip"><span class="num"><pre> 997</pre></span><pre>	#} END overridden methods</pre></div>
<div class="skip"><span class="num"><pre> 998</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 999</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1000</pre></span><pre>	#( iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre>1001</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1002</pre></span><pre>	@notundoable</pre></div>
<div class="cov"><span class="num"><pre>1003</pre></span><pre>	def duplicate( self, name = None, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>1004</pre></span><pre>		&quot;&quot;&quot;Duplicate our node and return a wrapped version to it</pre></div>
<div class="skip"><span class="num"><pre>1005</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1006</pre></span><pre>		:param name: if given, the newly created node will use the given name</pre></div>
<div class="cov"><span class="num"><pre>1007</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>1008</pre></span><pre>			 * renameOnClash: if Trrue, default True, clashes are prevented by renaming the new node</pre></div>
<div class="cov"><span class="num"><pre>1009</pre></span><pre>			 * autocreateNamespace: if True, default True, namespaces will be created if mentioned in the name</pre></div>
<div class="cov"><span class="num"><pre>1010</pre></span><pre>		:note: the copyTo method may not have not-undoable side-effects to be a proper</pre></div>
<div class="cov"><span class="num"><pre>1011</pre></span><pre>			implementation</pre></div>
<div class="cov"><span class="num"><pre>1012</pre></span><pre>		:note: undo could be implemented for dg nodes - but for reasons of consistency, its disabled here -</pre></div>
<div class="cov"><span class="num"><pre>1013</pre></span><pre>			who knows how much it will crap out after a while as duplicate is not undoable ( mel command )  -</pre></div>
<div class="cov"><span class="num"><pre>1014</pre></span><pre>			it never really worked to undo a mel command from within python, executed using a dgmodifier - unfortunately</pre></div>
<div class="cov"><span class="num"><pre>1015</pre></span><pre>			it does not return any result making it hard to find the newly duplicated object !&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1016</pre></span><pre>		# returns name of duplicated node</pre></div>
<div class="cov"><span class="num"><pre>1017</pre></span><pre>		duplnode = NodeFromStr( cmds.duplicate( str( self ) )[0] )</pre></div>
<div class="skip"><span class="num"><pre>1018</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1019</pre></span><pre>		# RENAME</pre></div>
<div class="skip"><span class="num"><pre>1020</pre></span><pre>		###########</pre></div>
<div class="skip"><span class="num"><pre>1021</pre></span><pre>		# find a good name based on our own one - the default name is just not nice</pre></div>
<div class="cov"><span class="num"><pre>1022</pre></span><pre>		if not name:</pre></div>
<div class="cov"><span class="num"><pre>1023</pre></span><pre>			name = _getUniqueName( self )</pre></div>
<div class="cov"><span class="num"><pre>1024</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>1025</pre></span><pre>			if '|' in name:</pre></div>
<div class="nocov"><span class="num"><pre>1026</pre></span><pre>				raise ValueError( &quot;Names for dependency nodes my not contain pipes: %s&quot; % name )</pre></div>
<div class="skip"><span class="num"><pre>1027</pre></span><pre>		# END name handling</pre></div>
<div class="skip"><span class="num"><pre>1028</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1029</pre></span><pre>		rkwargs = dict()</pre></div>
<div class="cov"><span class="num"><pre>1030</pre></span><pre>		rkwargs[ 'renameOnClash' ] = kwargs.pop( 'renameOnClash', True )</pre></div>
<div class="cov"><span class="num"><pre>1031</pre></span><pre>		rkwargs[ 'autocreateNamespace' ] = kwargs.pop( 'autocreateNamespace', True )</pre></div>
<div class="cov"><span class="num"><pre>1032</pre></span><pre>		duplnode = duplnode.rename( name, **rkwargs )</pre></div>
<div class="skip"><span class="num"><pre>1033</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1034</pre></span><pre>		# call our base class to copy additional information</pre></div>
<div class="cov"><span class="num"><pre>1035</pre></span><pre>		self.copyTo( duplnode, *args, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>1036</pre></span><pre>		return duplnode</pre></div>
<div class="skip"><span class="num"><pre>1037</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1038</pre></span><pre>	#) END iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre>1039</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1040</pre></span><pre>	#{ preset type filters</pre></div>
<div class="cov"><span class="num"><pre>1041</pre></span><pre>	fSetsObject = SetFilter( api.MFn.kSet, True, 0 )				# object fSets only</pre></div>
<div class="cov"><span class="num"><pre>1042</pre></span><pre>	fSets = SetFilter( api.MFn.kSet, False, 0 )			 		# all set types</pre></div>
<div class="skip"><span class="num"><pre>1043</pre></span><pre>	#} END type filters</pre></div>
<div class="skip"><span class="num"><pre>1044</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1045</pre></span><pre>	#{ Sets Handling</pre></div>
<div class="skip"><span class="num"><pre>1046</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1047</pre></span><pre>	def _getSetPlug( self ):</pre></div>
<div class="cov"><span class="num"><pre>1048</pre></span><pre>		&quot;&quot;&quot;:return: message plug - for non dag nodes, this will be connected &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>1049</pre></span><pre>		return self.message</pre></div>
<div class="skip"><span class="num"><pre>1050</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1051</pre></span><pre>	def connectedSets( self, setFilter = fSets ):</pre></div>
<div class="cov"><span class="num"><pre>1052</pre></span><pre>		&quot;&quot;&quot;:return: list of object set compatible Nodes having self as member</pre></div>
<div class="cov"><span class="num"><pre>1053</pre></span><pre>		:param setFilter: tuple( apiType, use_exact_type ) - the combination of the</pre></div>
<div class="cov"><span class="num"><pre>1054</pre></span><pre>			desired api type and the exact type flag allow precise control whether you which</pre></div>
<div class="cov"><span class="num"><pre>1055</pre></span><pre>			to get only renderable shading engines, only objectfSets ( tuple[1] = True ),</pre></div>
<div class="cov"><span class="num"><pre>1056</pre></span><pre>			or all objects supporting the given object type.</pre></div>
<div class="cov"><span class="num"><pre>1057</pre></span><pre>			Its preset to only return shading engines</pre></div>
<div class="cov"><span class="num"><pre>1058</pre></span><pre>		:note: the returned sets order is defined by the order connections to instObjGroups</pre></div>
<div class="cov"><span class="num"><pre>1059</pre></span><pre>		:note: only sets will be returned that have the whole object as member, thus you will not</pre></div>
<div class="cov"><span class="num"><pre>1060</pre></span><pre>			see sets having component assignments like per-compoent shader assignments or deformer sets &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1061</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1062</pre></span><pre>		# have to parse the connections to fSets manually, finding fSets matching the required</pre></div>
<div class="skip"><span class="num"><pre>1063</pre></span><pre>		# type and returning them</pre></div>
<div class="cov"><span class="num"><pre>1064</pre></span><pre>		outlist = list()</pre></div>
<div class="cov"><span class="num"><pre>1065</pre></span><pre>		iogplug = self._getSetPlug()</pre></div>
<div class="skip"><span class="num"><pre>1066</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1067</pre></span><pre>		for dplug in iogplug.moutputs():</pre></div>
<div class="cov"><span class="num"><pre>1068</pre></span><pre>			setapiobj = dplug.node()</pre></div>
<div class="skip"><span class="num"><pre>1069</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1070</pre></span><pre>			if not setFilter( setapiobj ):</pre></div>
<div class="cov"><span class="num"><pre>1071</pre></span><pre>				continue</pre></div>
<div class="cov"><span class="num"><pre>1072</pre></span><pre>			outlist.append( NodeFromObj( MObject( setapiobj ) ) )</pre></div>
<div class="skip"><span class="num"><pre>1073</pre></span><pre>		# END for each connected set</pre></div>
<div class="skip"><span class="num"><pre>1074</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1075</pre></span><pre>		return outlist</pre></div>
<div class="skip"><span class="num"><pre>1076</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1077</pre></span><pre>	# alias - connectedSets derives from the MayaAPI, but could be shorter</pre></div>
<div class="cov"><span class="num"><pre>1078</pre></span><pre>	sets = connectedSets</pre></div>
<div class="skip"><span class="num"><pre>1079</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1080</pre></span><pre>	def isMemberOf( self, setnode, component = MObject() ):</pre></div>
<div class="cov"><span class="num"><pre>1081</pre></span><pre>		&quot;&quot;&quot;:return: True if self is part of setnode</pre></div>
<div class="cov"><span class="num"><pre>1082</pre></span><pre>		:note: method is undoable</pre></div>
<div class="cov"><span class="num"><pre>1083</pre></span><pre>		:see: `sets.ObjectSet`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1084</pre></span><pre>		return setnode.isMember( self, component = component )</pre></div>
<div class="skip"><span class="num"><pre>1085</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1086</pre></span><pre>	def addTo( self, setnode, component = MObject(), **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>1087</pre></span><pre>		&quot;&quot;&quot;Add ourselves to the given set</pre></div>
<div class="skip"><span class="num"><pre>1088</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1089</pre></span><pre>		:note: method is undoable</pre></div>
<div class="cov"><span class="num"><pre>1090</pre></span><pre>		:see: `sets.ObjectSet`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1091</pre></span><pre>		return setnode.addMember( self, component = component, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>1092</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1093</pre></span><pre>	def removeFrom( self, setnode, component = MObject() ):</pre></div>
<div class="cov"><span class="num"><pre>1094</pre></span><pre>		&quot;&quot;&quot;remove ourselves to the given set</pre></div>
<div class="skip"><span class="num"><pre>1095</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1096</pre></span><pre>		:note: method is undoable</pre></div>
<div class="cov"><span class="num"><pre>1097</pre></span><pre>		:see: `sets.ObjectSet`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1098</pre></span><pre>		return setnode.removeMember( self, component = component )</pre></div>
<div class="skip"><span class="num"><pre>1099</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1100</pre></span><pre>	#} END sets handling</pre></div>
<div class="skip"><span class="num"><pre>1101</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1102</pre></span><pre>	#{ Edit</pre></div>
<div class="skip"><span class="num"><pre>1103</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1104</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1105</pre></span><pre>	def rename( self, newname, autocreateNamespace=True, renameOnClash = True ):</pre></div>
<div class="cov"><span class="num"><pre>1106</pre></span><pre>		&quot;&quot;&quot;Rename this node to newname</pre></div>
<div class="skip"><span class="num"><pre>1107</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1108</pre></span><pre>		:param newname: new name of the node</pre></div>
<div class="cov"><span class="num"><pre>1109</pre></span><pre>		:param autocreateNamespace: if true, namespaces given in newpath will be created automatically, otherwise</pre></div>
<div class="cov"><span class="num"><pre>1110</pre></span><pre>			a RuntimeException will be thrown if a required namespace does not exist</pre></div>
<div class="cov"><span class="num"><pre>1111</pre></span><pre>		:param renameOnClash: if true, clashing names will automatically be resolved by adjusting the name</pre></div>
<div class="cov"><span class="num"><pre>1112</pre></span><pre>		:return: renamed node which is the node itself</pre></div>
<div class="cov"><span class="num"><pre>1113</pre></span><pre>		:note: for safety reasons, this node is dagnode aware and uses a dag modifier for them !&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1114</pre></span><pre>		if '|' in newname:</pre></div>
<div class="nocov"><span class="num"><pre>1115</pre></span><pre>			raise NameError( &quot;new node names may not contain '|' as in %s&quot; % newname )</pre></div>
<div class="skip"><span class="num"><pre>1116</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1117</pre></span><pre>		# is it the same name ?</pre></div>
<div class="cov"><span class="num"><pre>1118</pre></span><pre>		if newname == api.MFnDependencyNode( self.object() ).name():</pre></div>
<div class="cov"><span class="num"><pre>1119</pre></span><pre>			return self</pre></div>
<div class="skip"><span class="num"><pre>1120</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1121</pre></span><pre>		# ALREADY EXISTS ?</pre></div>
<div class="cov"><span class="num"><pre>1122</pre></span><pre>		if not renameOnClash:</pre></div>
<div class="cov"><span class="num"><pre>1123</pre></span><pre>			exists = False</pre></div>
<div class="skip"><span class="num"><pre>1124</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1125</pre></span><pre>			if isinstance( self, DagNode ):	# dagnode: check existing children under parent</pre></div>
<div class="cov"><span class="num"><pre>1126</pre></span><pre>				parent = self.parent()</pre></div>
<div class="cov"><span class="num"><pre>1127</pre></span><pre>				if parent:</pre></div>
<div class="cov"><span class="num"><pre>1128</pre></span><pre>					testforobject = parent.fullChildName( newname )	# append our name to the path</pre></div>
<div class="cov"><span class="num"><pre>1129</pre></span><pre>					if objExists( testforobject ):</pre></div>
<div class="cov"><span class="num"><pre>1130</pre></span><pre>						raise RuntimeError( &quot;Object %s did already exist - renameOnClash could have resolved this issue&quot; % testforobject )</pre></div>
<div class="skip"><span class="num"><pre>1131</pre></span><pre>				# END if we have a parent</pre></div>
<div class="cov"><span class="num"><pre>1132</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>1133</pre></span><pre>				exists = objExists( newname )	# depnode: check if object exists</pre></div>
<div class="skip"><span class="num"><pre>1134</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1135</pre></span><pre>			if exists:</pre></div>
<div class="cov"><span class="num"><pre>1136</pre></span><pre>				raise RuntimeError( &quot;Node named %s did already exist, failed to rename %s&quot; % ( newname, self ) )</pre></div>
<div class="skip"><span class="num"><pre>1137</pre></span><pre>		# END not renameOnClash handling</pre></div>
<div class="skip"><span class="num"><pre>1138</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1139</pre></span><pre>		# NAMESPACE</pre></div>
<div class="cov"><span class="num"><pre>1140</pre></span><pre>		ns = &quot;:&quot;.join( newname.split( &quot;:&quot; )[:-1] )</pre></div>
<div class="cov"><span class="num"><pre>1141</pre></span><pre>		if not nsm.existsNamespace( ns ) and not autocreateNamespace:</pre></div>
<div class="cov"><span class="num"><pre>1142</pre></span><pre>			raise RuntimeError( &quot;Cannot rename %s to %s as namespace %s does not exist&quot; % ( self, newname, ns ) )</pre></div>
<div class="cov"><span class="num"><pre>1143</pre></span><pre>		ns = nsm.createNamespace( ns )		# assure its there</pre></div>
<div class="skip"><span class="num"><pre>1144</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1145</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1146</pre></span><pre>		# NOTE: this stupid method will also rename shapes !!!</pre></div>
<div class="skip"><span class="num"><pre>1147</pre></span><pre>		# you cannot prevent it, so we have to store the names and rename it lateron !!</pre></div>
<div class="cov"><span class="num"><pre>1148</pre></span><pre>		shapenames = shapes = None			# HACK: this is dagnodes only ( only put here for convenience, should be in DagNode )</pre></div>
<div class="skip"><span class="num"><pre>1149</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1150</pre></span><pre>		# rename the node</pre></div>
<div class="cov"><span class="num"><pre>1151</pre></span><pre>		mod = None</pre></div>
<div class="cov"><span class="num"><pre>1152</pre></span><pre>		if isinstance( self, DagNode ):</pre></div>
<div class="cov"><span class="num"><pre>1153</pre></span><pre>			mod = undo.DagModifier( )</pre></div>
<div class="cov"><span class="num"><pre>1154</pre></span><pre>			shapes = self.shapes( )</pre></div>
<div class="cov"><span class="num"><pre>1155</pre></span><pre>			shapenames = [ s.basename( ) for s in shapes  ]</pre></div>
<div class="cov"><span class="num"><pre>1156</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>1157</pre></span><pre>			mod = undo.DGModifier( )</pre></div>
<div class="cov"><span class="num"><pre>1158</pre></span><pre>		mod.renameNode( self.object(), newname )</pre></div>
<div class="skip"><span class="num"><pre>1159</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1160</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1161</pre></span><pre>		# RENAME SHAPES BACK !</pre></div>
<div class="skip"><span class="num"><pre>1162</pre></span><pre>		#######################</pre></div>
<div class="skip"><span class="num"><pre>1163</pre></span><pre>		# Yeah, of course the rename method renames shapes although this has never been</pre></div>
<div class="skip"><span class="num"><pre>1164</pre></span><pre>		# requested ... its so stupid ...</pre></div>
<div class="cov"><span class="num"><pre>1165</pre></span><pre>		if shapes:</pre></div>
<div class="cov"><span class="num"><pre>1166</pre></span><pre>			for shape,shapeorigname in zip( shapes, shapenames ): 	 # could use izip, but this is not about memory here</pre></div>
<div class="cov"><span class="num"><pre>1167</pre></span><pre>				mod.renameNode( shape.object(), shapeorigname )</pre></div>
<div class="skip"><span class="num"><pre>1168</pre></span><pre>			# END for each shape to rename</pre></div>
<div class="skip"><span class="num"><pre>1169</pre></span><pre>		# END handle renamed shapes</pre></div>
<div class="skip"><span class="num"><pre>1170</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1171</pre></span><pre>		mod.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1172</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1173</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre>1174</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1175</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1176</pre></span><pre>	def delete( self ):</pre></div>
<div class="cov"><span class="num"><pre>1177</pre></span><pre>		&quot;&quot;&quot;Delete this node</pre></div>
<div class="skip"><span class="num"><pre>1178</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1179</pre></span><pre>		:note: if the undo queue is enabled, the object becomes invalid, but stays alive until it</pre></div>
<div class="cov"><span class="num"><pre>1180</pre></span><pre>			drops off the queue</pre></div>
<div class="cov"><span class="num"><pre>1181</pre></span><pre>		:note: if you want to delete many nodes, its more efficient to delete them</pre></div>
<div class="cov"><span class="num"><pre>1182</pre></span><pre>			using the global `delete` method&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1183</pre></span><pre>		mod = undo.DGModifier( )</pre></div>
<div class="cov"><span class="num"><pre>1184</pre></span><pre>		mod.deleteNode( self.object() )</pre></div>
<div class="cov"><span class="num"><pre>1185</pre></span><pre>		mod.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1186</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1187</pre></span><pre>	def _addRemoveAttr( self, attr, add ):</pre></div>
<div class="cov"><span class="num"><pre>1188</pre></span><pre>		&quot;&quot;&quot;DoIt function adding or removing attributes with undo&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1189</pre></span><pre>		mfninst = self._mfncls( self.object() )</pre></div>
<div class="cov"><span class="num"><pre>1190</pre></span><pre>		doitfunc = mfninst.addAttribute</pre></div>
<div class="skip"><span class="num"><pre>1191</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1192</pre></span><pre>		if not add:</pre></div>
<div class="cov"><span class="num"><pre>1193</pre></span><pre>			doitfunc = mfninst.removeAttribute</pre></div>
<div class="skip"><span class="num"><pre>1194</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1195</pre></span><pre>		doitfunc( attr )</pre></div>
<div class="skip"><span class="num"><pre>1196</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1197</pre></span><pre>	def addAttribute( self, attr ):</pre></div>
<div class="cov"><span class="num"><pre>1198</pre></span><pre>		&quot;&quot;&quot;Add the given attribute to the node as local dynamic attribute</pre></div>
<div class="skip"><span class="num"><pre>1199</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1200</pre></span><pre>		:param attr: MObject of attribute or Attribute instance as retrieved from</pre></div>
<div class="cov"><span class="num"><pre>1201</pre></span><pre>			a plug</pre></div>
<div class="cov"><span class="num"><pre>1202</pre></span><pre>		:return: plug to the newly added attribute</pre></div>
<div class="cov"><span class="num"><pre>1203</pre></span><pre>		:note: This method is explicitly not undoable as attributes are being deleted</pre></div>
<div class="cov"><span class="num"><pre>1204</pre></span><pre>			in memory right in the moment they are being removed, thus they cannot</pre></div>
<div class="cov"><span class="num"><pre>1205</pre></span><pre>			reside on the undo queue&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1206</pre></span><pre>		# return it if it already exists</pre></div>
<div class="cov"><span class="num"><pre>1207</pre></span><pre>		attrname = api.MFnAttribute( attr ).name()</pre></div>
<div class="cov"><span class="num"><pre>1208</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>1209</pre></span><pre>			return self.findPlug( attrname, False )</pre></div>
<div class="cov"><span class="num"><pre>1210</pre></span><pre>		except RuntimeError:</pre></div>
<div class="cov"><span class="num"><pre>1211</pre></span><pre>			pass</pre></div>
<div class="skip"><span class="num"><pre>1212</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1213</pre></span><pre>		self._addRemoveAttr( attr, True )</pre></div>
<div class="cov"><span class="num"><pre>1214</pre></span><pre>		return self.findPlug( api.MFnAttribute( attr ).name() )</pre></div>
<div class="skip"><span class="num"><pre>1215</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1216</pre></span><pre>	def removeAttribute( self, attr ):</pre></div>
<div class="cov"><span class="num"><pre>1217</pre></span><pre>		&quot;&quot;&quot;Remove the given attribute from the node</pre></div>
<div class="skip"><span class="num"><pre>1218</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1219</pre></span><pre>		:param attr: see `addAttribute`&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1220</pre></span><pre>		# don't do anyting if it does not exist</pre></div>
<div class="cov"><span class="num"><pre>1221</pre></span><pre>		attrname = api.MFnAttribute( attr ).name()</pre></div>
<div class="cov"><span class="num"><pre>1222</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>1223</pre></span><pre>			self.findPlug( attrname, False )</pre></div>
<div class="nocov"><span class="num"><pre>1224</pre></span><pre>		except RuntimeError:</pre></div>
<div class="skip"><span class="num"><pre>1225</pre></span><pre>			# it does not exist, that's what was requested</pre></div>
<div class="nocov"><span class="num"><pre>1226</pre></span><pre>			return</pre></div>
<div class="skip"><span class="num"><pre>1227</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1228</pre></span><pre>		self._addRemoveAttr( attr, False )</pre></div>
<div class="skip"><span class="num"><pre>1229</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1230</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1231</pre></span><pre>	def setNamespace(self, newns, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>1232</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1233</pre></span><pre>		:return: self after being moved to the given namespace. This will effectively</pre></div>
<div class="cov"><span class="num"><pre>1234</pre></span><pre>			rename the object.</pre></div>
<div class="cov"><span class="num"><pre>1235</pre></span><pre>		:param newns: Namespace instance to put this Node into</pre></div>
<div class="cov"><span class="num"><pre>1236</pre></span><pre>		:param kwargs: to be passed to `rename`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1237</pre></span><pre>		namespace, objname = nsm.Namespace.splitNamespace(self.basename())</pre></div>
<div class="cov"><span class="num"><pre>1238</pre></span><pre>		return self.rename(newns + objname, **kwargs)</pre></div>
<div class="skip"><span class="num"><pre>1239</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1240</pre></span><pre>	#} END edit</pre></div>
<div class="skip"><span class="num"><pre>1241</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1242</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1243</pre></span><pre>	def setLocked( self, state ):</pre></div>
<div class="cov"><span class="num"><pre>1244</pre></span><pre>		&quot;&quot;&quot;Lock or unloack this node</pre></div>
<div class="skip"><span class="num"><pre>1245</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1246</pre></span><pre>		:param state: if True, the node is locked. Locked nodes cannot be deleted,</pre></div>
<div class="cov"><span class="num"><pre>1247</pre></span><pre>			renamed or reparented</pre></div>
<div class="cov"><span class="num"><pre>1248</pre></span><pre>		:note: you can query the lock state with `isLocked`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1249</pre></span><pre>		curstate = self.isLocked()</pre></div>
<div class="skip"><span class="num"><pre>1250</pre></span><pre>		# also works for dag nodes !</pre></div>
<div class="cov"><span class="num"><pre>1251</pre></span><pre>		depfn = api.MFnDependencyNode( self.object() )</pre></div>
<div class="skip"><span class="num"><pre>1252</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1253</pre></span><pre>		op = undo.GenericOperation( )</pre></div>
<div class="cov"><span class="num"><pre>1254</pre></span><pre>		op.setDoitCmd( depfn.setLocked, state )</pre></div>
<div class="cov"><span class="num"><pre>1255</pre></span><pre>		op.setUndoitCmd( depfn.setLocked, curstate )</pre></div>
<div class="cov"><span class="num"><pre>1256</pre></span><pre>		op.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1257</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1258</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1259</pre></span><pre>	#{ Connections and Attributes</pre></div>
<div class="skip"><span class="num"><pre>1260</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1261</pre></span><pre>	def connections( self ):</pre></div>
<div class="cov"><span class="num"><pre>1262</pre></span><pre>		&quot;&quot;&quot;:return: MPlugArray of connected plugs&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1263</pre></span><pre>		cons = api.MPlugArray( )</pre></div>
<div class="cov"><span class="num"><pre>1264</pre></span><pre>		mfn = DependNode._mfncls( self.object() ).getConnections( cons )</pre></div>
<div class="cov"><span class="num"><pre>1265</pre></span><pre>		return cons</pre></div>
<div class="skip"><span class="num"><pre>1266</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1267</pre></span><pre>	def dependencyInfo( self, attribute, by=True ):</pre></div>
<div class="cov"><span class="num"><pre>1268</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1269</pre></span><pre>		:return: list of attributes that given attribute affects or that the given attribute</pre></div>
<div class="cov"><span class="num"><pre>1270</pre></span><pre>			is affected by</pre></div>
<div class="cov"><span class="num"><pre>1271</pre></span><pre>			if the attribute turns dirty.</pre></div>
<div class="cov"><span class="num"><pre>1272</pre></span><pre>		:param attribute: attribute instance or attribute name</pre></div>
<div class="cov"><span class="num"><pre>1273</pre></span><pre>		:param by: if false, affected attributes will be returned, otherwise the attributes affecting this one</pre></div>
<div class="cov"><span class="num"><pre>1274</pre></span><pre>		:note: see also `MPlug.affectedByPlugs`</pre></div>
<div class="cov"><span class="num"><pre>1275</pre></span><pre>		:note: USING MEL: as api command and mObject array always crashed on me ... don't know :(&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1276</pre></span><pre>		if not isinstance( attribute, basestring ):</pre></div>
<div class="nocov"><span class="num"><pre>1277</pre></span><pre>			attribute = attribute.name()</pre></div>
<div class="skip"><span class="num"><pre>1278</pre></span><pre>		# END handle input</pre></div>
<div class="cov"><span class="num"><pre>1279</pre></span><pre>		attrs = cmds.affects( attribute , str(self), by=by )</pre></div>
<div class="cov"><span class="num"><pre>1280</pre></span><pre>		return [ self.attribute(an) for an in attrs ]</pre></div>
<div class="skip"><span class="num"><pre>1281</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1282</pre></span><pre>	#} END connections and attribtues</pre></div>
<div class="skip"><span class="num"><pre>1283</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1284</pre></span><pre>	#{ Status</pre></div>
<div class="cov"><span class="num"><pre>1285</pre></span><pre>	def isValid( self ):</pre></div>
<div class="cov"><span class="num"><pre>1286</pre></span><pre>		&quot;&quot;&quot;:return: True if the object exists in the scene</pre></div>
<div class="cov"><span class="num"><pre>1287</pre></span><pre>		:note: objects on the undo queue are NOT valid, but alive&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1288</pre></span><pre>		return MObjectHandle( self.object() ).isValid()</pre></div>
<div class="skip"><span class="num"><pre>1289</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1290</pre></span><pre>	def isAlive( self ):</pre></div>
<div class="cov"><span class="num"><pre>1291</pre></span><pre>		&quot;&quot;&quot;:return: True if the object exists in memory</pre></div>
<div class="cov"><span class="num"><pre>1292</pre></span><pre>		:note: objects on the undo queue are alive, but NOT valid&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1293</pre></span><pre>		return MObjectHandle( self.object() ).isAlive()</pre></div>
<div class="skip"><span class="num"><pre>1294</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1295</pre></span><pre>	#} END status</pre></div>
<div class="skip"><span class="num"><pre>1296</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1297</pre></span><pre>	#{ General Query</pre></div>
<div class="cov"><span class="num"><pre>1298</pre></span><pre>	def object( self ):</pre></div>
<div class="cov"><span class="num"><pre>1299</pre></span><pre>		&quot;&quot;&quot;:return: the MObject attached to this Node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1300</pre></span><pre>		return self._apiobj</pre></div>
<div class="skip"><span class="num"><pre>1301</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1302</pre></span><pre>	apiObject = object		# overridden from Node</pre></div>
<div class="skip"><span class="num"><pre>1303</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1304</pre></span><pre>	def referenceFile( self ):</pre></div>
<div class="cov"><span class="num"><pre>1305</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1306</pre></span><pre>		:return: name ( str ) of file this node is coming from - it could contain</pre></div>
<div class="cov"><span class="num"><pre>1307</pre></span><pre>			a copy number as {x}</pre></div>
<div class="cov"><span class="num"><pre>1308</pre></span><pre>		:note: will raise if the node is not referenced, use isReferenced to figure</pre></div>
<div class="cov"><span class="num"><pre>1309</pre></span><pre>			that out&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1310</pre></span><pre>		# apparently, we have to use MEL here :(</pre></div>
<div class="cov"><span class="num"><pre>1311</pre></span><pre>		return cmds.referenceQuery( str( self ) , f=1 )</pre></div>
<div class="skip"><span class="num"><pre>1312</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1313</pre></span><pre>	def basename(self):</pre></div>
<div class="cov"><span class="num"><pre>1314</pre></span><pre>		&quot;&quot;&quot;:return: name of this instance</pre></div>
<div class="cov"><span class="num"><pre>1315</pre></span><pre>		:note: it is mainly for compatability with dagNodes which need this method </pre></div>
<div class="cov"><span class="num"><pre>1316</pre></span><pre>			in order to return the name of their leaf node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1317</pre></span><pre>		return self.name()</pre></div>
<div class="skip"><span class="num"><pre>1318</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1319</pre></span><pre>	#}END general query</pre></div>
<div class="skip"><span class="num"><pre>1320</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1321</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1322</pre></span><pre>class Entity( DependNode ):		# parent just for epydoc</pre></div>
<div class="cov"><span class="num"><pre>1323</pre></span><pre>	&quot;&quot;&quot;Common base for dagnodes and paritions&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1324</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1325</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1326</pre></span><pre>class DagNode( Entity, iDagItem ):	# parent just for epydoc</pre></div>
<div class="cov"><span class="num"><pre>1327</pre></span><pre>	&quot;&quot;&quot; Implements access to DAG nodes &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1328</pre></span><pre>	_sep = &quot;|&quot;</pre></div>
<div class="cov"><span class="num"><pre>1329</pre></span><pre>	kNextPos = MFnDagNode.kNextPos</pre></div>
<div class="skip"><span class="num"><pre>1330</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1331</pre></span><pre>	def __eq__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre>1332</pre></span><pre>		&quot;&quot;&quot;Compare MDagPaths directly</pre></div>
<div class="cov"><span class="num"><pre>1333</pre></span><pre>		Valid inputs are Node, DagNode, MObject and MDagPath instances.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1334</pre></span><pre>		if not isinstance( other, Node ):</pre></div>
<div class="cov"><span class="num"><pre>1335</pre></span><pre>			other = NodeFromObj( other )</pre></div>
<div class="cov"><span class="num"><pre>1336</pre></span><pre>		if isinstance( other, DagNode ):</pre></div>
<div class="cov"><span class="num"><pre>1337</pre></span><pre>			return self.dagPath() == other.dagPath()</pre></div>
<div class="cov"><span class="num"><pre>1338</pre></span><pre>		return self.object() == other.object()</pre></div>
<div class="skip"><span class="num"><pre>1339</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1340</pre></span><pre>	def __ne__( self, other ):</pre></div>
<div class="cov"><span class="num"><pre>1341</pre></span><pre>		return not DagNode.__eq__( self, other )</pre></div>
<div class="skip"><span class="num"><pre>1342</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1343</pre></span><pre>	def __getitem__( self, index ):</pre></div>
<div class="cov"><span class="num"><pre>1344</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1345</pre></span><pre>		:return: if index &gt;= 0: Node( child )  at index</pre></div>
<div class="skip"><span class="num"><pre>1346</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1347</pre></span><pre>			 * if index &lt; 0: Node parent at  -(index+1)( if walking up the hierarchy )</pre></div>
<div class="cov"><span class="num"><pre>1348</pre></span><pre>			 * If index is string, use DependNodes implementation</pre></div>
<div class="skip"><span class="num"><pre>1349</pre></span><pre>			 </pre></div>
<div class="cov"><span class="num"><pre>1350</pre></span><pre>		:note: returned child can be transform or shape, use `shapes` or</pre></div>
<div class="cov"><span class="num"><pre>1351</pre></span><pre>			`childTransforms` if you need a quickfilter &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1352</pre></span><pre>		if index &gt; -1:</pre></div>
<div class="cov"><span class="num"><pre>1353</pre></span><pre>			return self.child( index )</pre></div>
<div class="cov"><span class="num"><pre>1354</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>1355</pre></span><pre>			for i,parent in enumerate( self.iterParents( ) ):</pre></div>
<div class="cov"><span class="num"><pre>1356</pre></span><pre>				if i == -(index+1):</pre></div>
<div class="cov"><span class="num"><pre>1357</pre></span><pre>					return parent</pre></div>
<div class="skip"><span class="num"><pre>1358</pre></span><pre>			# END for each parent</pre></div>
<div class="cov"><span class="num"><pre>1359</pre></span><pre>			raise IndexError( &quot;Parent with index %i did not exist for %r&quot; % ( index, self ) )</pre></div>
<div class="skip"><span class="num"><pre>1360</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1361</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1362</pre></span><pre>	def _getSetPlug( self ):</pre></div>
<div class="cov"><span class="num"><pre>1363</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1364</pre></span><pre>		:return: the iogplug properly initialized for self</pre></div>
<div class="cov"><span class="num"><pre>1365</pre></span><pre>			Dag Nodes have the iog plug as they support instancing &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1366</pre></span><pre>		return self.iog.elementByLogicalIndex( self.instanceNumber() )</pre></div>
<div class="skip"><span class="num"><pre>1367</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1368</pre></span><pre>	#{ DAG Modification</pre></div>
<div class="skip"><span class="num"><pre>1369</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1370</pre></span><pre>	def _setWorldspaceTransform( self, parentnode ):</pre></div>
<div class="cov"><span class="num"><pre>1371</pre></span><pre>		&quot;&quot;&quot;Set ourselve's transformation matrix to our absolute worldspace transformation,</pre></div>
<div class="cov"><span class="num"><pre>1372</pre></span><pre>		possibly relative to the optional parentnode</pre></div>
<div class="skip"><span class="num"><pre>1373</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1374</pre></span><pre>		:param parentnode: if not None, it is assumed to be the future parent of the node,</pre></div>
<div class="cov"><span class="num"><pre>1375</pre></span><pre>			our transformation will be set such that we retain our worldspace position if parented below</pre></div>
<div class="cov"><span class="num"><pre>1376</pre></span><pre>			parentnode&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1377</pre></span><pre>		if not isinstance( self, Transform ):</pre></div>
<div class="nocov"><span class="num"><pre>1378</pre></span><pre>			return</pre></div>
<div class="skip"><span class="num"><pre>1379</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1380</pre></span><pre>		nwm = self.wm.elementByLogicalIndex( self.instanceNumber() ).masData().transformation().asMatrix()</pre></div>
<div class="skip"><span class="num"><pre>1381</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1382</pre></span><pre>		# compenstate for new parents transformation ?</pre></div>
<div class="cov"><span class="num"><pre>1383</pre></span><pre>		if parentnode is not None:</pre></div>
<div class="skip"><span class="num"><pre>1384</pre></span><pre>			# use world - inverse matrix</pre></div>
<div class="cov"><span class="num"><pre>1385</pre></span><pre>			parentInverseMatrix = parentnode.wim.elementByLogicalIndex( parentnode.instanceNumber( ) ).masData().transformation().asMatrix()</pre></div>
<div class="cov"><span class="num"><pre>1386</pre></span><pre>			nwm = nwm * parentInverseMatrix</pre></div>
<div class="skip"><span class="num"><pre>1387</pre></span><pre>		# END if there is a new parent</pre></div>
<div class="skip"><span class="num"><pre>1388</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1389</pre></span><pre>		self.set( api.MTransformationMatrix( nwm ) )</pre></div>
<div class="skip"><span class="num"><pre>1390</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1391</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1392</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1393</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1394</pre></span><pre>	def reparent( self, parentnode, renameOnClash=True, raiseOnInstance=True, keepWorldSpace = False ):</pre></div>
<div class="cov"><span class="num"><pre>1395</pre></span><pre>		&quot;&quot;&quot; Change the parent of all nodes ( also instances ) to be located below parentnode</pre></div>
<div class="skip"><span class="num"><pre>1396</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1397</pre></span><pre>		:param parentnode: Node instance of transform under which this node should be parented to</pre></div>
<div class="cov"><span class="num"><pre>1398</pre></span><pre>			if None, node will be reparented under the root ( which only works for transforms )</pre></div>
<div class="cov"><span class="num"><pre>1399</pre></span><pre>		:param renameOnClash: resolve nameclashes by automatically renaming the node to make it unique</pre></div>
<div class="cov"><span class="num"><pre>1400</pre></span><pre>		:param raiseOnInstance: if True, this method will raise if you try to reparent an instanced object.</pre></div>
<div class="cov"><span class="num"><pre>1401</pre></span><pre>			If false, instanced objects will be merged into the newly created path under parentnode, effectively</pre></div>
<div class="cov"><span class="num"><pre>1402</pre></span><pre>			eliminating all other paths , keeping the newly created one</pre></div>
<div class="cov"><span class="num"><pre>1403</pre></span><pre>		:param keepWorldSpace: if True and node to be reparented is a transform, the world space position</pre></div>
<div class="cov"><span class="num"><pre>1404</pre></span><pre>			will be kept by adjusting the transformation accordingly.</pre></div>
<div class="cov"><span class="num"><pre>1405</pre></span><pre>			**WARNNG**: Currently we reset pivots when doing so</pre></div>
<div class="skip"><span class="num"><pre>1406</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>1407</pre></span><pre>		:return : copy of self pointing to the new dag path self</pre></div>
<div class="skip"><span class="num"><pre>1408</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1409</pre></span><pre>		:note: will remove all instance of this object and leave this object at only one path -</pre></div>
<div class="cov"><span class="num"><pre>1410</pre></span><pre>			if this is not what you want, use the addChild method instead as it can properly handle this case</pre></div>
<div class="skip"><span class="num"><pre>1411</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1412</pre></span><pre>		:note: this method handles namespaces properly &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1413</pre></span><pre>		if raiseOnInstance and self.instanceCount( False ) &gt; 1:</pre></div>
<div class="cov"><span class="num"><pre>1414</pre></span><pre>			raise RuntimeError( &quot;%r is instanced - reparent operation would destroy direct instances&quot; % self )</pre></div>
<div class="skip"><span class="num"><pre>1415</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1416</pre></span><pre>		if not renameOnClash and parentnode and self != parentnode:</pre></div>
<div class="skip"><span class="num"><pre>1417</pre></span><pre>			# check existing children of parent and raise if same name exists</pre></div>
<div class="skip"><span class="num"><pre>1418</pre></span><pre>			# I think this check must be string based though as we are talking about</pre></div>
<div class="skip"><span class="num"><pre>1419</pre></span><pre>			# a possbly different api object with the same name - probably api will be faster</pre></div>
<div class="cov"><span class="num"><pre>1420</pre></span><pre>			testforobject = parentnode.fullChildName( self.basename( ) )	# append our name to the path</pre></div>
<div class="cov"><span class="num"><pre>1421</pre></span><pre>			if objExists( testforobject ):</pre></div>
<div class="cov"><span class="num"><pre>1422</pre></span><pre>				raise RuntimeError( &quot;Object %s did already exist&quot; % testforobject )</pre></div>
<div class="skip"><span class="num"><pre>1423</pre></span><pre>		# END rename on clash handling</pre></div>
<div class="skip"><span class="num"><pre>1424</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1425</pre></span><pre>		# keep existing transformation ? Set the transformation accordingly beforehand</pre></div>
<div class="cov"><span class="num"><pre>1426</pre></span><pre>		if keepWorldSpace:</pre></div>
<div class="skip"><span class="num"><pre>1427</pre></span><pre>			# transform check done in method</pre></div>
<div class="cov"><span class="num"><pre>1428</pre></span><pre>			self._setWorldspaceTransform( parentnode )</pre></div>
<div class="skip"><span class="num"><pre>1429</pre></span><pre>		# END if keep worldspace</pre></div>
<div class="skip"><span class="num"><pre>1430</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1431</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1432</pre></span><pre>		# As stupid dagmodifier cannot handle instances right ( as it works on MObjects</pre></div>
<div class="cov"><span class="num"><pre>1433</pre></span><pre>		mod = None		# create it once we are sure the operation takes place</pre></div>
<div class="cov"><span class="num"><pre>1434</pre></span><pre>		if parentnode:</pre></div>
<div class="cov"><span class="num"><pre>1435</pre></span><pre>			if parentnode == self:</pre></div>
<div class="cov"><span class="num"><pre>1436</pre></span><pre>				raise RuntimeError( &quot;Cannot parent object %s under itself&quot; % self )</pre></div>
<div class="skip"><span class="num"><pre>1437</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1438</pre></span><pre>			mod = undo.DagModifier( )</pre></div>
<div class="cov"><span class="num"><pre>1439</pre></span><pre>			mod.reparentNode( self.object(), parentnode.object() )</pre></div>
<div class="cov"><span class="num"><pre>1440</pre></span><pre>		else:</pre></div>
<div class="skip"><span class="num"><pre>1441</pre></span><pre>			# sanity check</pre></div>
<div class="cov"><span class="num"><pre>1442</pre></span><pre>			if isinstance( self, Shape ):</pre></div>
<div class="cov"><span class="num"><pre>1443</pre></span><pre>				raise RuntimeError( &quot;Shape %s cannot be parented under root '|' but needs a transform&quot; % self )</pre></div>
<div class="cov"><span class="num"><pre>1444</pre></span><pre>			mod = undo.DagModifier( )</pre></div>
<div class="cov"><span class="num"><pre>1445</pre></span><pre>			mod.reparentNode( self.object() )</pre></div>
<div class="skip"><span class="num"><pre>1446</pre></span><pre>		# END handle parent node</pre></div>
<div class="skip"><span class="num"><pre>1447</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1448</pre></span><pre>		mod.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1449</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1450</pre></span><pre>		# UPDATE DAG PATH</pre></div>
<div class="skip"><span class="num"><pre>1451</pre></span><pre>		# find it in parentnodes children</pre></div>
<div class="cov"><span class="num"><pre>1452</pre></span><pre>		if parentnode:</pre></div>
<div class="cov"><span class="num"><pre>1453</pre></span><pre>			for child in parentnode.children():</pre></div>
<div class="cov"><span class="num"><pre>1454</pre></span><pre>				if DependNode.__eq__( self, child ):</pre></div>
<div class="cov"><span class="num"><pre>1455</pre></span><pre>					return child</pre></div>
<div class="cov"><span class="num"><pre>1456</pre></span><pre>		else: # return updated version of ourselves</pre></div>
<div class="cov"><span class="num"><pre>1457</pre></span><pre>			return NodeFromObj( self.object() )</pre></div>
<div class="skip"><span class="num"><pre>1458</pre></span><pre>		# END post-handle parent Node</pre></div>
<div class="skip"><span class="num"><pre>1459</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1460</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>1461</pre></span><pre>		raise AssertionError( &quot;Could not find self in children after reparenting&quot; )</pre></div>
<div class="skip"><span class="num"><pre>1462</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1463</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1464</pre></span><pre>	def unparent(self, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>1465</pre></span><pre>		&quot;&quot;&quot;As `reparent`, but will unparent this transform under the scene root&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1466</pre></span><pre>		return self.reparent(None, **kwargs)</pre></div>
<div class="skip"><span class="num"><pre>1467</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1468</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1469</pre></span><pre>	def addInstancedChild( self, childNode, position=MFnDagNode.kNextPos ):</pre></div>
<div class="cov"><span class="num"><pre>1470</pre></span><pre>		&quot;&quot;&quot;Add childnode as instanced child to this node</pre></div>
<div class="skip"><span class="num"><pre>1471</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1472</pre></span><pre>		:note: for more information, see `addChild`</pre></div>
<div class="cov"><span class="num"><pre>1473</pre></span><pre>		:note: its a shortcut to addChild allowing to clearly indicate what is happening&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1474</pre></span><pre>		return self.addChild( childNode, position = position, keepExistingParent=True )</pre></div>
<div class="skip"><span class="num"><pre>1475</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1476</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1477</pre></span><pre>	def removeChild( self, childNode, allowZeroParents = False ):</pre></div>
<div class="cov"><span class="num"><pre>1478</pre></span><pre>		&quot;&quot;&quot;remove the given childNode ( being a child of this node ) from our child list, effectively</pre></div>
<div class="cov"><span class="num"><pre>1479</pre></span><pre>		parenting it under world !</pre></div>
<div class="skip"><span class="num"><pre>1480</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1481</pre></span><pre>		:param childNode: Node to unparent - if it is not one of our children, no change takes place</pre></div>
<div class="cov"><span class="num"><pre>1482</pre></span><pre>		:param allowZeroParents: if True, it is possible to leave a node unparented, thus no valid</pre></div>
<div class="cov"><span class="num"><pre>1483</pre></span><pre>			dag paths leads to it. If False, transforms will just be reparented under the world</pre></div>
<div class="cov"><span class="num"><pre>1484</pre></span><pre>		:return: copy of childnode pointing to the first valid dag path we find.</pre></div>
<div class="cov"><span class="num"><pre>1485</pre></span><pre>		:note: to prevent the child ( if transform ) to dangle in unknown space if the last instance</pre></div>
<div class="cov"><span class="num"><pre>1486</pre></span><pre>			is to be removed, it will instead be reparented to world.</pre></div>
<div class="cov"><span class="num"><pre>1487</pre></span><pre>		:note: removing shapes from their last parent will result in an error&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1488</pre></span><pre>		# reparent if we have a last-instance of something</pre></div>
<div class="cov"><span class="num"><pre>1489</pre></span><pre>		if not allowZeroParents:</pre></div>
<div class="cov"><span class="num"><pre>1490</pre></span><pre>			if childNode.instanceCount( False ) == 1:</pre></div>
<div class="nocov"><span class="num"><pre>1491</pre></span><pre>				if isinstance( childNode, Transform ):</pre></div>
<div class="nocov"><span class="num"><pre>1492</pre></span><pre>					return childNode.reparent( None )</pre></div>
<div class="nocov"><span class="num"><pre>1493</pre></span><pre>				else:</pre></div>
<div class="skip"><span class="num"><pre>1494</pre></span><pre>					# must be shape - raise</pre></div>
<div class="skip"><span class="num"><pre>1495</pre></span><pre>					# TODO: could create new transform node which is pretty close to the maya default behaviour</pre></div>
<div class="nocov"><span class="num"><pre>1496</pre></span><pre>					raise RuntimeError( &quot;Shapenodes cannot be unparented if no parent transform would be left&quot; )</pre></div>
<div class="skip"><span class="num"><pre>1497</pre></span><pre>			# END if instance count == 1</pre></div>
<div class="skip"><span class="num"><pre>1498</pre></span><pre>		# END if not allowZeroParents</pre></div>
<div class="skip"><span class="num"><pre>1499</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1500</pre></span><pre>		op = undo.GenericOperation( )</pre></div>
<div class="cov"><span class="num"><pre>1501</pre></span><pre>		dagfn = api.MFnDagNode( self.dagPath() )</pre></div>
<div class="skip"><span class="num"><pre>1502</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1503</pre></span><pre>		# The method will not fail if the child cannot be found in child list</pre></div>
<div class="skip"><span class="num"><pre>1504</pre></span><pre>		# just go ahead</pre></div>
<div class="skip"><span class="num"><pre>1505</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1506</pre></span><pre>		op.setDoitCmd( dagfn.removeChild, childNode.object() )</pre></div>
<div class="cov"><span class="num"><pre>1507</pre></span><pre>		op.setUndoitCmd( self.addChild, childNode, keepExistingParent=True )	# TODO: add child to position it had</pre></div>
<div class="cov"><span class="num"><pre>1508</pre></span><pre>		op.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1509</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1510</pre></span><pre>		return NodeFromObj( childNode.object() )	# will attach A new dag path respectively - it will just pick the first one it gets</pre></div>
<div class="skip"><span class="num"><pre>1511</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1512</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1513</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1514</pre></span><pre>	def addChild( self, childNode, position=MFnDagNode.kNextPos, keepExistingParent=False,</pre></div>
<div class="cov"><span class="num"><pre>1515</pre></span><pre>				 renameOnClash=True, keepWorldSpace = False ):</pre></div>
<div class="cov"><span class="num"><pre>1516</pre></span><pre>		&quot;&quot;&quot;Add the given childNode as child to this Node. Allows instancing !</pre></div>
<div class="skip"><span class="num"><pre>1517</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1518</pre></span><pre>		:param childNode: Node you wish to add</pre></div>
<div class="cov"><span class="num"><pre>1519</pre></span><pre>		:param position: the index to which to add the new child, kNextPos will add it as last child.</pre></div>
<div class="cov"><span class="num"><pre>1520</pre></span><pre>			It supports python style negative indices</pre></div>
<div class="cov"><span class="num"><pre>1521</pre></span><pre>		:param keepExistingParent: if True, the childNode will be instanced as it will</pre></div>
<div class="cov"><span class="num"><pre>1522</pre></span><pre>			have its previous parent and this one, if False, the previous parent will be removed</pre></div>
<div class="cov"><span class="num"><pre>1523</pre></span><pre>			from the child's parent list</pre></div>
<div class="cov"><span class="num"><pre>1524</pre></span><pre>		:param renameOnClash: resolve nameclashes by automatically renaming the node to make it unique</pre></div>
<div class="cov"><span class="num"><pre>1525</pre></span><pre>		:param keepWorldSpace: see `reparent`, only effective if the node is not instanced</pre></div>
<div class="cov"><span class="num"><pre>1526</pre></span><pre>		:return: childNode whose path is pointing to the new child location</pre></div>
<div class="cov"><span class="num"><pre>1527</pre></span><pre>		:raise ValueError: if keepWorldSpace is requested with directly instanced nodes</pre></div>
<div class="cov"><span class="num"><pre>1528</pre></span><pre>		:note: the keepExistingParent flag is custom implemented as it would remove all existng parentS,</pre></div>
<div class="cov"><span class="num"><pre>1529</pre></span><pre>			not just the one of the path behind the object ( it does not use a path, so it must remove all existing</pre></div>
<div class="cov"><span class="num"><pre>1530</pre></span><pre>			parents unfortunatly ! )</pre></div>
<div class="cov"><span class="num"><pre>1531</pre></span><pre>		:note: as maya internally handles add/remove child as instancing operation, even though</pre></div>
<div class="cov"><span class="num"><pre>1532</pre></span><pre>			keepExistingParent is False, it will mess up things and for a short period of time in fact</pre></div>
<div class="cov"><span class="num"><pre>1533</pre></span><pre>			have two n + 1 instances, right before one is unlinked, This still fills a slot or something, and</pre></div>
<div class="cov"><span class="num"><pre>1534</pre></span><pre>			isInstanced will be true, although the pathcount is 1.</pre></div>
<div class="cov"><span class="num"><pre>1535</pre></span><pre>			Long story short: if the item to be added to us is not instanced, we use reparent instead. It</pre></div>
<div class="cov"><span class="num"><pre>1536</pre></span><pre>			will not harm in direct instances, so its save to use.</pre></div>
<div class="cov"><span class="num"><pre>1537</pre></span><pre>		:note: if the instance count of the item is 1 and keepExistingParent is False, the position</pre></div>
<div class="cov"><span class="num"><pre>1538</pre></span><pre>			argument is being ignored&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1539</pre></span><pre>		# should we use reparent to get around an instance bug ?</pre></div>
<div class="cov"><span class="num"><pre>1540</pre></span><pre>		is_direct_instance = childNode.instanceCount( 0 ) &gt; 1</pre></div>
<div class="cov"><span class="num"><pre>1541</pre></span><pre>		if not keepExistingParent and not is_direct_instance:	# direct only</pre></div>
<div class="cov"><span class="num"><pre>1542</pre></span><pre>			return childNode.reparent( self, renameOnClash=renameOnClash, raiseOnInstance=False,</pre></div>
<div class="cov"><span class="num"><pre>1543</pre></span><pre>									  	keepWorldSpace = keepWorldSpace )</pre></div>
<div class="skip"><span class="num"><pre>1544</pre></span><pre>		# END reparent if not-instanced</pre></div>
<div class="skip"><span class="num"><pre>1545</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1546</pre></span><pre>		# CHILD ALREADY THERE ?</pre></div>
<div class="skip"><span class="num"><pre>1547</pre></span><pre>		#########################</pre></div>
<div class="skip"><span class="num"><pre>1548</pre></span><pre>		# We do not raise if the user already has what he wants</pre></div>
<div class="skip"><span class="num"><pre>1549</pre></span><pre>		# check if child is already part of our children</pre></div>
<div class="cov"><span class="num"><pre>1550</pre></span><pre>		children = None</pre></div>
<div class="skip"><span class="num"><pre>1551</pre></span><pre>		# lets speed things up - getting children is expensive</pre></div>
<div class="cov"><span class="num"><pre>1552</pre></span><pre>		if isinstance( childNode, Transform ):</pre></div>
<div class="cov"><span class="num"><pre>1553</pre></span><pre>			children = self.childTransforms( )</pre></div>
<div class="cov"><span class="num"><pre>1554</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>1555</pre></span><pre>			children = self.shapes( )</pre></div>
<div class="skip"><span class="num"><pre>1556</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1557</pre></span><pre>		# compare MObjects</pre></div>
<div class="cov"><span class="num"><pre>1558</pre></span><pre>		for exChild in children:</pre></div>
<div class="cov"><span class="num"><pre>1559</pre></span><pre>			if DependNode.__eq__( childNode, exChild ):</pre></div>
<div class="cov"><span class="num"><pre>1560</pre></span><pre>				return exChild								# exchild has proper dagpath</pre></div>
<div class="cov"><span class="num"><pre>1561</pre></span><pre>		del( children )			# release memory</pre></div>
<div class="skip"><span class="num"><pre>1562</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1563</pre></span><pre>		if not renameOnClash:</pre></div>
<div class="skip"><span class="num"><pre>1564</pre></span><pre>			# check existing children of parent and raise if same name exists</pre></div>
<div class="skip"><span class="num"><pre>1565</pre></span><pre>			# I think this check must be string based though as we are talking about</pre></div>
<div class="skip"><span class="num"><pre>1566</pre></span><pre>			# a possbly different api object with the same name - probably api will be faster</pre></div>
<div class="nocov"><span class="num"><pre>1567</pre></span><pre>			testforobject = self.fullChildName( childNode.basename( ) )	# append our name to the path</pre></div>
<div class="nocov"><span class="num"><pre>1568</pre></span><pre>			if objExists( testforobject ):</pre></div>
<div class="nocov"><span class="num"><pre>1569</pre></span><pre>				raise RuntimeError( &quot;Object %s did already exist below %r&quot; % ( testforobject , self ) )</pre></div>
<div class="skip"><span class="num"><pre>1570</pre></span><pre>		# END rename on clash handling</pre></div>
<div class="skip"><span class="num"><pre>1571</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1572</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1573</pre></span><pre>		# ADD CHILD</pre></div>
<div class="skip"><span class="num"><pre>1574</pre></span><pre>		###############</pre></div>
<div class="cov"><span class="num"><pre>1575</pre></span><pre>		op = undo.GenericOperationStack( )</pre></div>
<div class="skip"><span class="num"><pre>1576</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1577</pre></span><pre>		pos = position</pre></div>
<div class="cov"><span class="num"><pre>1578</pre></span><pre>		if pos != self.kNextPos:</pre></div>
<div class="nocov"><span class="num"><pre>1579</pre></span><pre>			pos = pythonIndex( pos, self.childCount() )</pre></div>
<div class="skip"><span class="num"><pre>1580</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1581</pre></span><pre>		dagfn = api.MFnDagNode( self.dagPath() )</pre></div>
<div class="cov"><span class="num"><pre>1582</pre></span><pre>		docmd = Call( dagfn.addChild, childNode.object(), pos, True )</pre></div>
<div class="cov"><span class="num"><pre>1583</pre></span><pre>		undocmd = Call( self.removeChild, childNode )</pre></div>
<div class="skip"><span class="num"><pre>1584</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1585</pre></span><pre>		op.addCmd( docmd, undocmd )</pre></div>
<div class="skip"><span class="num"><pre>1586</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1587</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1588</pre></span><pre>		# EXISTING PARENT HANDLING</pre></div>
<div class="skip"><span class="num"><pre>1589</pre></span><pre>		############################</pre></div>
<div class="skip"><span class="num"><pre>1590</pre></span><pre>		# if we do not keep parents, we also have to re-add it to the original parent</pre></div>
<div class="skip"><span class="num"><pre>1591</pre></span><pre>		# therefore wer create a dummy do with a real undo</pre></div>
<div class="cov"><span class="num"><pre>1592</pre></span><pre>		undocmdCall = None</pre></div>
<div class="cov"><span class="num"><pre>1593</pre></span><pre>		parentTransform = None</pre></div>
<div class="cov"><span class="num"><pre>1594</pre></span><pre>		if not keepExistingParent:</pre></div>
<div class="skip"><span class="num"><pre>1595</pre></span><pre>			# remove from childNode from its current parent ( could be world ! )</pre></div>
<div class="cov"><span class="num"><pre>1596</pre></span><pre>			parentTransform = childNode.parent( )</pre></div>
<div class="cov"><span class="num"><pre>1597</pre></span><pre>			validParent = parentTransform</pre></div>
<div class="cov"><span class="num"><pre>1598</pre></span><pre>			if not validParent:</pre></div>
<div class="skip"><span class="num"><pre>1599</pre></span><pre>				# get the world, but initialize the function set with an mobject !</pre></div>
<div class="skip"><span class="num"><pre>1600</pre></span><pre>				# works for do only in the world case !</pre></div>
<div class="nocov"><span class="num"><pre>1601</pre></span><pre>				worldobj = api.MFnDagNode( childNode.dagPath() ).parent( 0 )</pre></div>
<div class="nocov"><span class="num"><pre>1602</pre></span><pre>				validParent = DagNode( worldobj )</pre></div>
<div class="skip"><span class="num"><pre>1603</pre></span><pre>			# END if no valid parent</pre></div>
<div class="skip"><span class="num"><pre>1604</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1605</pre></span><pre>			docmd = Call( validParent.removeChild, childNode )</pre></div>
<div class="skip"><span class="num"><pre>1606</pre></span><pre>			# TODO: find current position of item at parent restore it exactly</pre></div>
<div class="cov"><span class="num"><pre>1607</pre></span><pre>			undocmdCall = Call( validParent.addChild, childNode, keepExistingParent= True )	# call ourselves</pre></div>
<div class="skip"><span class="num"><pre>1608</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1609</pre></span><pre>			# special case to add items back to world</pre></div>
<div class="skip"><span class="num"><pre>1610</pre></span><pre>			# MGlobal. AddToMOdel does not work, and addChild on the world dag node</pre></div>
<div class="skip"><span class="num"><pre>1611</pre></span><pre>			# does not work either when re-adding the child ( but when removing it !! )</pre></div>
<div class="skip"><span class="num"><pre>1612</pre></span><pre>			# clear undocmd as it will not work and bake a mel cmd !</pre></div>
<div class="cov"><span class="num"><pre>1613</pre></span><pre>			op.addCmd( docmd, undocmdCall )</pre></div>
<div class="skip"><span class="num"><pre>1614</pre></span><pre>		# END if not keep existing parent</pre></div>
<div class="skip"><span class="num"><pre>1615</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1616</pre></span><pre>		op.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1617</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1618</pre></span><pre>		# UPDATE THE DAG PATH OF CHILDNODE</pre></div>
<div class="skip"><span class="num"><pre>1619</pre></span><pre>		################################</pre></div>
<div class="skip"><span class="num"><pre>1620</pre></span><pre>		# find dag path at the used index</pre></div>
<div class="cov"><span class="num"><pre>1621</pre></span><pre>		dagIndex = pos</pre></div>
<div class="cov"><span class="num"><pre>1622</pre></span><pre>		if pos == self.kNextPos:</pre></div>
<div class="cov"><span class="num"><pre>1623</pre></span><pre>			dagIndex = self.childCount() - 1	# last entry as child got added</pre></div>
<div class="cov"><span class="num"><pre>1624</pre></span><pre>		newChildNode = NodeFromObj(MDagPathUtil.childPathAtIndex(self.dagPath(), dagIndex))</pre></div>
<div class="skip"><span class="num"><pre>1625</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1626</pre></span><pre>		# update undo cmd to use the newly created child with the respective dag path</pre></div>
<div class="cov"><span class="num"><pre>1627</pre></span><pre>		undocmd.args = [ newChildNode ]</pre></div>
<div class="skip"><span class="num"><pre>1628</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1629</pre></span><pre>		# ALTER CMD FOR WORLD SPECIAL CASE ?</pre></div>
<div class="skip"><span class="num"><pre>1630</pre></span><pre>		######################################</pre></div>
<div class="skip"><span class="num"><pre>1631</pre></span><pre>		# alter undo to readd childNode to world using MEL ? - need final name for</pre></div>
<div class="skip"><span class="num"><pre>1632</pre></span><pre>		# this, which is why we delay so much</pre></div>
<div class="cov"><span class="num"><pre>1633</pre></span><pre>		if not keepExistingParent and not parentTransform and undocmdCall is not None:			# have call and child is under world</pre></div>
<div class="nocov"><span class="num"><pre>1634</pre></span><pre>			undocmdCall.func = cmds.parent</pre></div>
<div class="nocov"><span class="num"><pre>1635</pre></span><pre>			undocmdCall.args = [ str( newChildNode ) ]</pre></div>
<div class="nocov"><span class="num"><pre>1636</pre></span><pre>			undocmdCall.kwargs = { &quot;add&quot;:1, &quot;world&quot;:1 }</pre></div>
<div class="skip"><span class="num"><pre>1637</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1638</pre></span><pre>		return newChildNode</pre></div>
<div class="skip"><span class="num"><pre>1639</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1640</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1641</pre></span><pre>	def addParent( self, parentnode, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>1642</pre></span><pre>		&quot;&quot;&quot;Adds ourselves as instance to the given parentnode at position</pre></div>
<div class="skip"><span class="num"><pre>1643</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1644</pre></span><pre>		:param kwargs: see `addChild`</pre></div>
<div class="cov"><span class="num"><pre>1645</pre></span><pre>		:return: self with updated dag path&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1646</pre></span><pre>		kwargs.pop( &quot;keepExistingParent&quot;, None )</pre></div>
<div class="cov"><span class="num"><pre>1647</pre></span><pre>		return parentnode.addChild( self, keepExistingParent = True, **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>1648</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1649</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1650</pre></span><pre>	def setParent( self, parentnode, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>1651</pre></span><pre>		&quot;&quot;&quot;Change the parent of self to parentnode being placed at position</pre></div>
<div class="skip"><span class="num"><pre>1652</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1653</pre></span><pre>		:param kwargs: see `addChild`</pre></div>
<div class="cov"><span class="num"><pre>1654</pre></span><pre>		:return: self with updated dag path&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1655</pre></span><pre>		kwargs.pop( &quot;keepExistingParent&quot;, None )	# knock off our changed attr</pre></div>
<div class="cov"><span class="num"><pre>1656</pre></span><pre>		return parentnode.addChild( self, keepExistingParent = False,  **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>1657</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1658</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1659</pre></span><pre>	def removeParent( self, parentnode  ):</pre></div>
<div class="cov"><span class="num"><pre>1660</pre></span><pre>		&quot;&quot;&quot;Remove ourselves from given parentnode</pre></div>
<div class="skip"><span class="num"><pre>1661</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1662</pre></span><pre>		:return: None&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1663</pre></span><pre>		return parentnode.removeChild( self )</pre></div>
<div class="skip"><span class="num"><pre>1664</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1665</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1666</pre></span><pre>	#} END DAG modification</pre></div>
<div class="skip"><span class="num"><pre>1667</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1668</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>1669</pre></span><pre>	def delete( self ):</pre></div>
<div class="cov"><span class="num"><pre>1670</pre></span><pre>		&quot;&quot;&quot;Delete this node - this special version must be</pre></div>
<div class="skip"><span class="num"><pre>1671</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1672</pre></span><pre>		:note: if the undo queue is enabled, the object becomes invalid, but stays alive until it</pre></div>
<div class="cov"><span class="num"><pre>1673</pre></span><pre>			drops off the queue</pre></div>
<div class="cov"><span class="num"><pre>1674</pre></span><pre>		:note: if you want to delete many nodes, its more efficient to delete them</pre></div>
<div class="cov"><span class="num"><pre>1675</pre></span><pre>			using the global `delete` method&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1676</pre></span><pre>		mod = undo.DagModifier( )</pre></div>
<div class="cov"><span class="num"><pre>1677</pre></span><pre>		mod.deleteNode( self.object() )</pre></div>
<div class="cov"><span class="num"><pre>1678</pre></span><pre>		mod.doIt()</pre></div>
<div class="skip"><span class="num"><pre>1679</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1680</pre></span><pre>	#{ Edit</pre></div>
<div class="skip"><span class="num"><pre>1681</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1682</pre></span><pre>	@notundoable</pre></div>
<div class="cov"><span class="num"><pre>1683</pre></span><pre>	def duplicate( self, newpath='', autocreateNamespace=True, renameOnClash=True,</pre></div>
<div class="cov"><span class="num"><pre>1684</pre></span><pre>				   newTransform = False, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>1685</pre></span><pre>		&quot;&quot;&quot;Duplciate the given node to newpath</pre></div>
<div class="skip"><span class="num"><pre>1686</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1687</pre></span><pre>		:param newpath: result depends on its format:</pre></div>
<div class="skip"><span class="num"><pre>1688</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>1689</pre></span><pre>			 * '' - empty string, creates a unique name based on the actual node name by appending a copy number</pre></div>
<div class="cov"><span class="num"><pre>1690</pre></span><pre>			   to it, if newTransform is True, the newly created shape/transform will keep its name, but receives a new parent</pre></div>
<div class="cov"><span class="num"><pre>1691</pre></span><pre>			 * 'newname' - relative path, the node will be duplicated not changing its current parent if newTransform is False</pre></div>
<div class="cov"><span class="num"><pre>1692</pre></span><pre>			 * ``|parent|newname`` - absolute path, the node will be duplicated and reparented under the given path</pre></div>
<div class="cov"><span class="num"><pre>1693</pre></span><pre>				if newTransform is True, a new transform name will be created based on your name by appending a unique copy number</pre></div>
<div class="skip"><span class="num"><pre>1694</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>1695</pre></span><pre>		:param autocreateNamespace: if true, namespaces given in newpath will be created automatically, otherwise</pre></div>
<div class="cov"><span class="num"><pre>1696</pre></span><pre>			a RuntimeException will be thrown if a required namespace does not exist</pre></div>
<div class="cov"><span class="num"><pre>1697</pre></span><pre>		:param renameOnClash: if true, clashing names will automatically be resolved by adjusting the name</pre></div>
<div class="cov"><span class="num"><pre>1698</pre></span><pre>		:param newTransform: if True, a new transform will be created based on the name of the parent transform</pre></div>
<div class="cov"><span class="num"><pre>1699</pre></span><pre>			of this shape node, appending a unique copy number to it.</pre></div>
<div class="cov"><span class="num"><pre>1700</pre></span><pre>			Only has an effect for shape nodes</pre></div>
<div class="cov"><span class="num"><pre>1701</pre></span><pre>		:return: newly create Node</pre></div>
<div class="cov"><span class="num"><pre>1702</pre></span><pre>		:note: duplicate performance could be improved by checking more before doing work that does not</pre></div>
<div class="cov"><span class="num"><pre>1703</pre></span><pre>			really change the scene, but adds undo operations</pre></div>
<div class="cov"><span class="num"><pre>1704</pre></span><pre>		:note: inbetween parents are always required as needed</pre></div>
<div class="cov"><span class="num"><pre>1705</pre></span><pre>		:todo: add example for each version of newpath</pre></div>
<div class="cov"><span class="num"><pre>1706</pre></span><pre>		:note: instancing can be realized using the `addChild` function</pre></div>
<div class="cov"><span class="num"><pre>1707</pre></span><pre>		:note: If meshes have tweaks applied, the duplicate will not have these tweaks and the meshes will look</pre></div>
<div class="cov"><span class="num"><pre>1708</pre></span><pre>			mislocated.</pre></div>
<div class="cov"><span class="num"><pre>1709</pre></span><pre>			Using MEL works in that case ... ( they fixed it there obviously ) , but creates invalid objects</pre></div>
<div class="cov"><span class="num"><pre>1710</pre></span><pre>		:todo: Undo implementation - every undoable operation must in fact be based on strings to really work, all</pre></div>
<div class="cov"><span class="num"><pre>1711</pre></span><pre>			this is far too much - dagNode.duplicate must be undoable by itself</pre></div>
<div class="cov"><span class="num"><pre>1712</pre></span><pre>		:todo: duplicate should be completely reimplemented to support all mel options and actually work with</pre></div>
<div class="cov"><span class="num"><pre>1713</pre></span><pre>			meshes and tweaks - the underlying api duplication would still be used of course, as well as</pre></div>
<div class="cov"><span class="num"><pre>1714</pre></span><pre>			connections ( to sets ) and so on ... &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1715</pre></span><pre>		selfIsShape = isinstance( self, Shape )</pre></div>
<div class="skip"><span class="num"><pre>1716</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1717</pre></span><pre>		# NAME HANDLING</pre></div>
<div class="skip"><span class="num"><pre>1718</pre></span><pre>		# create a valid absolute name to have less special cases later on</pre></div>
<div class="skip"><span class="num"><pre>1719</pre></span><pre>		# if there is no name given, create a name</pre></div>
<div class="cov"><span class="num"><pre>1720</pre></span><pre>		if not newpath:		# &quot;&quot; or None</pre></div>
<div class="cov"><span class="num"><pre>1721</pre></span><pre>			if newTransform:</pre></div>
<div class="cov"><span class="num"><pre>1722</pre></span><pre>				newpath = &quot;%s|%s&quot; % ( _getUniqueName( self.transform( ) ), self.basename() )</pre></div>
<div class="cov"><span class="num"><pre>1723</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>1724</pre></span><pre>				newpath = _getUniqueName( self )</pre></div>
<div class="skip"><span class="num"><pre>1725</pre></span><pre>			# END newTransform if there is no new path given</pre></div>
<div class="cov"><span class="num"><pre>1726</pre></span><pre>		elif newTransform and selfIsShape:</pre></div>
<div class="nocov"><span class="num"><pre>1727</pre></span><pre>			newpath = &quot;%s|%s&quot; % ( _getUniqueName( self.transform( ) ), newpath.split('|')[-1] )</pre></div>
<div class="cov"><span class="num"><pre>1728</pre></span><pre>		elif '|' not in newpath:</pre></div>
<div class="cov"><span class="num"><pre>1729</pre></span><pre>			myparent = self.parent()</pre></div>
<div class="cov"><span class="num"><pre>1730</pre></span><pre>			parentname = &quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1731</pre></span><pre>			if myparent is not None:</pre></div>
<div class="cov"><span class="num"><pre>1732</pre></span><pre>				parentname = str( myparent )</pre></div>
<div class="cov"><span class="num"><pre>1733</pre></span><pre>			newpath = &quot;%s|%s&quot; % ( parentname, newpath )</pre></div>
<div class="skip"><span class="num"><pre>1734</pre></span><pre>		# END path name handling</pre></div>
<div class="skip"><span class="num"><pre>1735</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1736</pre></span><pre>		# Instance Parent Check</pre></div>
<div class="cov"><span class="num"><pre>1737</pre></span><pre>		dagtokens = newpath.split( '|' )</pre></div>
<div class="skip"><span class="num"><pre>1738</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1739</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1740</pre></span><pre>		# ASSERT NAME</pre></div>
<div class="skip"><span class="num"><pre>1741</pre></span><pre>		#############</pre></div>
<div class="skip"><span class="num"><pre>1742</pre></span><pre>		# need at least transform and shapename if path is absolute</pre></div>
<div class="cov"><span class="num"><pre>1743</pre></span><pre>		numtokens = 3				# like &quot;|parent|shape&quot; -&gt; ['','parent', 'shape']</pre></div>
<div class="cov"><span class="num"><pre>1744</pre></span><pre>		shouldbe = '|transformname|shapename'</pre></div>
<div class="cov"><span class="num"><pre>1745</pre></span><pre>		if not selfIsShape:</pre></div>
<div class="cov"><span class="num"><pre>1746</pre></span><pre>			numtokens = 2			# like &quot;|parent&quot; -&gt; ['','parent']</pre></div>
<div class="cov"><span class="num"><pre>1747</pre></span><pre>			shouldbe = '|transformname'</pre></div>
<div class="skip"><span class="num"><pre>1748</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1749</pre></span><pre>		if '|' in newpath and ( newpath == '|' or len( dagtokens ) &lt; numtokens ):</pre></div>
<div class="cov"><span class="num"><pre>1750</pre></span><pre>			raise NameError( &quot;Duplicate paths should be at least %s, was %s&quot; % ( shouldbe, newpath ) )</pre></div>
<div class="skip"><span class="num"><pre>1751</pre></span><pre>		# END not instance path checking</pre></div>
<div class="skip"><span class="num"><pre>1752</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1753</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1754</pre></span><pre>		# TARGET EXISTS ?</pre></div>
<div class="skip"><span class="num"><pre>1755</pre></span><pre>		#####################</pre></div>
<div class="cov"><span class="num"><pre>1756</pre></span><pre>		if '|' in newpath and objExists( newpath ):</pre></div>
<div class="cov"><span class="num"><pre>1757</pre></span><pre>			exnode = NodeFromStr( newpath )</pre></div>
<div class="cov"><span class="num"><pre>1758</pre></span><pre>			if not isinstance( exnode, self.__class__ ):</pre></div>
<div class="cov"><span class="num"><pre>1759</pre></span><pre>				raise RuntimeError( &quot;Existing object at path %s was of type %s, should be %s&quot;</pre></div>
<div class="cov"><span class="num"><pre>1760</pre></span><pre>									% ( newpath, exnode.__class__.__name__, self.__class__.__name__ ) )</pre></div>
<div class="nocov"><span class="num"><pre>1761</pre></span><pre>			return 	exnode# return already existing one as it has a compatible type</pre></div>
<div class="skip"><span class="num"><pre>1762</pre></span><pre>		# END target exists check</pre></div>
<div class="skip"><span class="num"><pre>1763</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1764</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1765</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1766</pre></span><pre>		# DUPLICATE IT WITHOUT UNDO</pre></div>
<div class="skip"><span class="num"><pre>1767</pre></span><pre>		############################</pre></div>
<div class="skip"><span class="num"><pre>1768</pre></span><pre>		# it will always duplicate the transform and return it</pre></div>
<div class="skip"><span class="num"><pre>1769</pre></span><pre>		# in case of instances, its the only way we have to get it below an own parent</pre></div>
<div class="skip"><span class="num"><pre>1770</pre></span><pre>		# bake all names into strings for undo and redo</pre></div>
<div class="cov"><span class="num"><pre>1771</pre></span><pre>		duplicate_node_parent = NodeFromObj( api.MFnDagNode( self.dagPath() ).duplicate( False, False ) )		# get the duplicate</pre></div>
<div class="skip"><span class="num"><pre>1772</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1773</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1774</pre></span><pre>		# RENAME DUPLICATE CHILDREN</pre></div>
<div class="skip"><span class="num"><pre>1775</pre></span><pre>		###########################</pre></div>
<div class="skip"><span class="num"><pre>1776</pre></span><pre>		#</pre></div>
<div class="cov"><span class="num"><pre>1777</pre></span><pre>		childsourceparent = self.transform()			# works if we are a transform as well</pre></div>
<div class="cov"><span class="num"><pre>1778</pre></span><pre>		self_shape_duplicated = None		# store Node of duplicates that corresponds to us ( only if self is shape )</pre></div>
<div class="skip"><span class="num"><pre>1779</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1780</pre></span><pre>		srcchildren = childsourceparent.childrenDeep( )</pre></div>
<div class="cov"><span class="num"><pre>1781</pre></span><pre>		destchildren = duplicate_node_parent.childrenDeep( )</pre></div>
<div class="skip"><span class="num"><pre>1782</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1783</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1784</pre></span><pre>		if len( srcchildren ) != len( destchildren ):</pre></div>
<div class="skip"><span class="num"><pre>1785</pre></span><pre>			# Happens if we have duplicated a shape, whose transform hat several shapes</pre></div>
<div class="skip"><span class="num"><pre>1786</pre></span><pre>			# To find usually, there should be only one shape which is our duplicated shape</pre></div>
<div class="cov"><span class="num"><pre>1787</pre></span><pre>			if len( destchildren ) != 1:</pre></div>
<div class="nocov"><span class="num"><pre>1788</pre></span><pre>				raise AssertionError( &quot;Expected %s to have exactly one child, but it had %i&quot; % ( duplicate_node_parent, len( destchildren ) ) )</pre></div>
<div class="cov"><span class="num"><pre>1789</pre></span><pre>			self_shape_duplicated = destchildren[0].rename( self.basename() )</pre></div>
<div class="cov"><span class="num"><pre>1790</pre></span><pre>		else:</pre></div>
<div class="skip"><span class="num"><pre>1791</pre></span><pre>			# this is the only part where we have a one-one relationship between the original children</pre></div>
<div class="skip"><span class="num"><pre>1792</pre></span><pre>			# and their copies - store the id the current basename once we encounter it</pre></div>
<div class="cov"><span class="num"><pre>1793</pre></span><pre>			selfbasename = self.basename()</pre></div>
<div class="cov"><span class="num"><pre>1794</pre></span><pre>			for i,targetchild in enumerate( destchildren ):</pre></div>
<div class="cov"><span class="num"><pre>1795</pre></span><pre>				srcchildbasename = srcchildren[i].basename( )</pre></div>
<div class="cov"><span class="num"><pre>1796</pre></span><pre>				targetchild.rename( srcchildbasename )</pre></div>
<div class="skip"><span class="num"><pre>1797</pre></span><pre>				# HACK: we should only check the intermediate children, but actually conisder them deep</pre></div>
<div class="skip"><span class="num"><pre>1798</pre></span><pre>				# trying to reduce risk of problem by only setting duplicate_shape_index once</pre></div>
<div class="cov"><span class="num"><pre>1799</pre></span><pre>				if not self_shape_duplicated and selfbasename == srcchildbasename:</pre></div>
<div class="cov"><span class="num"><pre>1800</pre></span><pre>					self_shape_duplicated = targetchild</pre></div>
<div class="skip"><span class="num"><pre>1801</pre></span><pre>			# END for each child to rename</pre></div>
<div class="skip"><span class="num"><pre>1802</pre></span><pre>		# END CHILD RENAME</pre></div>
<div class="skip"><span class="num"><pre>1803</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1804</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1805</pre></span><pre>		# REPARENT</pre></div>
<div class="skip"><span class="num"><pre>1806</pre></span><pre>		###############</pre></div>
<div class="skip"><span class="num"><pre>1807</pre></span><pre>		# create requested parents of our duplicate</pre></div>
<div class="cov"><span class="num"><pre>1808</pre></span><pre>		parenttokens = dagtokens[:-1]</pre></div>
<div class="cov"><span class="num"><pre>1809</pre></span><pre>		leafobjectname = dagtokens[-1]		# the basename of the dagpath</pre></div>
<div class="cov"><span class="num"><pre>1810</pre></span><pre>		duplparentname = None</pre></div>
<div class="cov"><span class="num"><pre>1811</pre></span><pre>		if selfIsShape and newTransform:</pre></div>
<div class="cov"><span class="num"><pre>1812</pre></span><pre>			parenttokens = dagtokens[:-2]	# the parent of the duplicate node parent transform</pre></div>
<div class="cov"><span class="num"><pre>1813</pre></span><pre>			duplparentname = dagtokens[-2]</pre></div>
<div class="skip"><span class="num"><pre>1814</pre></span><pre>		# END shape and new transform handling</pre></div>
<div class="skip"><span class="num"><pre>1815</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1816</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1817</pre></span><pre>		if parenttokens:			# could be [''] too if newpath = '|newpath'</pre></div>
<div class="cov"><span class="num"><pre>1818</pre></span><pre>			parentnodepath = '|'.join( parenttokens )</pre></div>
<div class="cov"><span class="num"><pre>1819</pre></span><pre>			parentnode = childsourceparent			# in case we have a relative name</pre></div>
<div class="skip"><span class="num"><pre>1820</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1821</pre></span><pre>			# happens on input like &quot;|name&quot;,</pre></div>
<div class="skip"><span class="num"><pre>1822</pre></span><pre>			# handle case that we are duplicating a transform and end up with a name</pre></div>
<div class="skip"><span class="num"><pre>1823</pre></span><pre>			# that already exists - createNode will return the existing one, and error if</pre></div>
<div class="skip"><span class="num"><pre>1824</pre></span><pre>			# the type does not match</pre></div>
<div class="skip"><span class="num"><pre>1825</pre></span><pre>			# We have to keep the duplicate as it contains duplicated values that are not</pre></div>
<div class="skip"><span class="num"><pre>1826</pre></span><pre>			# present in a generic newly created transform node</pre></div>
<div class="cov"><span class="num"><pre>1827</pre></span><pre>			parentnode = None</pre></div>
<div class="cov"><span class="num"><pre>1828</pre></span><pre>			if cmds.objExists( parentnodepath ):</pre></div>
<div class="cov"><span class="num"><pre>1829</pre></span><pre>				parentnode = NodeFromStr( parentnodepath )</pre></div>
<div class="cov"><span class="num"><pre>1830</pre></span><pre>			elif parentnodepath != '':</pre></div>
<div class="cov"><span class="num"><pre>1831</pre></span><pre>				parentnode = createNode( parentnodepath, &quot;transform&quot;,</pre></div>
<div class="cov"><span class="num"><pre>1832</pre></span><pre>			     						  renameOnClash=renameOnClash,</pre></div>
<div class="cov"><span class="num"><pre>1833</pre></span><pre>										  autocreateNamespace=autocreateNamespace )</pre></div>
<div class="skip"><span class="num"><pre>1834</pre></span><pre>			# END create parent handling</pre></div>
<div class="skip"><span class="num"><pre>1835</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1836</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1837</pre></span><pre>			# reparent our own duplicated node - this is always a transform at this</pre></div>
<div class="skip"><span class="num"><pre>1838</pre></span><pre>			# point</pre></div>
<div class="cov"><span class="num"><pre>1839</pre></span><pre>			if parentnode is not None:</pre></div>
<div class="cov"><span class="num"><pre>1840</pre></span><pre>				if selfIsShape and not newTransform:</pre></div>
<div class="skip"><span class="num"><pre>1841</pre></span><pre>					# duplicate_shape_parent is not needed, reparent shape to our valid parent</pre></div>
<div class="skip"><span class="num"><pre>1842</pre></span><pre>					# name and remove the intermediate parent</pre></div>
<div class="cov"><span class="num"><pre>1843</pre></span><pre>					self_shape_duplicated = self_shape_duplicated.reparent( parentnode, renameOnClash = renameOnClash )</pre></div>
<div class="cov"><span class="num"><pre>1844</pre></span><pre>					if str( duplicate_node_parent ) not in str( parentnode ):</pre></div>
<div class="cov"><span class="num"><pre>1845</pre></span><pre>						duplicate_node_parent.delete()</pre></div>
<div class="cov"><span class="num"><pre>1846</pre></span><pre>						duplicate_node_parent = None</pre></div>
<div class="skip"><span class="num"><pre>1847</pre></span><pre>					# END if we may delete the duplicate node parent</pre></div>
<div class="skip"><span class="num"><pre>1848</pre></span><pre>				# END self is shape</pre></div>
<div class="cov"><span class="num"><pre>1849</pre></span><pre>				else:</pre></div>
<div class="skip"><span class="num"><pre>1850</pre></span><pre>					# we are a transform and will reparent under our destined parent node</pre></div>
<div class="cov"><span class="num"><pre>1851</pre></span><pre>					duplicate_node_parent = duplicate_node_parent.reparent( parentnode, renameOnClash=renameOnClash )</pre></div>
<div class="skip"><span class="num"><pre>1852</pre></span><pre>			# END if there is a new parent node</pre></div>
<div class="skip"><span class="num"><pre>1853</pre></span><pre>		# END PARENT HANDLING</pre></div>
<div class="skip"><span class="num"><pre>1854</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1855</pre></span><pre>		# if we are a shape duplication, we have to rename the duplicated parent node as well</pre></div>
<div class="skip"><span class="num"><pre>1856</pre></span><pre>		# since maya's duplication routine really does a lot to change my names :)</pre></div>
<div class="cov"><span class="num"><pre>1857</pre></span><pre>		if duplparentname and duplicate_node_parent is not None:</pre></div>
<div class="cov"><span class="num"><pre>1858</pre></span><pre>			duplicate_node_parent = duplicate_node_parent.rename( duplparentname, renameOnClash=renameOnClash )</pre></div>
<div class="skip"><span class="num"><pre>1859</pre></span><pre>		# END dupl parent rename</pre></div>
<div class="skip"><span class="num"><pre>1860</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1861</pre></span><pre>		# FIND RETURN NODE</pre></div>
<div class="skip"><span class="num"><pre>1862</pre></span><pre>		######################</pre></div>
<div class="cov"><span class="num"><pre>1863</pre></span><pre>		final_node = rename_target = duplicate_node_parent		# item that is to be renamed to the final name later</pre></div>
<div class="skip"><span class="num"><pre>1864</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1865</pre></span><pre>		# rename target must be the child matching our name</pre></div>
<div class="cov"><span class="num"><pre>1866</pre></span><pre>		if selfIsShape:	# want shape, have transform</pre></div>
<div class="cov"><span class="num"><pre>1867</pre></span><pre>			final_node = rename_target = self_shape_duplicated</pre></div>
<div class="skip"><span class="num"><pre>1868</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1869</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1870</pre></span><pre>		# RENAME TARGET</pre></div>
<div class="skip"><span class="num"><pre>1871</pre></span><pre>		# rename the target to match the leaf of the path</pre></div>
<div class="skip"><span class="num"><pre>1872</pre></span><pre>		# we currently do not check whether the name is already set</pre></div>
<div class="skip"><span class="num"><pre>1873</pre></span><pre>		# - the rename method does that for us</pre></div>
<div class="cov"><span class="num"><pre>1874</pre></span><pre>		final_node = rename_target.rename( leafobjectname, autocreateNamespace = autocreateNamespace,</pre></div>
<div class="cov"><span class="num"><pre>1875</pre></span><pre>										  	renameOnClash=renameOnClash )</pre></div>
<div class="skip"><span class="num"><pre>1876</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1877</pre></span><pre>		# call our base class to copy additional information</pre></div>
<div class="cov"><span class="num"><pre>1878</pre></span><pre>		self.copyTo( final_node, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>1879</pre></span><pre>		return final_node</pre></div>
<div class="skip"><span class="num"><pre>1880</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1881</pre></span><pre>	#} END edit</pre></div>
<div class="skip"><span class="num"><pre>1882</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1883</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1884</pre></span><pre>	#{ DAG Status Information</pre></div>
<div class="cov"><span class="num"><pre>1885</pre></span><pre>	def _checkHierarchyVal( self, plugName, cmpval ):</pre></div>
<div class="cov"><span class="num"><pre>1886</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1887</pre></span><pre>		:return: cmpval if the plug value of one of the parents equals cmpval</pre></div>
<div class="cov"><span class="num"><pre>1888</pre></span><pre>			as well as the current entity&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1889</pre></span><pre>		if getattr( self, plugName ).asInt() == cmpval:</pre></div>
<div class="cov"><span class="num"><pre>1890</pre></span><pre>			return cmpval</pre></div>
<div class="skip"><span class="num"><pre>1891</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1892</pre></span><pre>		for parent in self.iterParents():</pre></div>
<div class="cov"><span class="num"><pre>1893</pre></span><pre>			if getattr( parent, plugName ).asInt() == cmpval:</pre></div>
<div class="cov"><span class="num"><pre>1894</pre></span><pre>				return cmpval</pre></div>
<div class="skip"><span class="num"><pre>1895</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1896</pre></span><pre>		return 1 - cmpval</pre></div>
<div class="skip"><span class="num"><pre>1897</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1898</pre></span><pre>	def _getDisplayOverrideValue( self, plugName ):</pre></div>
<div class="cov"><span class="num"><pre>1899</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1900</pre></span><pre>		:return: the given effective display override value or None if display</pre></div>
<div class="cov"><span class="num"><pre>1901</pre></span><pre>			overrides are disabled&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1902</pre></span><pre>		if self.do.mchildByName('ove').asInt():</pre></div>
<div class="nocov"><span class="num"><pre>1903</pre></span><pre>			return getattr( self.do, plugName ).asInt()</pre></div>
<div class="skip"><span class="num"><pre>1904</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1905</pre></span><pre>		for parent in self.iterParents():</pre></div>
<div class="cov"><span class="num"><pre>1906</pre></span><pre>			if parent.do.mchildByName('ove').asInt():</pre></div>
<div class="cov"><span class="num"><pre>1907</pre></span><pre>				return parent.do.mchildByName(plugName).asInt()</pre></div>
<div class="skip"><span class="num"><pre>1908</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1909</pre></span><pre>		return None</pre></div>
<div class="skip"><span class="num"><pre>1910</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1911</pre></span><pre>	def isVisible( self ):</pre></div>
<div class="cov"><span class="num"><pre>1912</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1913</pre></span><pre>		:return: True if this node is visible - its visible if itself and all parents are</pre></div>
<div class="cov"><span class="num"><pre>1914</pre></span><pre>			visible&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1915</pre></span><pre>		return self._checkHierarchyVal( 'v', False )</pre></div>
<div class="skip"><span class="num"><pre>1916</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1917</pre></span><pre>	def isTemplate( self ):</pre></div>
<div class="cov"><span class="num"><pre>1918</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1919</pre></span><pre>		:return: True if this node is templated - this is the case if itself or one of its</pre></div>
<div class="cov"><span class="num"><pre>1920</pre></span><pre>			parents are templated &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1921</pre></span><pre>		return self._checkHierarchyVal( 'tmp', True )</pre></div>
<div class="skip"><span class="num"><pre>1922</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1923</pre></span><pre>	def displayOverrideValue( self, plugName ):</pre></div>
<div class="cov"><span class="num"><pre>1924</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1925</pre></span><pre>		:return: the override display value actually identified by plugName affecting</pre></div>
<div class="cov"><span class="num"><pre>1926</pre></span><pre>			the given object ( that should be a leaf node for the result you see in the viewport.</pre></div>
<div class="cov"><span class="num"><pre>1927</pre></span><pre>			The display type in effect is always the last one set in the hierarchy</pre></div>
<div class="cov"><span class="num"><pre>1928</pre></span><pre>			returns None display overrides are disabled&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1929</pre></span><pre>		return self._getDisplayOverrideValue( plugName )</pre></div>
<div class="skip"><span class="num"><pre>1930</pre></span><pre>	#} END dag status information</pre></div>
<div class="skip"><span class="num"><pre>1931</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1932</pre></span><pre>	def isValid( self ):</pre></div>
<div class="cov"><span class="num"><pre>1933</pre></span><pre>		&quot;&quot;&quot;:return: True if the object exists in the scene</pre></div>
<div class="cov"><span class="num"><pre>1934</pre></span><pre>		:note: Handles DAG objects correctly that can be instanced, in which case</pre></div>
<div class="cov"><span class="num"><pre>1935</pre></span><pre>			the MObject may be valid , but the respective dag path is not.</pre></div>
<div class="cov"><span class="num"><pre>1936</pre></span><pre>			Additionally, if the object is not parented below any object, everything appears</pre></div>
<div class="cov"><span class="num"><pre>1937</pre></span><pre>			to be valid, but the path name is empty &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1938</pre></span><pre>		return self.dagPath().isValid() and self.dagPath().fullPathName() != '' and DependNode.isValid( self )</pre></div>
<div class="skip"><span class="num"><pre>1939</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1940</pre></span><pre>	def name( self ):</pre></div>
<div class="cov"><span class="num"><pre>1941</pre></span><pre>		&quot;&quot;&quot;:return: fully qualified ( long ) name of this dag node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1942</pre></span><pre>		return self.fullPathName( )</pre></div>
<div class="skip"><span class="num"><pre>1943</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>1944</pre></span><pre>	# override dependnode implementation with the original one</pre></div>
<div class="cov"><span class="num"><pre>1945</pre></span><pre>	basename = iDagItem.basename</pre></div>
<div class="skip"><span class="num"><pre>1946</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>1947</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>1948</pre></span><pre>	#{ DAG Query</pre></div>
<div class="skip"><span class="num"><pre>1949</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1950</pre></span><pre>	def parentAtIndex( self, index ):</pre></div>
<div class="cov"><span class="num"><pre>1951</pre></span><pre>		&quot;&quot;&quot;:return: Node of the parent at the given index - non-instanced nodes only have one parent</pre></div>
<div class="cov"><span class="num"><pre>1952</pre></span><pre>		:note: if a node is instanced, it can have `parentCount` parents</pre></div>
<div class="cov"><span class="num"><pre>1953</pre></span><pre>		:todo: Update dagpath afterwards ! Use dagpaths instead !&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1954</pre></span><pre>		sutil = api.MScriptUtil()</pre></div>
<div class="cov"><span class="num"><pre>1955</pre></span><pre>		sutil.createFromInt(index)</pre></div>
<div class="cov"><span class="num"><pre>1956</pre></span><pre>		uint = sutil.asUint()</pre></div>
<div class="skip"><span class="num"><pre>1957</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1958</pre></span><pre>		return NodeFromObj( api.MFnDagNode(self.dagPath()).parent( uint ) )</pre></div>
<div class="skip"><span class="num"><pre>1959</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1960</pre></span><pre>	def transform( self ):</pre></div>
<div class="cov"><span class="num"><pre>1961</pre></span><pre>		&quot;&quot;&quot;:return: Node to lowest transform in the path attached to our node</pre></div>
<div class="cov"><span class="num"><pre>1962</pre></span><pre>		:note: for shapes this is the parent, for transforms the transform itself&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1963</pre></span><pre>		# this should be faster than asking maya for the path and converting</pre></div>
<div class="skip"><span class="num"><pre>1964</pre></span><pre>		# back to a Node</pre></div>
<div class="cov"><span class="num"><pre>1965</pre></span><pre>		if isinstance( self, Transform ):</pre></div>
<div class="cov"><span class="num"><pre>1966</pre></span><pre>			return self</pre></div>
<div class="cov"><span class="num"><pre>1967</pre></span><pre>		return NodeFromObj( self.dagPath().transform( ) )</pre></div>
<div class="skip"><span class="num"><pre>1968</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1969</pre></span><pre>	def parent( self ):</pre></div>
<div class="cov"><span class="num"><pre>1970</pre></span><pre>		&quot;&quot;&quot;:return: Maya node of the parent of this instance or None if this is the root&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>1971</pre></span><pre>		# implement raw not using a wrapped path</pre></div>
<div class="cov"><span class="num"><pre>1972</pre></span><pre>		copy = MDagPath( self.dagPath() )</pre></div>
<div class="cov"><span class="num"><pre>1973</pre></span><pre>		copy.pop( 1 )</pre></div>
<div class="cov"><span class="num"><pre>1974</pre></span><pre>		if copy.length() == 0:		# ignore world !</pre></div>
<div class="cov"><span class="num"><pre>1975</pre></span><pre>			return None</pre></div>
<div class="cov"><span class="num"><pre>1976</pre></span><pre>		return NodeFromObj( copy )</pre></div>
<div class="skip"><span class="num"><pre>1977</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1978</pre></span><pre>	def children( self, predicate = lambda x: True, asNode=True ):</pre></div>
<div class="cov"><span class="num"><pre>1979</pre></span><pre>		&quot;&quot;&quot;:return: all child nodes below this dag node if predicate returns True for passed Node</pre></div>
<div class="cov"><span class="num"><pre>1980</pre></span><pre>		:param asNode: if True, you will receive the children as wrapped Nodes, otherwise you </pre></div>
<div class="cov"><span class="num"><pre>1981</pre></span><pre>			get MDagPaths&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>1982</pre></span><pre>		out = list()</pre></div>
<div class="cov"><span class="num"><pre>1983</pre></span><pre>		ownpath = self.dagPath()</pre></div>
<div class="cov"><span class="num"><pre>1984</pre></span><pre>		for i in range( ownpath.childCount() ):</pre></div>
<div class="cov"><span class="num"><pre>1985</pre></span><pre>			copy = MDagPath( ownpath )</pre></div>
<div class="cov"><span class="num"><pre>1986</pre></span><pre>			copy.push( MDagPath.child( ownpath, i ) )</pre></div>
<div class="skip"><span class="num"><pre>1987</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>1988</pre></span><pre>			if asNode:</pre></div>
<div class="cov"><span class="num"><pre>1989</pre></span><pre>				copy = NodeFromObj( copy )</pre></div>
<div class="skip"><span class="num"><pre>1990</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1991</pre></span><pre>			if not predicate( copy ):</pre></div>
<div class="nocov"><span class="num"><pre>1992</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>1993</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1994</pre></span><pre>			out.append( copy )</pre></div>
<div class="skip"><span class="num"><pre>1995</pre></span><pre>		# END for each child</pre></div>
<div class="cov"><span class="num"><pre>1996</pre></span><pre>		return out</pre></div>
<div class="skip"><span class="num"><pre>1997</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>1998</pre></span><pre>	def childrenByType( self, nodeType, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>1999</pre></span><pre>		&quot;&quot;&quot;:return: all childnodes below this one matching the given nodeType and the predicate</pre></div>
<div class="cov"><span class="num"><pre>2000</pre></span><pre>		:param nodeType: class of the nodeTyoe, like nt.Transform&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2001</pre></span><pre>		return [ p for p in self.children() if isinstance( p, nodeType ) and predicate( p ) ]</pre></div>
<div class="skip"><span class="num"><pre>2002</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2003</pre></span><pre>	def shapes( self, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>2004</pre></span><pre>		&quot;&quot;&quot;:return: all our Shape nodes</pre></div>
<div class="cov"><span class="num"><pre>2005</pre></span><pre>		:note: you could use getChildren with a predicate, but this method is more</pre></div>
<div class="cov"><span class="num"><pre>2006</pre></span><pre>			efficient as it uses dagpath functions to filter shapes&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2007</pre></span><pre>		shapeNodes = map(NodeFromObj, MDagPathUtil.shapes(self.dagPath()))	# could use getChildrenByType, but this is faster</pre></div>
<div class="cov"><span class="num"><pre>2008</pre></span><pre>		return [ s for s in shapeNodes if predicate( s ) ]</pre></div>
<div class="skip"><span class="num"><pre>2009</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2010</pre></span><pre>	def childTransforms( self, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>2011</pre></span><pre>		&quot;&quot;&quot;:return: list of all transform nodes below this one &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2012</pre></span><pre>		transformNodes = map(NodeFromObj, MDagPathUtil.transforms(self.dagPath())) # could use getChildrenByType, but this is faster</pre></div>
<div class="cov"><span class="num"><pre>2013</pre></span><pre>		return [ t for t in transformNodes if predicate( t ) ]</pre></div>
<div class="skip"><span class="num"><pre>2014</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2015</pre></span><pre>	def instanceNumber( self ):</pre></div>
<div class="cov"><span class="num"><pre>2016</pre></span><pre>		&quot;&quot;&quot;:return: our instance number</pre></div>
<div class="cov"><span class="num"><pre>2017</pre></span><pre>		:note: 0 does not indicate that this object is not instanced - use getInstanceCount instead&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2018</pre></span><pre>		return self.dagPath().instanceNumber()</pre></div>
<div class="skip"><span class="num"><pre>2019</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2020</pre></span><pre>	def instance( self, instanceNumber ):</pre></div>
<div class="cov"><span class="num"><pre>2021</pre></span><pre>		&quot;&quot;&quot;:return: Node to the instance identified by instanceNumber</pre></div>
<div class="cov"><span class="num"><pre>2022</pre></span><pre>		:param instanceNumber: range( 0, self.instanceCount()-1 )&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2023</pre></span><pre>		# secure it - could crash if its not an instanced node</pre></div>
<div class="cov"><span class="num"><pre>2024</pre></span><pre>		if self.instanceCount( False ) == 1:</pre></div>
<div class="nocov"><span class="num"><pre>2025</pre></span><pre>			if instanceNumber:</pre></div>
<div class="nocov"><span class="num"><pre>2026</pre></span><pre>				raise AssertionError( &quot;instanceNumber for non-instanced nodes must be 0, was %i&quot; % instanceNumber )</pre></div>
<div class="nocov"><span class="num"><pre>2027</pre></span><pre>			return self</pre></div>
<div class="skip"><span class="num"><pre>2028</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2029</pre></span><pre>		allpaths = api.MDagPathArray()</pre></div>
<div class="cov"><span class="num"><pre>2030</pre></span><pre>		self.getAllPaths( allpaths )</pre></div>
<div class="skip"><span class="num"><pre>2031</pre></span><pre>		# copy the path as it will be invalidated once the array goes out of scope !</pre></div>
<div class="cov"><span class="num"><pre>2032</pre></span><pre>		return NodeFromObj( MDagPath( allpaths[ instanceNumber ] ) )</pre></div>
<div class="skip"><span class="num"><pre>2033</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2034</pre></span><pre>	def hasChild( self, node ):</pre></div>
<div class="cov"><span class="num"><pre>2035</pre></span><pre>		&quot;&quot;&quot;:return: True if node is a child of self&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2036</pre></span><pre>		return api.MFnDagNode( self.dagPath() ).hasChild( node.object() )</pre></div>
<div class="skip"><span class="num"><pre>2037</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2038</pre></span><pre>	def child( self, index ):</pre></div>
<div class="cov"><span class="num"><pre>2039</pre></span><pre>		&quot;&quot;&quot;:return: child of self at index</pre></div>
<div class="cov"><span class="num"><pre>2040</pre></span><pre>		:note: this method fixes the MFnDagNode.child method - it returns an MObject,</pre></div>
<div class="cov"><span class="num"><pre>2041</pre></span><pre>			which doesnt work well with instanced nodes - a dag path is required, which is what</pre></div>
<div class="cov"><span class="num"><pre>2042</pre></span><pre>			we use to aquire the object&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2043</pre></span><pre>		copy = MDagPath( self.dagPath() )</pre></div>
<div class="cov"><span class="num"><pre>2044</pre></span><pre>		copy.push( MDagPath.child( self.dagPath(), index ) )</pre></div>
<div class="cov"><span class="num"><pre>2045</pre></span><pre>		return NodeFromObj( copy )</pre></div>
<div class="skip"><span class="num"><pre>2046</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2047</pre></span><pre>	#} END dag query</pre></div>
<div class="skip"><span class="num"><pre>2048</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2049</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2050</pre></span><pre>	def _dagPath_delayed( self ):</pre></div>
<div class="cov"><span class="num"><pre>2051</pre></span><pre>		&quot;&quot;&quot;Handles the retrieval of a dagpath from an MObject if it is not known</pre></div>
<div class="cov"><span class="num"><pre>2052</pre></span><pre>		at first.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2053</pre></span><pre>		self._apidagpath = MDagPath( )</pre></div>
<div class="cov"><span class="num"><pre>2054</pre></span><pre>		_mfndag_setObject(self._apiobj)</pre></div>
<div class="cov"><span class="num"><pre>2055</pre></span><pre>		_mfndag.getPath( self._apidagpath )</pre></div>
<div class="cov"><span class="num"><pre>2056</pre></span><pre>		cls = type(self)</pre></div>
<div class="cov"><span class="num"><pre>2057</pre></span><pre>		object.__setattr__(self, 'dagPath', instancemethod(cls._dagPath_cached, self, cls))</pre></div>
<div class="cov"><span class="num"><pre>2058</pre></span><pre>		return self._apidagpath</pre></div>
<div class="skip"><span class="num"><pre>2059</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2060</pre></span><pre>	def _dagPath_cached( self ):</pre></div>
<div class="cov"><span class="num"><pre>2061</pre></span><pre>		&quot;&quot;&quot;:return: MDagPath attached to this node from a cached location&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2062</pre></span><pre>		return self._apidagpath</pre></div>
<div class="skip"><span class="num"><pre>2063</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2064</pre></span><pre>	def _object_cached( self ):</pre></div>
<div class="cov"><span class="num"><pre>2065</pre></span><pre>		&quot;&quot;&quot;:return: MObject associated with the path of this instance from a cached location&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2066</pre></span><pre>		return self._apiobj</pre></div>
<div class="skip"><span class="num"><pre>2067</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2068</pre></span><pre>	def _object_delayed( self ):</pre></div>
<div class="cov"><span class="num"><pre>2069</pre></span><pre>		&quot;&quot;&quot;:return: MObject as retrieved from the MDagPath of our Node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2070</pre></span><pre>		self._apiobj = self._apidagpath.node()		# expensive call</pre></div>
<div class="cov"><span class="num"><pre>2071</pre></span><pre>		cls = type(self)</pre></div>
<div class="cov"><span class="num"><pre>2072</pre></span><pre>		object.__setattr__(self, 'object', instancemethod(cls._object_cached, self, cls))</pre></div>
<div class="cov"><span class="num"><pre>2073</pre></span><pre>		return self._apiobj</pre></div>
<div class="skip"><span class="num"><pre>2074</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2075</pre></span><pre>	# delayed mobject retrieval is the default for DagNodes as they are created from </pre></div>
<div class="skip"><span class="num"><pre>2076</pre></span><pre>	# MDagPaths most of the time</pre></div>
<div class="cov"><span class="num"><pre>2077</pre></span><pre>	object = _object_delayed</pre></div>
<div class="skip"><span class="num"><pre>2078</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2079</pre></span><pre>	def dagPath( self ):</pre></div>
<div class="cov"><span class="num"><pre>2080</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2081</pre></span><pre>		:return: the original DagPath attached to this Node - it's not wrapped</pre></div>
<div class="cov"><span class="num"><pre>2082</pre></span><pre>			for performance&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2083</pre></span><pre>		return self._apidagpath</pre></div>
<div class="skip"><span class="num"><pre>2084</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2085</pre></span><pre>	def apiObject( self ):</pre></div>
<div class="cov"><span class="num"><pre>2086</pre></span><pre>		&quot;&quot;&quot;:return: our dag path as this is our api object - the object defining this node best&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2087</pre></span><pre>		return self.dagPath()</pre></div>
<div class="skip"><span class="num"><pre>2088</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2089</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2090</pre></span><pre>	#{ Iterators</pre></div>
<div class="cov"><span class="num"><pre>2091</pre></span><pre>	def iterInstances( self, excludeSelf = False ):</pre></div>
<div class="cov"><span class="num"><pre>2092</pre></span><pre>		&quot;&quot;&quot;Get iterator over all ( direct and indirect )instances of this node</pre></div>
<div class="skip"><span class="num"><pre>2093</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2094</pre></span><pre>		:param excludeSelf: if True, self will not be returned, if False, it will be in</pre></div>
<div class="cov"><span class="num"><pre>2095</pre></span><pre>			the list of items</pre></div>
<div class="cov"><span class="num"><pre>2096</pre></span><pre>		:note: Iterating instances is more efficient than querying all instances individually using</pre></div>
<div class="cov"><span class="num"><pre>2097</pre></span><pre>			`instance`</pre></div>
<div class="cov"><span class="num"><pre>2098</pre></span><pre>		:todo: add flag to allow iteration of indirect instances as well &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2099</pre></span><pre>		# prevents crashes if this method is called within a dag instance added callback</pre></div>
<div class="cov"><span class="num"><pre>2100</pre></span><pre>		if self.instanceCount( True ) == 1:</pre></div>
<div class="cov"><span class="num"><pre>2101</pre></span><pre>			if not excludeSelf:</pre></div>
<div class="cov"><span class="num"><pre>2102</pre></span><pre>				yield self</pre></div>
<div class="cov"><span class="num"><pre>2103</pre></span><pre>			raise StopIteration</pre></div>
<div class="skip"><span class="num"><pre>2104</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2105</pre></span><pre>		ownNumber = -1</pre></div>
<div class="cov"><span class="num"><pre>2106</pre></span><pre>		if excludeSelf:</pre></div>
<div class="cov"><span class="num"><pre>2107</pre></span><pre>			ownNumber = self.instanceNumber( )</pre></div>
<div class="skip"><span class="num"><pre>2108</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2109</pre></span><pre>		allpaths = api.MDagPathArray()</pre></div>
<div class="cov"><span class="num"><pre>2110</pre></span><pre>		self.getAllPaths( allpaths )</pre></div>
<div class="skip"><span class="num"><pre>2111</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2112</pre></span><pre>		# paths are ordered by instance number</pre></div>
<div class="cov"><span class="num"><pre>2113</pre></span><pre>		for i in range( allpaths.length() ):</pre></div>
<div class="skip"><span class="num"><pre>2114</pre></span><pre>			# index is NOT instance number ! If transforms are instanced, children increase instance number</pre></div>
<div class="cov"><span class="num"><pre>2115</pre></span><pre>			dagpath = allpaths[ i ]</pre></div>
<div class="cov"><span class="num"><pre>2116</pre></span><pre>			if dagpath.instanceNumber() != ownNumber:</pre></div>
<div class="cov"><span class="num"><pre>2117</pre></span><pre>				yield NodeFromObj( MDagPath( dagpath ) )</pre></div>
<div class="skip"><span class="num"><pre>2118</pre></span><pre>		# END for each instance</pre></div>
<div class="skip"><span class="num"><pre>2119</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2120</pre></span><pre>	#} END iterators</pre></div>
<div class="skip"><span class="num"><pre>2121</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2122</pre></span><pre>#} END base ( classes )</pre></div>
<div class="skip"><span class="num"><pre>2123</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2124</pre></span><pre>#{ Attributes</pre></div>
<div class="skip"><span class="num"><pre>2125</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2126</pre></span><pre>def _new_mixin( cls, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>2127</pre></span><pre>	&quot;&quot;&quot;Constructor for MObject derived types which only differ in a few parameters.</pre></div>
<div class="cov"><span class="num"><pre>2128</pre></span><pre>	Requires _base_cls_ and _mfn_suffix_ to be set on the respective class</pre></div>
<div class="skip"><span class="num"><pre>2129</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2130</pre></span><pre>	return an attribute class of the respective type for given MObject</pre></div>
<div class="skip"><span class="num"><pre>2131</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2132</pre></span><pre>	:param args: arg[0] is attribute's MObject to be wrapped.</pre></div>
<div class="cov"><span class="num"><pre>2133</pre></span><pre>	:note: Custom constructors are not possible as __init__ is automatically called</pre></div>
<div class="cov"><span class="num"><pre>2134</pre></span><pre>		afterwards - MObject does not support anything but no args or another MObject.&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2135</pre></span><pre>	# may fail as we didn't check of len(args), but its okay, lets safe the if statement </pre></div>
<div class="skip"><span class="num"><pre>2136</pre></span><pre>	# here ! Python will bark nicely anyway</pre></div>
<div class="cov"><span class="num"><pre>2137</pre></span><pre>	mobject = args[0]</pre></div>
<div class="cov"><span class="num"><pre>2138</pre></span><pre>	if cls != cls._base_cls_:</pre></div>
<div class="skip"><span class="num"><pre>2139</pre></span><pre>		# the user knows which type he wants, created it directly</pre></div>
<div class="cov"><span class="num"><pre>2140</pre></span><pre>		newinst = object.__new__(cls, mobject)</pre></div>
<div class="skip"><span class="num"><pre>2141</pre></span><pre>		# NOTE: Although this class is implemented not to need the _apiobj anymore</pre></div>
<div class="skip"><span class="num"><pre>2142</pre></span><pre>		# as we ARE an MObject, we are learning from the issue in Component</pre></div>
<div class="skip"><span class="num"><pre>2143</pre></span><pre>		# and just keep another reference to it, to be on the safe side</pre></div>
<div class="skip"><span class="num"><pre>2144</pre></span><pre>		# DEL_ME_AND_CRASH ############################</pre></div>
<div class="cov"><span class="num"><pre>2145</pre></span><pre>		newinst._apiobj = newinst		########</pre></div>
<div class="skip"><span class="num"><pre>2146</pre></span><pre>		#################################</pre></div>
<div class="cov"><span class="num"><pre>2147</pre></span><pre>		return newinst</pre></div>
<div class="skip"><span class="num"><pre>2148</pre></span><pre>	# END optimization</pre></div>
<div class="cov"><span class="num"><pre>2149</pre></span><pre>	newinst = _createInstByPredicate( mobject, cls, cls, lambda x: x.endswith( cls._mfn_suffix_ ) )</pre></div>
<div class="skip"><span class="num"><pre>2150</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2151</pre></span><pre>	if newinst is None:</pre></div>
<div class="nocov"><span class="num"><pre>2152</pre></span><pre>		raise ValueError( &quot;%s with apitype %r could not be wrapped into any function set&quot; % ( cls._mfn_suffix_, mobject.apiTypeStr() ) )</pre></div>
<div class="skip"><span class="num"><pre>2153</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2154</pre></span><pre>	return newinst</pre></div>
<div class="skip"><span class="num"><pre>2155</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2156</pre></span><pre># assure proper name, just in case</pre></div>
<div class="cov"><span class="num"><pre>2157</pre></span><pre>_new_mixin.__name__ = '__new__'</pre></div>
<div class="skip"><span class="num"><pre>2158</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2159</pre></span><pre>class Attribute( MObject ):</pre></div>
<div class="cov"><span class="num"><pre>2160</pre></span><pre>	&quot;&quot;&quot;Represents an attribute in general - this is the base class</pre></div>
<div class="cov"><span class="num"><pre>2161</pre></span><pre>	Use this general class to create attribute wraps - it will return</pre></div>
<div class="cov"><span class="num"><pre>2162</pre></span><pre>	a class of the respective type &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2163</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2164</pre></span><pre>	__metaclass__ = MetaClassCreatorNodes</pre></div>
<div class="cov"><span class="num"><pre>2165</pre></span><pre>	_base_cls_ = None</pre></div>
<div class="cov"><span class="num"><pre>2166</pre></span><pre>	_mfn_suffix_ = 'Attribute'</pre></div>
<div class="skip"><span class="num"><pre>2167</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2168</pre></span><pre>	__new__ = _new_mixin</pre></div>
<div class="skip"><span class="num"><pre>2169</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2170</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2171</pre></span><pre>	def create(cls, full_name, brief_name, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>2172</pre></span><pre>		&quot;&quot;&quot;:return: A new Attribute </pre></div>
<div class="cov"><span class="num"><pre>2173</pre></span><pre>		:param full_name: the long name of the attribute</pre></div>
<div class="cov"><span class="num"><pre>2174</pre></span><pre>		:param brief_name: the brief name of the attribute</pre></div>
<div class="cov"><span class="num"><pre>2175</pre></span><pre>		:note: all args and kwargs are passed to the respective function set instance</pre></div>
<div class="cov"><span class="num"><pre>2176</pre></span><pre>		:note: specialize this method in derived types if required&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2177</pre></span><pre>		if cls == Attribute:</pre></div>
<div class="nocov"><span class="num"><pre>2178</pre></span><pre>			raise TypeError(&quot;Cannot create plain Attributes, choose a subclass of Attribute instead&quot;)</pre></div>
<div class="skip"><span class="num"><pre>2179</pre></span><pre>		# END handle invalid type</pre></div>
<div class="skip"><span class="num"><pre>2180</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2181</pre></span><pre>		# keep the class around to be sure we don't die on the way due to decremented</pre></div>
<div class="skip"><span class="num"><pre>2182</pre></span><pre>		# ref counts</pre></div>
<div class="cov"><span class="num"><pre>2183</pre></span><pre>		mfninst = cls._mfncls()</pre></div>
<div class="cov"><span class="num"><pre>2184</pre></span><pre>		attr = mfninst.create(full_name, brief_name, *args, **kwargs)</pre></div>
<div class="cov"><span class="num"><pre>2185</pre></span><pre>		return cls(attr)		# this copies the MObject and we are safe</pre></div>
<div class="skip"><span class="num"><pre>2186</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2187</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2188</pre></span><pre>Attribute._base_cls_ = Attribute</pre></div>
<div class="skip"><span class="num"><pre>2189</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2190</pre></span><pre>class UnitAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2191</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2192</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2193</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2194</pre></span><pre>class TypedAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2195</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2196</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2197</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2198</pre></span><pre>class NumericAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2199</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2200</pre></span><pre>	def _create_using(cls, method_name, *args):</pre></div>
<div class="cov"><span class="num"><pre>2201</pre></span><pre>		mfninst = cls._mfncls()</pre></div>
<div class="cov"><span class="num"><pre>2202</pre></span><pre>		attr = getattr(mfninst, method_name)(*args)</pre></div>
<div class="cov"><span class="num"><pre>2203</pre></span><pre>		return cls(attr)</pre></div>
<div class="skip"><span class="num"><pre>2204</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2205</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2206</pre></span><pre>	def createColor(cls, full_name, brief_name ):</pre></div>
<div class="cov"><span class="num"><pre>2207</pre></span><pre>		&quot;&quot;&quot;:return: An attribute representing a RGB color</pre></div>
<div class="cov"><span class="num"><pre>2208</pre></span><pre>		:param full_name: see `create`</pre></div>
<div class="cov"><span class="num"><pre>2209</pre></span><pre>		:param brief_name: see `create`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2210</pre></span><pre>		return cls._create_using('createColor', full_name, brief_name)</pre></div>
<div class="skip"><span class="num"><pre>2211</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2212</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2213</pre></span><pre>	def createPoint(cls, full_name, brief_name ):</pre></div>
<div class="cov"><span class="num"><pre>2214</pre></span><pre>		&quot;&quot;&quot;:return: An attribute representing a point with XYZ coordinates</pre></div>
<div class="cov"><span class="num"><pre>2215</pre></span><pre>		:param full_name: see `create`</pre></div>
<div class="cov"><span class="num"><pre>2216</pre></span><pre>		:param brief_name: see `create`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2217</pre></span><pre>		return cls._create_using('createPoint', full_name, brief_name)</pre></div>
<div class="skip"><span class="num"><pre>2218</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2219</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2220</pre></span><pre>class MessageAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2221</pre></span><pre>	pass </pre></div>
<div class="skip"><span class="num"><pre>2222</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2223</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2224</pre></span><pre>class MatrixAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2225</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2226</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2227</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2228</pre></span><pre>class LightDataAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2229</pre></span><pre>	pass </pre></div>
<div class="skip"><span class="num"><pre>2230</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2231</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2232</pre></span><pre>class GenericAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2233</pre></span><pre>	pass </pre></div>
<div class="skip"><span class="num"><pre>2234</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2235</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2236</pre></span><pre>class EnumAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2237</pre></span><pre>	pass </pre></div>
<div class="skip"><span class="num"><pre>2238</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2239</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2240</pre></span><pre>class CompoundAttribute( Attribute ):</pre></div>
<div class="cov"><span class="num"><pre>2241</pre></span><pre>	pass </pre></div>
<div class="skip"><span class="num"><pre>2242</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2243</pre></span><pre>#} END attributes</pre></div>
<div class="skip"><span class="num"><pre>2244</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2245</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2246</pre></span><pre>#{ Data </pre></div>
<div class="skip"><span class="num"><pre>2247</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2248</pre></span><pre>class Data( MObject ):</pre></div>
<div class="cov"><span class="num"><pre>2249</pre></span><pre>	&quot;&quot;&quot;Represents an data in general - this is the base class</pre></div>
<div class="cov"><span class="num"><pre>2250</pre></span><pre>	Use this general class to create data wrap objects - it will return a class of the respective type &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2251</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2252</pre></span><pre>	__metaclass__ = MetaClassCreatorNodes</pre></div>
<div class="cov"><span class="num"><pre>2253</pre></span><pre>	_base_cls_ = None</pre></div>
<div class="cov"><span class="num"><pre>2254</pre></span><pre>	_mfn_suffix_ = 'Data'</pre></div>
<div class="skip"><span class="num"><pre>2255</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2256</pre></span><pre>	__new__ = _new_mixin</pre></div>
<div class="skip"><span class="num"><pre>2257</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2258</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2259</pre></span><pre>	def create(cls, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>2260</pre></span><pre>		&quot;&quot;&quot;:return: A new instance of data wrapped in the desired Data type</pre></div>
<div class="cov"><span class="num"><pre>2261</pre></span><pre>		:note: specialize this method in derived types !&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2262</pre></span><pre>		if cls == Data:</pre></div>
<div class="cov"><span class="num"><pre>2263</pre></span><pre>			raise TypeError(&quot;Cannot create 'plain' data, choose a subclass of Data instead&quot;)</pre></div>
<div class="skip"><span class="num"><pre>2264</pre></span><pre>		# END handle invalid type</pre></div>
<div class="skip"><span class="num"><pre>2265</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2266</pre></span><pre>		# keep the instance alive until we have wrapped the MObject which essentiall</pre></div>
<div class="skip"><span class="num"><pre>2267</pre></span><pre>		# creates a copy and increments its maya ref count.</pre></div>
<div class="cov"><span class="num"><pre>2268</pre></span><pre>		mfninst = cls._mfncls() </pre></div>
<div class="cov"><span class="num"><pre>2269</pre></span><pre>		data = mfninst.create(*args, **kwargs)</pre></div>
<div class="cov"><span class="num"><pre>2270</pre></span><pre>		return cls(data)</pre></div>
<div class="skip"><span class="num"><pre>2271</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2272</pre></span><pre>Data._base_cls_ = Data</pre></div>
<div class="skip"><span class="num"><pre>2273</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2274</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2275</pre></span><pre>class VectorArrayData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2276</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2277</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2278</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2279</pre></span><pre>class UInt64ArrayData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2280</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2281</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2282</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2283</pre></span><pre>class StringData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2284</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2285</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2286</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2287</pre></span><pre>class StringArrayData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2288</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2289</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2290</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2291</pre></span><pre>class SphereData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2292</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2293</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2294</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2295</pre></span><pre>class PointArrayData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2296</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2297</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2298</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2299</pre></span><pre>class PluginData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2300</pre></span><pre>	&quot;&quot;&quot;Wraps plugin data as received by a plug. If plugin's registered their data</pre></div>
<div class="cov"><span class="num"><pre>2301</pre></span><pre>	types and tracking dictionaries using the `registerPluginDataTrackingDict`,</pre></div>
<div class="cov"><span class="num"><pre>2302</pre></span><pre>	the original self pointer can easily be retrieved using this classes interface&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2303</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2304</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2305</pre></span><pre>	def data( self ):</pre></div>
<div class="cov"><span class="num"><pre>2306</pre></span><pre>		&quot;&quot;&quot;:return: python data wrapped by this plugin data object</pre></div>
<div class="cov"><span class="num"><pre>2307</pre></span><pre>		:note: the python data should be made such that it can be changed using</pre></div>
<div class="cov"><span class="num"><pre>2308</pre></span><pre>			the reference we return - otherwise it will be read-only as it is just a copy !</pre></div>
<div class="cov"><span class="num"><pre>2309</pre></span><pre>		:note: the data retrieved by this method cannot be used in plug.msetMObject( data ) as it</pre></div>
<div class="cov"><span class="num"><pre>2310</pre></span><pre>			is ordinary python data, not an mobject</pre></div>
<div class="cov"><span class="num"><pre>2311</pre></span><pre>		:raise RuntimeError: if the data object's id is unknown to this class&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2312</pre></span><pre>		import maya.OpenMayaMPx as mpx	# delayed import as it takes plenty of time</pre></div>
<div class="skip"><span class="num"><pre>2313</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2314</pre></span><pre>		mfn = self._mfncls( self._apiobj )</pre></div>
<div class="cov"><span class="num"><pre>2315</pre></span><pre>		datatype = mfn.typeId( )</pre></div>
<div class="cov"><span class="num"><pre>2316</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>2317</pre></span><pre>			trackingdict = sys._dataTypeIdToTrackingDictMap[ datatype.id() ]</pre></div>
<div class="nocov"><span class="num"><pre>2318</pre></span><pre>		except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>2319</pre></span><pre>			raise RuntimeError( &quot;Datatype %r is not registered to python as plugin data&quot; % datatype )</pre></div>
<div class="cov"><span class="num"><pre>2320</pre></span><pre>		else:</pre></div>
<div class="skip"><span class="num"><pre>2321</pre></span><pre>			# retrieve the data pointer</pre></div>
<div class="cov"><span class="num"><pre>2322</pre></span><pre>			dataptrkey = mpx.asHashable( mfn.data() )</pre></div>
<div class="cov"><span class="num"><pre>2323</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>2324</pre></span><pre>				return trackingdict[ dataptrkey ]</pre></div>
<div class="nocov"><span class="num"><pre>2325</pre></span><pre>			except KeyError:</pre></div>
<div class="nocov"><span class="num"><pre>2326</pre></span><pre>				raise RuntimeError( &quot;Could not find data associated with plugin data pointer at %r&quot; % dataptrkey )</pre></div>
<div class="skip"><span class="num"><pre>2327</pre></span><pre>			# END exception handling tracking dict</pre></div>
<div class="skip"><span class="num"><pre>2328</pre></span><pre>		# END exception handling dict access</pre></div>
<div class="skip"><span class="num"><pre>2329</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2330</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2331</pre></span><pre>class NumericData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2332</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2333</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2334</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2335</pre></span><pre>class NObjectData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2336</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2337</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2338</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2339</pre></span><pre>class NIdData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2340</pre></span><pre>	&quot;&quot;&quot;:note: maya 2011 and newer&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2341</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2342</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2343</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2344</pre></span><pre>class MatrixData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2345</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2346</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2347</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2348</pre></span><pre>class IntArrayData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2349</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2350</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2351</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2352</pre></span><pre>class GeometryData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2353</pre></span><pre>	&quot;&quot;&quot;Wraps geometry data providing additional convenience methods&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2354</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2355</pre></span><pre>	def uniqueObjectId( self ):</pre></div>
<div class="cov"><span class="num"><pre>2356</pre></span><pre>		&quot;&quot;&quot;:return: an object id that is guaranteed to be unique</pre></div>
<div class="cov"><span class="num"><pre>2357</pre></span><pre>		:note: use it with addObjectGroup to create a new unique group&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2358</pre></span><pre>		# find a unique object group id</pre></div>
<div class="nocov"><span class="num"><pre>2359</pre></span><pre>		objgrpid = 0</pre></div>
<div class="nocov"><span class="num"><pre>2360</pre></span><pre>		for ogid in range( self.objectGroupCount() ):</pre></div>
<div class="nocov"><span class="num"><pre>2361</pre></span><pre>			exog = self.objectGroup( ogid )</pre></div>
<div class="nocov"><span class="num"><pre>2362</pre></span><pre>			while exog == objgrpid:</pre></div>
<div class="nocov"><span class="num"><pre>2363</pre></span><pre>				objgrpid += 1</pre></div>
<div class="skip"><span class="num"><pre>2364</pre></span><pre>		# END for each existing object group</pre></div>
<div class="nocov"><span class="num"><pre>2365</pre></span><pre>		return objgrpid</pre></div>
<div class="skip"><span class="num"><pre>2366</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2367</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2368</pre></span><pre>class SubdData( GeometryData ):</pre></div>
<div class="cov"><span class="num"><pre>2369</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2370</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2371</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2372</pre></span><pre>class NurbsSurfaceData( GeometryData ):</pre></div>
<div class="cov"><span class="num"><pre>2373</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2374</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2375</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2376</pre></span><pre>class NurbsCurveData( GeometryData ):</pre></div>
<div class="cov"><span class="num"><pre>2377</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2378</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2379</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2380</pre></span><pre>class MeshData( GeometryData ):</pre></div>
<div class="cov"><span class="num"><pre>2381</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2382</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2383</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2384</pre></span><pre>class LatticeData( GeometryData ):</pre></div>
<div class="cov"><span class="num"><pre>2385</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2386</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2387</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2388</pre></span><pre>class DynSweptGeometryData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2389</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2390</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2391</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2392</pre></span><pre>class DoubleArrayData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2393</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2394</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2395</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2396</pre></span><pre>class ComponentListData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2397</pre></span><pre>	&quot;&quot;&quot;Improves the default wrap by adding some required methods to deal with</pre></div>
<div class="cov"><span class="num"><pre>2398</pre></span><pre>	component lists&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2399</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2400</pre></span><pre>	def __getitem__( self, index ):</pre></div>
<div class="cov"><span class="num"><pre>2401</pre></span><pre>		&quot;&quot;&quot;:return: the item at the given index&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2402</pre></span><pre>		return self._mfncls( self )[ index ]</pre></div>
<div class="skip"><span class="num"><pre>2403</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2404</pre></span><pre>	def __len__( self ):</pre></div>
<div class="cov"><span class="num"><pre>2405</pre></span><pre>		&quot;&quot;&quot;:return: number of components stored in this data&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2406</pre></span><pre>		return self.length()</pre></div>
<div class="skip"><span class="num"><pre>2407</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2408</pre></span><pre>	def __contains__( self, component ):</pre></div>
<div class="cov"><span class="num"><pre>2409</pre></span><pre>		&quot;&quot;&quot;:return: True if the given component is contained in this data&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2410</pre></span><pre>		return self.has(component)</pre></div>
<div class="skip"><span class="num"><pre>2411</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2412</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2413</pre></span><pre>class ArrayAttrsData( Data ):</pre></div>
<div class="cov"><span class="num"><pre>2414</pre></span><pre>	pass</pre></div>
<div class="skip"><span class="num"><pre>2415</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2416</pre></span><pre>#} END data</pre></div>
<div class="skip"><span class="num"><pre>2417</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2418</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2419</pre></span><pre>#{ Components </pre></div>
<div class="skip"><span class="num"><pre>2420</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2421</pre></span><pre>class Component( MObject ):</pre></div>
<div class="cov"><span class="num"><pre>2422</pre></span><pre>	&quot;&quot;&quot;Represents a shape component - its derivates can be used to handle component lists</pre></div>
<div class="cov"><span class="num"><pre>2423</pre></span><pre>	to be used in object sets and shading engines &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2424</pre></span><pre>	__metaclass__ = MetaClassCreatorNodes</pre></div>
<div class="cov"><span class="num"><pre>2425</pre></span><pre>	_mfnType = None	# to be set in the subclass component</pre></div>
<div class="cov"><span class="num"><pre>2426</pre></span><pre>	_base_cls_ = None</pre></div>
<div class="cov"><span class="num"><pre>2427</pre></span><pre>	_mfn_suffix_ = &quot;Component&quot;</pre></div>
<div class="skip"><span class="num"><pre>2428</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2429</pre></span><pre>	__new__ = _new_mixin</pre></div>
<div class="skip"><span class="num"><pre>2430</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2431</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2432</pre></span><pre>	def create(cls, component_type):</pre></div>
<div class="cov"><span class="num"><pre>2433</pre></span><pre>		&quot;&quot;&quot;:return: A new component instance carrying data of the given component type</pre></div>
<div class="cov"><span class="num"><pre>2434</pre></span><pre>		:param component_type: MFn:: component type to be created. </pre></div>
<div class="cov"><span class="num"><pre>2435</pre></span><pre>		:note: It is important that you call this function on the Component Class of </pre></div>
<div class="cov"><span class="num"><pre>2436</pre></span><pre>			a compatible type, or a RuntimeError will occour&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2437</pre></span><pre>		if cls == Component:</pre></div>
<div class="cov"><span class="num"><pre>2438</pre></span><pre>			raise TypeError(&quot;The base compnent type cannot be instantiated&quot;)</pre></div>
<div class="skip"><span class="num"><pre>2439</pre></span><pre>		# END handle invalid type</pre></div>
<div class="skip"><span class="num"><pre>2440</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2441</pre></span><pre>		cdata = cls._mfncls().create(component_type)</pre></div>
<div class="cov"><span class="num"><pre>2442</pre></span><pre>		return cls(cdata)</pre></div>
<div class="skip"><span class="num"><pre>2443</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2444</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2445</pre></span><pre>	def getMFnType( cls ):</pre></div>
<div class="cov"><span class="num"><pre>2446</pre></span><pre>		&quot;&quot;&quot;:return: mfn type of this class</pre></div>
<div class="cov"><span class="num"><pre>2447</pre></span><pre>		:note: the type returned is *not* the type of the shape component&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2448</pre></span><pre>		return cls._mfnType</pre></div>
<div class="skip"><span class="num"><pre>2449</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2450</pre></span><pre>	def addElements( self, *args ):</pre></div>
<div class="cov"><span class="num"><pre>2451</pre></span><pre>		&quot;&quot;&quot;Operates exactly as described in the MFn...IndexComponent documentation, </pre></div>
<div class="cov"><span class="num"><pre>2452</pre></span><pre>		but returns self to allow combined calls and on-the-fly component generation</pre></div>
<div class="skip"><span class="num"><pre>2453</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2454</pre></span><pre>		:return: self&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2455</pre></span><pre>		self._mfncls(self).addElements(*args)</pre></div>
<div class="cov"><span class="num"><pre>2456</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre>2457</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2458</pre></span><pre>	def addElement( self, *args ):</pre></div>
<div class="cov"><span class="num"><pre>2459</pre></span><pre>		&quot;&quot;&quot;see `addElements`</pre></div>
<div class="skip"><span class="num"><pre>2460</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2461</pre></span><pre>		:return: self</pre></div>
<div class="cov"><span class="num"><pre>2462</pre></span><pre>		:note: do not use this function as it will be really slow when handling many</pre></div>
<div class="cov"><span class="num"><pre>2463</pre></span><pre>			items, use addElements instead&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2464</pre></span><pre>		self._mfncls(self).addElement(*args)</pre></div>
<div class="cov"><span class="num"><pre>2465</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre>2466</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2467</pre></span><pre>Component._base_cls_ = Component</pre></div>
<div class="skip"><span class="num"><pre>2468</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2469</pre></span><pre>class SingleIndexedComponent( Component ):</pre></div>
<div class="cov"><span class="num"><pre>2470</pre></span><pre>	&quot;&quot;&quot;precreated class for ease-of-use&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2471</pre></span><pre>	_mfnType = api.MFn.kSingleIndexedComponent</pre></div>
<div class="skip"><span class="num"><pre>2472</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2473</pre></span><pre>	def getElements(self):</pre></div>
<div class="cov"><span class="num"><pre>2474</pre></span><pre>		&quot;&quot;&quot;:return: MIntArray containing the indices this component represents&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2475</pre></span><pre>		u = api.MIntArray()</pre></div>
<div class="cov"><span class="num"><pre>2476</pre></span><pre>		api.MFnSingleIndexedComponent(self).getElements(u)</pre></div>
<div class="cov"><span class="num"><pre>2477</pre></span><pre>		return u</pre></div>
<div class="skip"><span class="num"><pre>2478</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2479</pre></span><pre>	# aliases</pre></div>
<div class="cov"><span class="num"><pre>2480</pre></span><pre>	elements = getElements</pre></div>
<div class="skip"><span class="num"><pre>2481</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2482</pre></span><pre>class DoubleIndexedComponent( Component ):	# derived just for epydoc</pre></div>
<div class="cov"><span class="num"><pre>2483</pre></span><pre>	&quot;&quot;&quot;Fixes some functions that would not work usually &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2484</pre></span><pre>	_mfnType = api.MFn.kDoubleIndexedComponent</pre></div>
<div class="skip"><span class="num"><pre>2485</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2486</pre></span><pre>	def getElements(self):</pre></div>
<div class="cov"><span class="num"><pre>2487</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2488</pre></span><pre>		:return: (uIntArray, vIntArray) tuple containing arrays with the u and v</pre></div>
<div class="cov"><span class="num"><pre>2489</pre></span><pre>			indices this component represents&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2490</pre></span><pre>		u = api.MIntArray()</pre></div>
<div class="nocov"><span class="num"><pre>2491</pre></span><pre>		v = api.MIntArray()</pre></div>
<div class="nocov"><span class="num"><pre>2492</pre></span><pre>		api.MFnDoubleIndexedComponent(self).getElements(u, v)</pre></div>
<div class="nocov"><span class="num"><pre>2493</pre></span><pre>		return (u,v)</pre></div>
<div class="skip"><span class="num"><pre>2494</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2495</pre></span><pre>	# aliases</pre></div>
<div class="cov"><span class="num"><pre>2496</pre></span><pre>	elements = getElements</pre></div>
<div class="skip"><span class="num"><pre>2497</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2498</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2499</pre></span><pre>class TripleIndexedComponent( Component ):</pre></div>
<div class="cov"><span class="num"><pre>2500</pre></span><pre>	&quot;&quot;&quot;precreated class for ease-of-use&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2501</pre></span><pre>	_mfnType = api.MFn.kTripleIndexedComponent</pre></div>
<div class="skip"><span class="num"><pre>2502</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2503</pre></span><pre>	def getElements(self):</pre></div>
<div class="cov"><span class="num"><pre>2504</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2505</pre></span><pre>		:return: (uIntArray, vIntArray, wIntArray) tuple containing arrays with </pre></div>
<div class="cov"><span class="num"><pre>2506</pre></span><pre>			the u, v and w indices this component represents&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2507</pre></span><pre>		u = api.MIntArray()</pre></div>
<div class="nocov"><span class="num"><pre>2508</pre></span><pre>		v = api.MIntArray()</pre></div>
<div class="nocov"><span class="num"><pre>2509</pre></span><pre>		w = api.MIntArray()</pre></div>
<div class="nocov"><span class="num"><pre>2510</pre></span><pre>		api.MFnDoubleIndexedComponent(self).getElements(u, v, w)</pre></div>
<div class="nocov"><span class="num"><pre>2511</pre></span><pre>		return (u,v,w)</pre></div>
<div class="skip"><span class="num"><pre>2512</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>2513</pre></span><pre>	# aliases</pre></div>
<div class="cov"><span class="num"><pre>2514</pre></span><pre>	elements = getElements</pre></div>
<div class="skip"><span class="num"><pre>2515</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2516</pre></span><pre>#} END components</pre></div>
<div class="skip"><span class="num"><pre>2517</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2518</pre></span><pre>#{ Basic Types</pre></div>
<div class="skip"><span class="num"><pre>2519</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2520</pre></span><pre>class MDagPathUtil( object ):</pre></div>
<div class="cov"><span class="num"><pre>2521</pre></span><pre>	&quot;&quot;&quot;Performs operations on MDagPaths which are hard or inconvenient to do otherwise</pre></div>
<div class="skip"><span class="num"><pre>2522</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2523</pre></span><pre>	:note: We do NOT patch the actual api type as this would make it unusable to be passed in</pre></div>
<div class="cov"><span class="num"><pre>2524</pre></span><pre>		as reference/pointer type unless its being created by maya itself.&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2525</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2526</pre></span><pre>	#{ Query</pre></div>
<div class="skip"><span class="num"><pre>2527</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2528</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2529</pre></span><pre>	def parentPath( cls, path ):</pre></div>
<div class="cov"><span class="num"><pre>2530</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2531</pre></span><pre>		:return: MDagPath to the parent of path or None if path is in the scene </pre></div>
<div class="cov"><span class="num"><pre>2532</pre></span><pre>			root.&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2533</pre></span><pre>		copy = MDagPath( path )</pre></div>
<div class="nocov"><span class="num"><pre>2534</pre></span><pre>		copy.pop( 1 )</pre></div>
<div class="nocov"><span class="num"><pre>2535</pre></span><pre>		if copy.length() == 0:		# ignore world !</pre></div>
<div class="nocov"><span class="num"><pre>2536</pre></span><pre>			return None</pre></div>
<div class="nocov"><span class="num"><pre>2537</pre></span><pre>		return copy</pre></div>
<div class="skip"><span class="num"><pre>2538</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2539</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2540</pre></span><pre>	def numShapes( cls, path ):</pre></div>
<div class="cov"><span class="num"><pre>2541</pre></span><pre>		&quot;&quot;&quot;:return: return the number of shapes below path&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2542</pre></span><pre>		sutil = api.MScriptUtil()</pre></div>
<div class="nocov"><span class="num"><pre>2543</pre></span><pre>		uintptr = sutil.asUintPtr()</pre></div>
<div class="nocov"><span class="num"><pre>2544</pre></span><pre>		sutil.setUint( uintptr , 0 )</pre></div>
<div class="skip"><span class="num"><pre>2545</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>2546</pre></span><pre>		path.numberOfShapesDirectlyBelow( uintptr )</pre></div>
<div class="skip"><span class="num"><pre>2547</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>2548</pre></span><pre>		return sutil.uint( uintptr )</pre></div>
<div class="skip"><span class="num"><pre>2549</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2550</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2551</pre></span><pre>	def childPathAtIndex( cls, path, index ):</pre></div>
<div class="cov"><span class="num"><pre>2552</pre></span><pre>		&quot;&quot;&quot;:return: MDagPath pointing to this path's child at the given index&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2553</pre></span><pre>		copy = MDagPath(path)</pre></div>
<div class="cov"><span class="num"><pre>2554</pre></span><pre>		copy.push(path.child(index))</pre></div>
<div class="cov"><span class="num"><pre>2555</pre></span><pre>		return copy</pre></div>
<div class="skip"><span class="num"><pre>2556</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2557</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2558</pre></span><pre>	def childPaths( cls, path, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>2559</pre></span><pre>		&quot;&quot;&quot;:return: list of child MDagPaths which have path as parent</pre></div>
<div class="cov"><span class="num"><pre>2560</pre></span><pre>		:param predicate: returns True for each path which should be included in the result.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2561</pre></span><pre>		outPaths = list()</pre></div>
<div class="cov"><span class="num"><pre>2562</pre></span><pre>		for i in xrange( path.childCount() ):</pre></div>
<div class="cov"><span class="num"><pre>2563</pre></span><pre>			childpath = cls.childPathAtIndex( path, i )</pre></div>
<div class="cov"><span class="num"><pre>2564</pre></span><pre>			if predicate( childpath ):</pre></div>
<div class="cov"><span class="num"><pre>2565</pre></span><pre>				outPaths.append( childpath )</pre></div>
<div class="cov"><span class="num"><pre>2566</pre></span><pre>		return outPaths</pre></div>
<div class="skip"><span class="num"><pre>2567</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2568</pre></span><pre>	#} END query</pre></div>
<div class="skip"><span class="num"><pre>2569</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2570</pre></span><pre>	#{ Edit Inplace</pre></div>
<div class="cov"><span class="num"><pre>2571</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2572</pre></span><pre>	def pop( cls, path, num ):</pre></div>
<div class="cov"><span class="num"><pre>2573</pre></span><pre>		&quot;&quot;&quot;Pop the given number of items off the end of the path</pre></div>
<div class="skip"><span class="num"><pre>2574</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2575</pre></span><pre>		:return: path itself&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2576</pre></span><pre>		path.pop( num )</pre></div>
<div class="nocov"><span class="num"><pre>2577</pre></span><pre>		return path</pre></div>
<div class="skip"><span class="num"><pre>2578</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2579</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2580</pre></span><pre>	def extendToChild( cls, path, num ):</pre></div>
<div class="cov"><span class="num"><pre>2581</pre></span><pre>		&quot;&quot;&quot;Extend path to the given child number - can be shape or transform</pre></div>
<div class="skip"><span class="num"><pre>2582</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2583</pre></span><pre>		:return: path itself&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>2584</pre></span><pre>		path.extendToShapeDirectlyBelow( num )</pre></div>
<div class="nocov"><span class="num"><pre>2585</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre>2586</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2587</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2588</pre></span><pre>	def childPathsByFn( cls, path, fn, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>2589</pre></span><pre>		&quot;&quot;&quot;Get all children below path supporting the given MFn.type</pre></div>
<div class="skip"><span class="num"><pre>2590</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2591</pre></span><pre>		:return: MDagPaths to all matched paths below this path</pre></div>
<div class="cov"><span class="num"><pre>2592</pre></span><pre>		:param fn: member of MFn</pre></div>
<div class="cov"><span class="num"><pre>2593</pre></span><pre>		:param predicate: returns True for each path which should be included in the result.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2594</pre></span><pre>		isMatch = lambda p: p.hasFn( fn )</pre></div>
<div class="cov"><span class="num"><pre>2595</pre></span><pre>		return [ p for p in cls.childPaths( path, predicate = isMatch ) if predicate( p ) ]</pre></div>
<div class="skip"><span class="num"><pre>2596</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2597</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2598</pre></span><pre>	def shapes( cls, path, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>2599</pre></span><pre>		&quot;&quot;&quot;:return: MDagPaths to all shapes below path</pre></div>
<div class="cov"><span class="num"><pre>2600</pre></span><pre>		:param predicate: returns True for each path which should be included in the result.</pre></div>
<div class="cov"><span class="num"><pre>2601</pre></span><pre>		:note: have to explicitly assure we do not get transforms that are compatible to the shape function</pre></div>
<div class="cov"><span class="num"><pre>2602</pre></span><pre>			set for some reason - this is just odd and shouldn't be, but it happens if a transform has an instanced</pre></div>
<div class="cov"><span class="num"><pre>2603</pre></span><pre>			shape for example, perhaps even if it is not instanced&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2604</pre></span><pre>		return [ shape for shape in cls.childPathsByFn( path, api.MFn.kShape, predicate=predicate ) if shape.apiType() != api.MFn.kTransform ]</pre></div>
<div class="skip"><span class="num"><pre>2605</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2606</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>2607</pre></span><pre>	def transforms( cls, path, predicate = lambda x: True ):</pre></div>
<div class="cov"><span class="num"><pre>2608</pre></span><pre>		&quot;&quot;&quot;:return: MDagPaths to all transforms below path</pre></div>
<div class="cov"><span class="num"><pre>2609</pre></span><pre>		:param predicate: returns True to include path in result&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2610</pre></span><pre>		return cls.childPathsByFn( path, api.MFn.kTransform, predicate=predicate )</pre></div>
<div class="skip"><span class="num"><pre>2611</pre></span><pre>	#} END edit in place</pre></div>
<div class="skip"><span class="num"><pre>2612</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2613</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2614</pre></span><pre>#} END basic types</pre></div>
<div class="skip"><span class="num"><pre>2615</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2616</pre></span><pre>#{ Default Types</pre></div>
<div class="skip"><span class="num"><pre>2617</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2618</pre></span><pre>class Reference( DependNode ):</pre></div>
<div class="cov"><span class="num"><pre>2619</pre></span><pre>	&quot;&quot;&quot;Implements additional utilities to work with references&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2620</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2621</pre></span><pre>	def fileReference(self):</pre></div>
<div class="cov"><span class="num"><pre>2622</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2623</pre></span><pre>		:return: `FileReference` instance initialized with the reference we </pre></div>
<div class="cov"><span class="num"><pre>2624</pre></span><pre>			represent&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2625</pre></span><pre>		import mrv.maya.ref as refmod</pre></div>
<div class="cov"><span class="num"><pre>2626</pre></span><pre>		return refmod.FileReference(refnode=self)</pre></div>
<div class="skip"><span class="num"><pre>2627</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2628</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2629</pre></span><pre>class Transform( DagNode ):		# derived just for epydoc</pre></div>
<div class="cov"><span class="num"><pre>2630</pre></span><pre>	&quot;&quot;&quot;Precreated class to allow isinstance checking against their types and</pre></div>
<div class="cov"><span class="num"><pre>2631</pre></span><pre>	to add undo support to MFnTransform functions, as well as for usability</pre></div>
<div class="skip"><span class="num"><pre>2632</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2633</pre></span><pre>	:note: bases determined by metaclass</pre></div>
<div class="cov"><span class="num"><pre>2634</pre></span><pre>	:note: to have undoable set* functions , get the ( improved ) transformation matrix</pre></div>
<div class="cov"><span class="num"><pre>2635</pre></span><pre>		make your changes to it and use the `set` method &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2636</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2637</pre></span><pre>	#{ MFnTransform Overrides</pre></div>
<div class="skip"><span class="num"><pre>2638</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2639</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>2640</pre></span><pre>	def set( self, transformation ):</pre></div>
<div class="cov"><span class="num"><pre>2641</pre></span><pre>		&quot;&quot;&quot;Set the transformation of this Transform node&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2642</pre></span><pre>		curtransformation = self.transformation()</pre></div>
<div class="cov"><span class="num"><pre>2643</pre></span><pre>		setter = self._api_set</pre></div>
<div class="cov"><span class="num"><pre>2644</pre></span><pre>		op = undo.GenericOperation()</pre></div>
<div class="cov"><span class="num"><pre>2645</pre></span><pre>		op.setDoitCmd( setter, transformation )</pre></div>
<div class="cov"><span class="num"><pre>2646</pre></span><pre>		op.setUndoitCmd( setter, curtransformation )</pre></div>
<div class="cov"><span class="num"><pre>2647</pre></span><pre>		op.doIt()</pre></div>
<div class="skip"><span class="num"><pre>2648</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2649</pre></span><pre>	#} END mfntransform overrides</pre></div>
<div class="skip"><span class="num"><pre>2650</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2651</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2652</pre></span><pre>	#{ Convenience Overrides</pre></div>
<div class="cov"><span class="num"><pre>2653</pre></span><pre>	def getScale(self):</pre></div>
<div class="cov"><span class="num"><pre>2654</pre></span><pre>		&quot;&quot;&quot;:return: MVector containing the scale of the transform&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2655</pre></span><pre>		return in_double3_out_vector(self._api_getScale)</pre></div>
<div class="skip"><span class="num"><pre>2656</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2657</pre></span><pre>	def getShear(self):</pre></div>
<div class="cov"><span class="num"><pre>2658</pre></span><pre>		&quot;&quot;&quot;:return: MVector containing the shear of the transform&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2659</pre></span><pre>		return in_double3_out_vector(self._api_getShear)</pre></div>
<div class="skip"><span class="num"><pre>2660</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2661</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>2662</pre></span><pre>	def setScale(self, vec_scale):</pre></div>
<div class="cov"><span class="num"><pre>2663</pre></span><pre>		&quot;&quot;&quot;Set the scale of the transform with undo support from a single vector&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2664</pre></span><pre>		return undoable_in_double3_as_vector(self._api_setScale, self.getScale(), vec_scale)</pre></div>
<div class="skip"><span class="num"><pre>2665</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2666</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>2667</pre></span><pre>	def setShear(self, vec_shear):</pre></div>
<div class="cov"><span class="num"><pre>2668</pre></span><pre>		&quot;&quot;&quot;Set the shear value of the transform with undo support from single vector&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2669</pre></span><pre>		return undoable_in_double3_as_vector(self._api_setShear, self.getShear(), vec_shear)</pre></div>
<div class="skip"><span class="num"><pre>2670</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2671</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>2672</pre></span><pre>	def shearBy(self, vec_value):</pre></div>
<div class="cov"><span class="num"><pre>2673</pre></span><pre>		&quot;&quot;&quot;Add the given vector to the transform's shear&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2674</pre></span><pre>		return undoable_in_double3_as_vector(self._api_shearBy, self.getShear(), vec_value)</pre></div>
<div class="skip"><span class="num"><pre>2675</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>2676</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>2677</pre></span><pre>	def scaleBy(self, vec_value):</pre></div>
<div class="cov"><span class="num"><pre>2678</pre></span><pre>		&quot;&quot;&quot;Add the given vector to the transform's scale&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2679</pre></span><pre>		return undoable_in_double3_as_vector(self._api_scaleBy, self.getScale(), vec_value)</pre></div>
<div class="skip"><span class="num"><pre>2680</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2681</pre></span><pre>	#} END convenience overrides</pre></div>
<div class="skip"><span class="num"><pre>2682</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>2683</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2684</pre></span><pre>class Shape( DagNode ):	 # base for epydoc !</pre></div>
<div class="cov"><span class="num"><pre>2685</pre></span><pre>	&quot;&quot;&quot;Interface providing common methods to all geometry shapes as they can be shaded.</pre></div>
<div class="cov"><span class="num"><pre>2686</pre></span><pre>	They usually support per object and per component shader assignments</pre></div>
<div class="skip"><span class="num"><pre>2687</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2688</pre></span><pre>	:note: as shadingEngines are derived from objectSet, this class deliberatly uses</pre></div>
<div class="cov"><span class="num"><pre>2689</pre></span><pre>		them interchangably when it comes to set handling.</pre></div>
<div class="cov"><span class="num"><pre>2690</pre></span><pre>	:note: for convenience, this class implements the shader related methods</pre></div>
<div class="cov"><span class="num"><pre>2691</pre></span><pre>		whereever possible</pre></div>
<div class="cov"><span class="num"><pre>2692</pre></span><pre>	:note: bases determined by metaclass&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2693</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2694</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2695</pre></span><pre>	#{ preset type filters</pre></div>
<div class="cov"><span class="num"><pre>2696</pre></span><pre>	fSetsRenderable = SetFilter( api.MFn.kShadingEngine, False, 0 )	# shading engines only</pre></div>
<div class="cov"><span class="num"><pre>2697</pre></span><pre>	fSetsDeformer = SetFilter( api.MFn.kSet, True , 1)				# deformer sets only</pre></div>
<div class="skip"><span class="num"><pre>2698</pre></span><pre>	#} END type filters</pre></div>
<div class="skip"><span class="num"><pre>2699</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2700</pre></span><pre>	#{ Sets Interface</pre></div>
<div class="skip"><span class="num"><pre>2701</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2702</pre></span><pre>	def _parseSetConnections( self, allow_compoents ):</pre></div>
<div class="cov"><span class="num"><pre>2703</pre></span><pre>		&quot;&quot;&quot;Manually parses the set connections from self</pre></div>
<div class="skip"><span class="num"><pre>2704</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>2705</pre></span><pre>		:return: tuple( MObjectArray( setapiobj ), MObjectArray( compapiobj ) ) if allow_compoents, otherwise</pre></div>
<div class="cov"><span class="num"><pre>2706</pre></span><pre>			just a list( setapiobj )&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2707</pre></span><pre>		sets = api.MObjectArray()</pre></div>
<div class="cov"><span class="num"><pre>2708</pre></span><pre>		iogplug = self._getSetPlug()			# from DagNode , usually iog plug</pre></div>
<div class="skip"><span class="num"><pre>2709</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2710</pre></span><pre>		# this will never fail - logcical index creates the plug as needed</pre></div>
<div class="skip"><span class="num"><pre>2711</pre></span><pre>		# and drops it if it is no longer required</pre></div>
<div class="cov"><span class="num"><pre>2712</pre></span><pre>		if allow_compoents:</pre></div>
<div class="cov"><span class="num"><pre>2713</pre></span><pre>			components = api.MObjectArray()</pre></div>
<div class="skip"><span class="num"><pre>2714</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2715</pre></span><pre>			# take full assignments as well - make it work as the connectedSets api method</pre></div>
<div class="cov"><span class="num"><pre>2716</pre></span><pre>			for dplug in iogplug.moutputs():</pre></div>
<div class="cov"><span class="num"><pre>2717</pre></span><pre>				sets.append( dplug.node() )</pre></div>
<div class="cov"><span class="num"><pre>2718</pre></span><pre>				components.append( MObject() )</pre></div>
<div class="skip"><span class="num"><pre>2719</pre></span><pre>			# END full objecft assignments</pre></div>
<div class="skip"><span class="num"><pre>2720</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2721</pre></span><pre>			for compplug in iogplug.mchildByName('objectGroups'):</pre></div>
<div class="cov"><span class="num"><pre>2722</pre></span><pre>				for setplug in compplug.moutputs():</pre></div>
<div class="cov"><span class="num"><pre>2723</pre></span><pre>					sets.append( setplug.node() )		# connected set</pre></div>
<div class="skip"><span class="num"><pre>2724</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2725</pre></span><pre>					# get the component from the data</pre></div>
<div class="cov"><span class="num"><pre>2726</pre></span><pre>					compdata = compplug.mchildByName('objectGrpCompList').masData()</pre></div>
<div class="cov"><span class="num"><pre>2727</pre></span><pre>					if compdata.length() == 1:			# this is what we can handle</pre></div>
<div class="cov"><span class="num"><pre>2728</pre></span><pre>						components.append( compdata[0] ) 	# the component itself</pre></div>
<div class="nocov"><span class="num"><pre>2729</pre></span><pre>					else:</pre></div>
<div class="nocov"><span class="num"><pre>2730</pre></span><pre>						raise AssertionError( &quot;more than one compoents in list&quot; )</pre></div>
<div class="skip"><span class="num"><pre>2731</pre></span><pre>					# END assure we have components in data</pre></div>
<div class="skip"><span class="num"><pre>2732</pre></span><pre>				# END for each set connected to component</pre></div>
<div class="skip"><span class="num"><pre>2733</pre></span><pre>			# END for each component group</pre></div>
<div class="skip"><span class="num"><pre>2734</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2735</pre></span><pre>			return ( sets, components )</pre></div>
<div class="nocov"><span class="num"><pre>2736</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>2737</pre></span><pre>			for dplug in iogplug.moutputs():</pre></div>
<div class="nocov"><span class="num"><pre>2738</pre></span><pre>				sets.append(dplug.node())</pre></div>
<div class="nocov"><span class="num"><pre>2739</pre></span><pre>			return sets</pre></div>
<div class="skip"><span class="num"><pre>2740</pre></span><pre>		# END for each object grouop connection in iog</pre></div>
<div class="skip"><span class="num"><pre>2741</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2742</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2743</pre></span><pre>	def componentAssignments( self, setFilter = fSetsRenderable, use_api = True, asComponent = True ):</pre></div>
<div class="cov"><span class="num"><pre>2744</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>2745</pre></span><pre>		:return: list of tuples( ObjectSetNode, Component_or_MObject ) defininmg shader</pre></div>
<div class="cov"><span class="num"><pre>2746</pre></span><pre>			assignments on per component basis.</pre></div>
<div class="skip"><span class="num"><pre>2747</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>2748</pre></span><pre>			If a shader is assigned to the whole object, the component would be a null object, otherwise</pre></div>
<div class="cov"><span class="num"><pre>2749</pre></span><pre>			it is an instance of a wrapped IndexedComponent class</pre></div>
<div class="cov"><span class="num"><pre>2750</pre></span><pre>		:note: The returned Component will be an MObject(kNullObject) only in case the component is </pre></div>
<div class="cov"><span class="num"><pre>2751</pre></span><pre>			not set. Hence you should check whether it isNull() before actually using it.</pre></div>
<div class="cov"><span class="num"><pre>2752</pre></span><pre>		:param setFilter: see `connectedSets`</pre></div>
<div class="cov"><span class="num"><pre>2753</pre></span><pre>		:param use_api: if True, api methods will be used if possible which is usually faster.</pre></div>
<div class="cov"><span class="num"><pre>2754</pre></span><pre>			If False, a custom non-api implementation will be used instead.</pre></div>
<div class="cov"><span class="num"><pre>2755</pre></span><pre>			This can be required if the apiImplementation is not reliable which happens in</pre></div>
<div class="cov"><span class="num"><pre>2756</pre></span><pre>			few cases of 'weird' component assignments</pre></div>
<div class="cov"><span class="num"><pre>2757</pre></span><pre>		:param asComponent: If True, the components will be wrapped into the matching MRV compontent type</pre></div>
<div class="cov"><span class="num"><pre>2758</pre></span><pre>			to provide a nicer interface. This might slightly slow down the process, but this is usually </pre></div>
<div class="cov"><span class="num"><pre>2759</pre></span><pre>			neglectable.</pre></div>
<div class="cov"><span class="num"><pre>2760</pre></span><pre>		:note: the sets order will be the order of connections of the respective component list</pre></div>
<div class="cov"><span class="num"><pre>2761</pre></span><pre>			attributes at instObjGroups.objectGroups</pre></div>
<div class="cov"><span class="num"><pre>2762</pre></span><pre>		:note: currently only meshes and subdees support per component assignment, whereas only</pre></div>
<div class="cov"><span class="num"><pre>2763</pre></span><pre>			meshes can have per component shader assignments</pre></div>
<div class="cov"><span class="num"><pre>2764</pre></span><pre>		:note: SubDivision Components cannot be supported as the component type kSubdivCVComponent</pre></div>
<div class="cov"><span class="num"><pre>2765</pre></span><pre>			cannot be wrapped into any component function set - reevaluate that with new maya versions !</pre></div>
<div class="cov"><span class="num"><pre>2766</pre></span><pre>		:note: deformer set component assignments are only returned for instance 0 ! They apply to all</pre></div>
<div class="cov"><span class="num"><pre>2767</pre></span><pre>			output meshes though&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>2768</pre></span><pre>		# SUBDEE SPECIAL CASE</pre></div>
<div class="skip"><span class="num"><pre>2769</pre></span><pre>		#########################</pre></div>
<div class="skip"><span class="num"><pre>2770</pre></span><pre>		# cannot handle components for subdees - return them empty</pre></div>
<div class="cov"><span class="num"><pre>2771</pre></span><pre>		if self._apiobj.apiType() == api.MFn.kSubdiv:</pre></div>
<div class="nocov"><span class="num"><pre>2772</pre></span><pre>			log.warn(&quot;components are not supported for Subdivision surfaces due to m8.5 api limitation&quot;)</pre></div>
<div class="nocov"><span class="num"><pre>2773</pre></span><pre>			sets = self.connectedSets( setFilter = setFilter )</pre></div>
<div class="nocov"><span class="num"><pre>2774</pre></span><pre>			return [ ( setnode, MObject() ) for setnode in sets ]</pre></div>
<div class="skip"><span class="num"><pre>2775</pre></span><pre>		# END subdee handling</pre></div>
<div class="skip"><span class="num"><pre>2776</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2777</pre></span><pre>		sets = components = None</pre></div>
<div class="skip"><span class="num"><pre>2778</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2779</pre></span><pre>		# MESHES AND NURBS</pre></div>
<div class="skip"><span class="num"><pre>2780</pre></span><pre>		##################</pre></div>
<div class="skip"><span class="num"><pre>2781</pre></span><pre>		# QUERY SETS AND COMPONENTS</pre></div>
<div class="skip"><span class="num"><pre>2782</pre></span><pre>		# for non-meshes, we have to parse the components manually</pre></div>
<div class="cov"><span class="num"><pre>2783</pre></span><pre>		if not use_api or not self._apiobj.hasFn( api.MFn.kMesh ) or not self.isValidMesh():</pre></div>
<div class="skip"><span class="num"><pre>2784</pre></span><pre>			# check full membership</pre></div>
<div class="cov"><span class="num"><pre>2785</pre></span><pre>			sets,components = self._parseSetConnections( True )</pre></div>
<div class="skip"><span class="num"><pre>2786</pre></span><pre>		# END non-mesh handling</pre></div>
<div class="cov"><span class="num"><pre>2787</pre></span><pre>		else:</pre></div>
<div class="skip"><span class="num"><pre>2788</pre></span><pre>			# MESH - use the function set</pre></div>
<div class="skip"><span class="num"><pre>2789</pre></span><pre>			# take all fSets by default, we do the filtering</pre></div>
<div class="cov"><span class="num"><pre>2790</pre></span><pre>			sets = api.MObjectArray()</pre></div>
<div class="cov"><span class="num"><pre>2791</pre></span><pre>			components = api.MObjectArray()</pre></div>
<div class="cov"><span class="num"><pre>2792</pre></span><pre>			self.getConnectedSetsAndMembers( self.instanceNumber(), sets, components, False )</pre></div>
<div class="skip"><span class="num"><pre>2793</pre></span><pre>		# END sets/components query</pre></div>
<div class="skip"><span class="num"><pre>2794</pre></span><pre>                                         </pre></div>
<div class="skip"><span class="num"><pre>2795</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2796</pre></span><pre>		# wrap the sets and components</pre></div>
<div class="cov"><span class="num"><pre>2797</pre></span><pre>		outlist = list()</pre></div>
<div class="cov"><span class="num"><pre>2798</pre></span><pre>		for setobj,compobj in zip( sets, components ):</pre></div>
<div class="cov"><span class="num"><pre>2799</pre></span><pre>			if not setFilter( setobj ):</pre></div>
<div class="cov"><span class="num"><pre>2800</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>2801</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>2802</pre></span><pre>			setobj = NodeFromObj( MObject( setobj ) )								# copy obj to get memory to python</pre></div>
<div class="cov"><span class="num"><pre>2803</pre></span><pre>			if not compobj.isNull() and asComponent:</pre></div>
<div class="cov"><span class="num"><pre>2804</pre></span><pre>				compobj = Component( compobj )	# this copies the object as well</pre></div>
<div class="cov"><span class="num"><pre>2805</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>2806</pre></span><pre>				compobj = MObject( compobj )	# make it ours</pre></div>
<div class="skip"><span class="num"><pre>2807</pre></span><pre>			# END handle component type</pre></div>
<div class="skip"><span class="num"><pre>2808</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>2809</pre></span><pre>			outlist.append( ( setobj, compobj ) )</pre></div>
<div class="skip"><span class="num"><pre>2810</pre></span><pre>		# END for each set/component pair</pre></div>
<div class="cov"><span class="num"><pre>2811</pre></span><pre>		return outlist</pre></div>
<div class="skip"><span class="num"><pre>2812</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2813</pre></span><pre>	#} END set interface</pre></div>
<div class="skip"><span class="num"><pre>2814</pre></span><pre>#} END default types</pre></div>
<div class="skip"><span class="num"><pre>2815</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2816</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>2817</pre></span><pre></pre></div>
</div>
</body>
</html>
