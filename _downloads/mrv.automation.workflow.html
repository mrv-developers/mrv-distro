<html>
<head>
<title>mrv.automation.workflow</title>
</head>
<body>
mrv.automation.workflow
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 289 lines<br/>
Missed: 61 lines<br/>
Skipped 200 lines<br/>
Percent: 82 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;Contains workflow classes that conenct processes in a di - graph &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>  4</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>import networkx as nx</pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>from mrv.dge import Graph, ComputeError</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>import time</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>import weakref</pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>import traceback</pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>log = logging.getLogger('mrv.automation.workflow')</pre></div>
<div class="skip"><span class="num"><pre> 12</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 13</pre></span><pre>#####################</pre></div>
<div class="skip"><span class="num"><pre> 14</pre></span><pre>## EXCEPTIONS ######</pre></div>
<div class="skip"><span class="num"><pre> 15</pre></span><pre>###################</pre></div>
<div class="skip"><span class="num"><pre> 16</pre></span><pre>#{ Exceptions</pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>class TargetError( ValueError ):</pre></div>
<div class="cov"><span class="num"><pre> 18</pre></span><pre>	&quot;&quot;&quot;Thrown if target is now supported by the workflow ( and thus cannot be made )&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 19</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 20</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 21</pre></span><pre>class DirtyException( Exception ):</pre></div>
<div class="cov"><span class="num"><pre> 22</pre></span><pre>	&quot;&quot;&quot;Exception thrown when system is in dirty query mode and the process detects</pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>	that it is dirty.</pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>	The exception can also contain a report that will be returned using the</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>	makeReport function.</pre></div>
<div class="skip"><span class="num"><pre> 27</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>	:note: Thus exeption class must NOT be derived from ComputeError as it will be caught</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>		by the DG engine and mis-interpreted - unknown exceptions will just be passed on by it</pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>	__slots__ = &quot;report&quot;</pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>	def __init__( self, report = '' ):</pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>		Exception.__init__( self )	# cannot use super with exceptions apparently</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>		self.report = report</pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 36</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>	def __str__( self ):</pre></div>
<div class="nocov"><span class="num"><pre> 38</pre></span><pre>		return str( self.report )</pre></div>
<div class="skip"><span class="num"><pre> 39</pre></span><pre>	#{ Interface</pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>	def makeReport( self ):</pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>		:return: printable report, usually a string or some object that</pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>			responds to str() appropriately&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 45</pre></span><pre>		return self.report</pre></div>
<div class="skip"><span class="num"><pre> 46</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 47</pre></span><pre>	#} END interface</pre></div>
<div class="skip"><span class="num"><pre> 48</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre>#} END exceptions</pre></div>
<div class="skip"><span class="num"><pre> 50</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 51</pre></span><pre>#####################</pre></div>
<div class="skip"><span class="num"><pre> 52</pre></span><pre>## CLASSES    ######</pre></div>
<div class="skip"><span class="num"><pre> 53</pre></span><pre>###################</pre></div>
<div class="skip"><span class="num"><pre> 54</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>class Workflow( Graph ):</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>	&quot;&quot;&quot;Implements a workflow as connected processes</pre></div>
<div class="skip"><span class="num"><pre> 57</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>	:note: if you have to access the processes directly, use the DiGraph methods&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 59</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 60</pre></span><pre>	#{ Utility Classes</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>	class ProcessData( object ):</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>		&quot;&quot;&quot;Allows to store additional information with each process called during the workflow&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>		__slots__ = ( 'process','plug','mode', '_result', 'starttime', 'endtime','exception','index' )</pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>		def __init__( self, process, plug, mode ):</pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>			self.process = process</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>			self.plug = plug</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>			self.mode = mode</pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>			self._result = None					# can be weakref or actual value</pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>			self.starttime = time.clock()</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>			self.endtime = self.starttime</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>			self.exception = None				# stores exception on error</pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>			self.index = 0						# index of the child - graph stores nodes unordered</pre></div>
<div class="skip"><span class="num"><pre> 73</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>		def __repr__( self ):</pre></div>
<div class="nocov"><span class="num"><pre> 75</pre></span><pre>			out = &quot;%s.%s&quot; % ( self.process, self.plug )</pre></div>
<div class="nocov"><span class="num"><pre> 76</pre></span><pre>			if self.exception:</pre></div>
<div class="nocov"><span class="num"><pre> 77</pre></span><pre>				out += &quot;&amp;ERROR&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 78</pre></span><pre>			return out</pre></div>
<div class="skip"><span class="num"><pre> 79</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 80</pre></span><pre>		def elapsed( ):</pre></div>
<div class="cov"><span class="num"><pre> 81</pre></span><pre>			&quot;&quot;&quot;:return: time to process the call&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 82</pre></span><pre>			return self.endtime - self.starttime</pre></div>
<div class="skip"><span class="num"><pre> 83</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>		def setResult( self, result ):</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>			&quot;&quot;&quot;Set the given result</pre></div>
<div class="skip"><span class="num"><pre> 86</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>			:note: uses weak references as the tracking structure should not cause a possible</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>				mutation of the program flow ( as instances stay alive although code expects it to be</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>				deleted&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>			if result is not None:</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>				try:</pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>					self._result = weakref.ref( result )</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>				except TypeError:</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>					self._result = result</pre></div>
<div class="skip"><span class="num"><pre> 95</pre></span><pre>			# END if result not None</pre></div>
<div class="skip"><span class="num"><pre> 96</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>		def result( self ):</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>			&quot;&quot;&quot;:return: result stored in this instance, or None if it is not present or not alive&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>			if self._result:</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>				if isinstance( self._result, weakref.ref ):</pre></div>
<div class="nocov"><span class="num"><pre>101</pre></span><pre>					return self._result()</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>				return self._result</pre></div>
<div class="skip"><span class="num"><pre>103</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>104</pre></span><pre>			return None</pre></div>
<div class="skip"><span class="num"><pre>105</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>106</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>	class CallGraph( nx.DiGraph ):</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>		&quot;&quot;&quot;Simple wrapper storing a call graph, keeping the root at which the call started</pre></div>
<div class="skip"><span class="num"><pre>109</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>		:note: this class is specialized to be used by workflows, its not general for that purpose&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>		def __init__( self ):</pre></div>
<div class="cov"><span class="num"><pre>112</pre></span><pre>			super( Workflow.CallGraph, self ).__init__( name=&quot;Callgraph&quot; )</pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>			self._call_stack = []</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>			self._root = None</pre></div>
<div class="skip"><span class="num"><pre>115</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>		def startCall( self, pdata ):</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>			&quot;&quot;&quot;Add a call of a process&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>118</pre></span><pre>			# keep the call graph</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>			if self._call_stack:</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>				curdata = self._call_stack[ -1 ]</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>				pdata.index = self.in_degree( curdata )</pre></div>
<div class="cov"><span class="num"><pre>122</pre></span><pre>				self.add_edge( pdata, curdata )</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>			else:</pre></div>
<div class="skip"><span class="num"><pre>124</pre></span><pre>				# its the first call, thus we add it as node - would work on first edge add too though</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>				self.add_node( pdata )</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>				self._root = pdata</pre></div>
<div class="skip"><span class="num"><pre>127</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>			self._call_stack.append( pdata )</pre></div>
<div class="skip"><span class="num"><pre>129</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>		def endCall( self, result ):</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>			&quot;&quot;&quot;End the call start started previously</pre></div>
<div class="skip"><span class="num"><pre>132</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>			:param result: the result of the call&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>			lastprocessdata = self._call_stack.pop( )</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>			lastprocessdata.endtime = time.clock( )</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>			lastprocessdata.setResult( result )</pre></div>
<div class="skip"><span class="num"><pre>137</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>		def callRoot( self ):</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>			&quot;&quot;&quot;:return: root at which the call started&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>			return self._root</pre></div>
<div class="skip"><span class="num"><pre>141</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>		def callstackSize( self ):</pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>			&quot;&quot;&quot;:return: length of the callstack&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>144</pre></span><pre>			return len( self._call_stack )</pre></div>
<div class="skip"><span class="num"><pre>145</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>		def toCallList( self, reverse = True, pruneIfTrue = lambda x: False ):</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>			&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>			:return: flattened version of graph as list of ProcessData edges in call order , having</pre></div>
<div class="cov"><span class="num"><pre>149</pre></span><pre>				the root as last element of the list</pre></div>
<div class="skip"><span class="num"><pre>150</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>			:param pruneIfTrue: Function taking ProcessData to return true if the node</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>				should be pruned from the result</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>			:param reverse: if true, the calllist will be properly reversed ( taking childre into account &quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>154</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>155</pre></span><pre>			def predecessors( node, nextNode, reverse, pruneIfTrue ):</pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>				out = []</pre></div>
<div class="skip"><span class="num"><pre>157</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>158</pre></span><pre>				# invert the callorder - each predecessor list defines the input calls</pre></div>
<div class="skip"><span class="num"><pre>159</pre></span><pre>				# a process has made - to properly reporoduce that, the call order needs to be</pre></div>
<div class="skip"><span class="num"><pre>160</pre></span><pre>				# inverted as well</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>				predlist = self.predecessors( node )</pre></div>
<div class="cov"><span class="num"><pre>162</pre></span><pre>				lenpredlist = len( predlist ) - 1</pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>				if not reverse:</pre></div>
<div class="nocov"><span class="num"><pre>164</pre></span><pre>					lenpredlist *= -1 	# will keep the right, non reversed order</pre></div>
<div class="skip"><span class="num"><pre>165</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>166</pre></span><pre>				predlist = [ ( lenpredlist - p.index, p ) for p in predlist ]</pre></div>
<div class="cov"><span class="num"><pre>167</pre></span><pre>				predlist.sort()</pre></div>
<div class="skip"><span class="num"><pre>168</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>169</pre></span><pre>				prednextnode = node</pre></div>
<div class="cov"><span class="num"><pre>170</pre></span><pre>				pruneThisNode = pruneIfTrue( node )</pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>				if pruneThisNode:</pre></div>
<div class="nocov"><span class="num"><pre>172</pre></span><pre>					prednextnode = nextNode</pre></div>
<div class="skip"><span class="num"><pre>173</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>174</pre></span><pre>				# enumerate the other way round, as the call list needs to be inverted</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>				for i,pred in predlist:</pre></div>
<div class="cov"><span class="num"><pre>176</pre></span><pre>					out.extend( predecessors( pred, prednextnode, reverse, pruneIfTrue ) )</pre></div>
<div class="skip"><span class="num"><pre>177</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>				if not pruneThisNode:</pre></div>
<div class="cov"><span class="num"><pre>179</pre></span><pre>					out.append( ( node, nextNode ) )</pre></div>
<div class="cov"><span class="num"><pre>180</pre></span><pre>				return out</pre></div>
<div class="skip"><span class="num"><pre>181</pre></span><pre>			# END predecessors</pre></div>
<div class="cov"><span class="num"><pre>182</pre></span><pre>			calllist = predecessors( self.callRoot(), None, reverse, pruneIfTrue )</pre></div>
<div class="cov"><span class="num"><pre>183</pre></span><pre>			if not reverse:</pre></div>
<div class="nocov"><span class="num"><pre>184</pre></span><pre>				calllist.reverse() 	# actually brings it in the right order, starting at root</pre></div>
<div class="cov"><span class="num"><pre>185</pre></span><pre>			return calllist</pre></div>
<div class="skip"><span class="num"><pre>186</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>187</pre></span><pre>	#} END utility classes</pre></div>
<div class="skip"><span class="num"><pre>188</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>189</pre></span><pre>	def __init__( self, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>190</pre></span><pre>		&quot;&quot;&quot;Initalized base class&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>191</pre></span><pre>		super( Workflow, self ).__init__( **kwargs )</pre></div>
<div class="skip"><span class="num"><pre>192</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>193</pre></span><pre>		self._callgraph = None</pre></div>
<div class="cov"><span class="num"><pre>194</pre></span><pre>		self._mode = False</pre></div>
<div class="skip"><span class="num"><pre>195</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>196</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>197</pre></span><pre>	def __str__( self ):</pre></div>
<div class="nocov"><span class="num"><pre>198</pre></span><pre>		return self.name</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>	def copyFrom( self, other ):</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>		&quot;&quot;&quot;Only mode is required &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>202</pre></span><pre>		self._mode = other._mode</pre></div>
<div class="skip"><span class="num"><pre>203</pre></span><pre>		# shallow copy callgraph</pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>		self._callgraph = other._callgraph</pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>206</pre></span><pre>	#{ Main Interface</pre></div>
<div class="skip"><span class="num"><pre>207</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>	def makeTarget( self, target ):</pre></div>
<div class="cov"><span class="num"><pre>209</pre></span><pre>		&quot;&quot;&quot;:param target: target to make - can be class or instance</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>		:return: result when producing the target&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>211</pre></span><pre>		# generate mode</pre></div>
<div class="cov"><span class="num"><pre>212</pre></span><pre>		import process</pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>		pb = process.ProcessBase</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>		processmode = globalmode = pb.is_state | pb.target_state</pre></div>
<div class="skip"><span class="num"><pre>215</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>		shell, result = self._evaluate( target, processmode, globalmode )</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>		return result</pre></div>
<div class="skip"><span class="num"><pre>218</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>	def makeTargets( self, targetList, errstream=None, donestream=None ):</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>		&quot;&quot;&quot;batch module compatible method allowing to make mutliple targets at once</pre></div>
<div class="skip"><span class="num"><pre>221</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>222</pre></span><pre>		:param targetList: iterable providing the targets to make</pre></div>
<div class="cov"><span class="num"><pre>223</pre></span><pre>		:param errstream: object with file interface allowing to log errors that occurred</pre></div>
<div class="cov"><span class="num"><pre>224</pre></span><pre>			during operation</pre></div>
<div class="cov"><span class="num"><pre>225</pre></span><pre>		:param donestream: if list, targets successfully done will be appended to it, if</pre></div>
<div class="cov"><span class="num"><pre>226</pre></span><pre>			it is a stream, the string representation will be wrtten to it&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>227</pre></span><pre>		def to_stream(msg, stream):</pre></div>
<div class="cov"><span class="num"><pre>228</pre></span><pre>			&quot;&quot;&quot;print msg to stream or use the logger instead&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>229</pre></span><pre>			if stream:</pre></div>
<div class="nocov"><span class="num"><pre>230</pre></span><pre>				stream.write( msg )</pre></div>
<div class="nocov"><span class="num"><pre>231</pre></span><pre>			else:</pre></div>
<div class="nocov"><span class="num"><pre>232</pre></span><pre>				log.info(msg)</pre></div>
<div class="skip"><span class="num"><pre>233</pre></span><pre>			# END errstream handling</pre></div>
<div class="skip"><span class="num"><pre>234</pre></span><pre>		# END utility</pre></div>
<div class="skip"><span class="num"><pre>235</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>		for target in targetList:</pre></div>
<div class="cov"><span class="num"><pre>237</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>				self.makeTarget( target )</pre></div>
<div class="nocov"><span class="num"><pre>239</pre></span><pre>			except ComputeError,e:</pre></div>
<div class="nocov"><span class="num"><pre>240</pre></span><pre>				to_stream(str( e ) + &quot;\n&quot;, errstream)</pre></div>
<div class="nocov"><span class="num"><pre>241</pre></span><pre>			except Exception, e:</pre></div>
<div class="skip"><span class="num"><pre>242</pre></span><pre>				# except all</pre></div>
<div class="nocov"><span class="num"><pre>243</pre></span><pre>				msg = &quot;--&gt; UNHANDLED EXCEPTION: &quot; + str( e ) + &quot;\n&quot;</pre></div>
<div class="nocov"><span class="num"><pre>244</pre></span><pre>				msg += traceback.format_exc( )</pre></div>
<div class="nocov"><span class="num"><pre>245</pre></span><pre>				to_stream(msg, errstream)</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>			if donestream is None:</pre></div>
<div class="cov"><span class="num"><pre>247</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>248</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>249</pre></span><pre>			# all clear, put item to done list</pre></div>
<div class="cov"><span class="num"><pre>250</pre></span><pre>			if hasattr( donestream, &quot;write&quot; ):</pre></div>
<div class="cov"><span class="num"><pre>251</pre></span><pre>				donestream.write( str( target ) + &quot;\n&quot; )</pre></div>
<div class="cov"><span class="num"><pre>252</pre></span><pre>			else:</pre></div>
<div class="skip"><span class="num"><pre>253</pre></span><pre>				# assume its a list</pre></div>
<div class="cov"><span class="num"><pre>254</pre></span><pre>				donestream.append( target )</pre></div>
<div class="skip"><span class="num"><pre>255</pre></span><pre>		# END for each target</pre></div>
<div class="skip"><span class="num"><pre>256</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>257</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>258</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>	def _evaluateDirtyState( self, outputplug, processmode ):</pre></div>
<div class="cov"><span class="num"><pre>260</pre></span><pre>		&quot;&quot;&quot;Evaluate the given plug in process mode and return a dirty report tuple</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>		as used by `makeDirtyReport`&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>		report = list( ( outputplug, None ) )</pre></div>
<div class="cov"><span class="num"><pre>263</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>264</pre></span><pre>			outputplug.clearCache( clear_affected = False ) 		# assure it eavaluates</pre></div>
<div class="cov"><span class="num"><pre>265</pre></span><pre>			outputplug.get( processmode )	# trigger computation, might raise</pre></div>
<div class="nocov"><span class="num"><pre>266</pre></span><pre>		except DirtyException, e:</pre></div>
<div class="nocov"><span class="num"><pre>267</pre></span><pre>			report[ 1 ] = e					# remember report as well</pre></div>
<div class="nocov"><span class="num"><pre>268</pre></span><pre>		except Exception:</pre></div>
<div class="skip"><span class="num"><pre>269</pre></span><pre>			# Renember normal errors , put them into a dirty report, as well as stacktrace</pre></div>
<div class="nocov"><span class="num"><pre>270</pre></span><pre>			excformat = traceback.format_exc( )</pre></div>
<div class="nocov"><span class="num"><pre>271</pre></span><pre>			report[ 1 ] = DirtyException( report = ''.join( excformat ) )</pre></div>
<div class="skip"><span class="num"><pre>272</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>		return tuple( report )</pre></div>
<div class="skip"><span class="num"><pre>274</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>276</pre></span><pre>	def makeDirtyReport( self, target, mode = &quot;single&quot; ):</pre></div>
<div class="cov"><span class="num"><pre>277</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>278</pre></span><pre>		:return: list of tuple( shell, DirtyReport|None )</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>			If a process ( shell.node ) is dirty, a dirty report will be given explaining</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>			why the process is dirty and needs an update</pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>		:param target: target you which to check for it's dirty state</pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>		:param mode:</pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>		 	 * single - only the process assigned to evaluate target will be checked</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>			 * multi - as single, but the whole callgraph will be checked, starting</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>						at the first node, stepping down the callgraph. This gives a per</pre></div>
<div class="cov"><span class="num"><pre>286</pre></span><pre>						node dirty report.</pre></div>
<div class="cov"><span class="num"><pre>287</pre></span><pre>			 * deep - try to evaluate target, but fail if one process in the target's</pre></div>
<div class="cov"><span class="num"><pre>288</pre></span><pre>			 	call history is dirty</pre></div>
<div class="cov"><span class="num"><pre>289</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>		import process</pre></div>
<div class="cov"><span class="num"><pre>291</pre></span><pre>		pb = process.ProcessBase</pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>		processmode = pb.is_state | pb.dirty_check</pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>		globalmode = None</pre></div>
<div class="skip"><span class="num"><pre>294</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>295</pre></span><pre>		# lets make the mode clear</pre></div>
<div class="cov"><span class="num"><pre>296</pre></span><pre>		if mode == &quot;deep&quot; :</pre></div>
<div class="cov"><span class="num"><pre>297</pre></span><pre>			globalmode = processmode		# input processes may apply dirty check ( and fail )</pre></div>
<div class="nocov"><span class="num"><pre>298</pre></span><pre>		elif mode in ( &quot;single&quot;, &quot;multi&quot; ):</pre></div>
<div class="nocov"><span class="num"><pre>299</pre></span><pre>			globalmode = pb.is_state		# input process should just return the current state, no checking</pre></div>
<div class="nocov"><span class="num"><pre>300</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>301</pre></span><pre>			raise AssertionError( &quot;invalid mode: %s&quot; % mode )</pre></div>
<div class="skip"><span class="num"><pre>302</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>303</pre></span><pre>		outreports = []</pre></div>
<div class="skip"><span class="num"><pre>304</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>305</pre></span><pre>		# GET INITIAL REPORT</pre></div>
<div class="skip"><span class="num"><pre>306</pre></span><pre>		######################</pre></div>
<div class="cov"><span class="num"><pre>307</pre></span><pre>		outputplug = self._setupProcess( target, globalmode )</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>		outreports.append( self._evaluateDirtyState( outputplug, processmode ) )</pre></div>
<div class="skip"><span class="num"><pre>309</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>310</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>311</pre></span><pre>		# STEP THE CALLGRAPH ?</pre></div>
<div class="cov"><span class="num"><pre>312</pre></span><pre>		if mode == &quot;multi&quot;:</pre></div>
<div class="skip"><span class="num"><pre>313</pre></span><pre>			# walk the callgraph and get dirty reports from each node</pre></div>
<div class="nocov"><span class="num"><pre>314</pre></span><pre>			calllist = self._callgraph.toCallList( reverse = False )</pre></div>
<div class="nocov"><span class="num"><pre>315</pre></span><pre>			for s_pdata,d_pdata in calllist:</pre></div>
<div class="nocov"><span class="num"><pre>316</pre></span><pre>				if d_pdata is None:					# the root node ( we already called it ) has no destination</pre></div>
<div class="nocov"><span class="num"><pre>317</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>318</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>319</pre></span><pre>				outputshell = d_pdata.process.toShell( d_pdata.plug )</pre></div>
<div class="nocov"><span class="num"><pre>320</pre></span><pre>				outreports.append( self._evaluateDirtyState( outputshell, processmode ) )</pre></div>
<div class="skip"><span class="num"><pre>321</pre></span><pre>			# END for each s_pdata, d_pdata</pre></div>
<div class="skip"><span class="num"><pre>322</pre></span><pre>		# END if multi handling</pre></div>
<div class="cov"><span class="num"><pre>323</pre></span><pre>		return outreports</pre></div>
<div class="skip"><span class="num"><pre>324</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>325</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>326</pre></span><pre>	def _clearState( self, global_evaluation_mode ):</pre></div>
<div class="cov"><span class="num"><pre>327</pre></span><pre>		&quot;&quot;&quot;Clear the previous state and re-initialize this instance getting ready</pre></div>
<div class="cov"><span class="num"><pre>328</pre></span><pre>		for a new instance</pre></div>
<div class="skip"><span class="num"><pre>329</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>330</pre></span><pre>		:param global_evaluation_mode: evaluation mode to be used&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>331</pre></span><pre>		self._callgraph = Workflow.CallGraph( )</pre></div>
<div class="cov"><span class="num"><pre>332</pre></span><pre>		self._mode = global_evaluation_mode</pre></div>
<div class="skip"><span class="num"><pre>333</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>334</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>335</pre></span><pre>	def _setupProcess( self, target, globalmode ):</pre></div>
<div class="cov"><span class="num"><pre>336</pre></span><pre>		&quot;&quot;&quot;Setup the workflow's dg such that the returned output shell can be queried</pre></div>
<div class="cov"><span class="num"><pre>337</pre></span><pre>		to evaluate target</pre></div>
<div class="skip"><span class="num"><pre>338</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>339</pre></span><pre>		:param globalmode: mode with which all other processes will be handling</pre></div>
<div class="cov"><span class="num"><pre>340</pre></span><pre>			their input calls</pre></div>
<div class="cov"><span class="num"><pre>341</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>342</pre></span><pre>		# find suitable process</pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>		inputshell = self.targetRating( target )[1]</pre></div>
<div class="cov"><span class="num"><pre>344</pre></span><pre>		if inputshell is None:</pre></div>
<div class="nocov"><span class="num"><pre>345</pre></span><pre>			raise TargetError( &quot;Cannot handle target %r&quot; % target )</pre></div>
<div class="skip"><span class="num"><pre>346</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>347</pre></span><pre>		# clear previous callgraph</pre></div>
<div class="cov"><span class="num"><pre>348</pre></span><pre>		self._clearState( globalmode )</pre></div>
<div class="skip"><span class="num"><pre>349</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>350</pre></span><pre>		# prepare all processes</pre></div>
<div class="cov"><span class="num"><pre>351</pre></span><pre>		for node in self.iterNodes( ):</pre></div>
<div class="cov"><span class="num"><pre>352</pre></span><pre>			node.prepareProcess( )</pre></div>
<div class="skip"><span class="num"><pre>353</pre></span><pre>		# END reset dg handling</pre></div>
<div class="skip"><span class="num"><pre>354</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>355</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>356</pre></span><pre>		# OUTPUT SHELL HANDLING</pre></div>
<div class="skip"><span class="num"><pre>357</pre></span><pre>		#########################</pre></div>
<div class="skip"><span class="num"><pre>358</pre></span><pre>		# Find a shell that we can query to trigger the graph to evaluate</pre></div>
<div class="skip"><span class="num"><pre>359</pre></span><pre>		# get output plug that can be queried to get the target - follow the flow</pre></div>
<div class="skip"><span class="num"><pre>360</pre></span><pre>		# of the graph downstream and get the first compatible plug that would</pre></div>
<div class="skip"><span class="num"><pre>361</pre></span><pre>		# return the same type that we put in</pre></div>
<div class="skip"><span class="num"><pre>362</pre></span><pre>		# NOTE: requires an unconnected output plug by convention !</pre></div>
<div class="cov"><span class="num"><pre>363</pre></span><pre>		these = lambda shell: not shell.plug.providesOutput() or shell.outputs( )</pre></div>
<div class="cov"><span class="num"><pre>364</pre></span><pre>		allAffectedNodes = ( shell.node for shell in inputshell.iterShells( direction = &quot;down&quot;, visit_once = 1, prune = these ) )</pre></div>
<div class="cov"><span class="num"><pre>365</pre></span><pre>		outputshell = None</pre></div>
<div class="skip"><span class="num"><pre>366</pre></span><pre>		# AFFECTED NODES</pre></div>
<div class="skip"><span class="num"><pre>367</pre></span><pre>		##################</pre></div>
<div class="skip"><span class="num"><pre>368</pre></span><pre>		# use last compatible node in the chain -</pre></div>
<div class="cov"><span class="num"><pre>369</pre></span><pre>		for node in allAffectedNodes:</pre></div>
<div class="cov"><span class="num"><pre>370</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>371</pre></span><pre>				shell = node.targetRating( target, check_input_plugs = False, raise_on_ambiguity = 0 )[1] # 1 == plug</pre></div>
<div class="nocov"><span class="num"><pre>372</pre></span><pre>			except TypeError,e:		# ambiguous outputs</pre></div>
<div class="nocov"><span class="num"><pre>373</pre></span><pre>				log.error(str( e ))</pre></div>
<div class="nocov"><span class="num"><pre>374</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>375</pre></span><pre>			# END handle exceptions</pre></div>
<div class="skip"><span class="num"><pre>376</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>377</pre></span><pre>			if shell:</pre></div>
<div class="cov"><span class="num"><pre>378</pre></span><pre>				outputshell = shell</pre></div>
<div class="skip"><span class="num"><pre>379</pre></span><pre>				# so here it comes - take this break away, and workflow might not work anymore</pre></div>
<div class="skip"><span class="num"><pre>380</pre></span><pre>				# perhaps we should add a flag to define whether workflows should keep on looking</pre></div>
<div class="skip"><span class="num"><pre>381</pre></span><pre>				# or not - if not, one has to carefully plane the output plugs ...</pre></div>
<div class="cov"><span class="num"><pre>382</pre></span><pre>				break</pre></div>
<div class="skip"><span class="num"><pre>383</pre></span><pre>		# END for each affected node try to get a valid shell</pre></div>
<div class="skip"><span class="num"><pre>384</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>385</pre></span><pre>		# AFFECTED PLUGS HANDLING</pre></div>
<div class="cov"><span class="num"><pre>386</pre></span><pre>		if not outputshell:</pre></div>
<div class="skip"><span class="num"><pre>387</pre></span><pre>			# try to use just the affected ones - that would be the best we have</pre></div>
<div class="nocov"><span class="num"><pre>388</pre></span><pre>			outplugs = inputshell.plug.affected()</pre></div>
<div class="skip"><span class="num"><pre>389</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>390</pre></span><pre>			if not outplugs:</pre></div>
<div class="nocov"><span class="num"><pre>391</pre></span><pre>				raise TargetError( &quot;Plug %r takes target %r as input, but does not affect an output plug that would take the same target type&quot; % ( str( inputshell ), target ) )</pre></div>
<div class="skip"><span class="num"><pre>392</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>393</pre></span><pre>			is_valid_shell = lambda shell: not these( shell ) and shell.plug.attr.compatabilityRate( target )</pre></div>
<div class="nocov"><span class="num"><pre>394</pre></span><pre>			for plug in outplugs:</pre></div>
<div class="nocov"><span class="num"><pre>395</pre></span><pre>				shell = inputshell.node.toShell( plug )</pre></div>
<div class="skip"><span class="num"><pre>396</pre></span><pre></pre></div>
<div class="nocov"><span class="num"><pre>397</pre></span><pre>				if is_valid_shell( shell ):</pre></div>
<div class="nocov"><span class="num"><pre>398</pre></span><pre>					log.warning(&quot;Did not find output plug delivering our target type - fallback to simple affected checks on node&quot;)</pre></div>
<div class="nocov"><span class="num"><pre>399</pre></span><pre>					outputshell = shell</pre></div>
<div class="nocov"><span class="num"><pre>400</pre></span><pre>					break</pre></div>
<div class="skip"><span class="num"><pre>401</pre></span><pre>				# END valid shell check</pre></div>
<div class="skip"><span class="num"><pre>402</pre></span><pre>			# END for each plug in node output plugs</pre></div>
<div class="skip"><span class="num"><pre>403</pre></span><pre>		# END try to get output shell by checking affects of current node</pre></div>
<div class="skip"><span class="num"><pre>404</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>405</pre></span><pre>		# still no shell ?</pre></div>
<div class="cov"><span class="num"><pre>406</pre></span><pre>		if not outputshell:</pre></div>
<div class="nocov"><span class="num"><pre>407</pre></span><pre>			raise TypeError( &quot;Target %s cannot be handled by this workflow (%s) as a computable output for %s cannot be found&quot; % ( target, self, str( inputshell ) ) )</pre></div>
<div class="skip"><span class="num"><pre>408</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>409</pre></span><pre>		# we do not care about ambiguity, simply pull one</pre></div>
<div class="skip"><span class="num"><pre>410</pre></span><pre>		# QUESTION: should we warn about multiple affected plugs ?</pre></div>
<div class="cov"><span class="num"><pre>411</pre></span><pre>		inputshell.set( target, ignore_connection = True )</pre></div>
<div class="cov"><span class="num"><pre>412</pre></span><pre>		return outputshell</pre></div>
<div class="skip"><span class="num"><pre>413</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>414</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>415</pre></span><pre>	def _evaluate( self, target, processmode, globalmode ):</pre></div>
<div class="cov"><span class="num"><pre>416</pre></span><pre>		&quot;&quot;&quot;Make or update the target using a process in our workflow</pre></div>
<div class="skip"><span class="num"><pre>417</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>418</pre></span><pre>		:param processmode: the mode with which to call the initial process</pre></div>
<div class="cov"><span class="num"><pre>419</pre></span><pre>		:return: tuple( shell, result ) - plugshell queried to get the result</pre></div>
<div class="cov"><span class="num"><pre>420</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>421</pre></span><pre>		outputshell = self._setupProcess( target, globalmode )</pre></div>
<div class="skip"><span class="num"><pre>422</pre></span><pre>		######################################################</pre></div>
<div class="cov"><span class="num"><pre>423</pre></span><pre>		result = outputshell.get( processmode )</pre></div>
<div class="skip"><span class="num"><pre>424</pre></span><pre>		######################################################</pre></div>
<div class="skip"><span class="num"><pre>425</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>426</pre></span><pre>		if len( self._callgraph._call_stack ):</pre></div>
<div class="nocov"><span class="num"><pre>427</pre></span><pre>			raise AssertionError( &quot;Callstack was not empty after calculations for %r where done&quot; % target )</pre></div>
<div class="skip"><span class="num"><pre>428</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>429</pre></span><pre>		return ( outputshell, result )</pre></div>
<div class="skip"><span class="num"><pre>430</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>431</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>432</pre></span><pre>	def createReportInstance( self, reportType ):</pre></div>
<div class="cov"><span class="num"><pre>433</pre></span><pre>		&quot;&quot;&quot;Create a report instance that describes how the previous target was made</pre></div>
<div class="skip"><span class="num"><pre>434</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>435</pre></span><pre>		:param reportType: Report to populate with information - it must be a Plan based</pre></div>
<div class="cov"><span class="num"><pre>436</pre></span><pre>			class that can be instantiated and populated with call information.</pre></div>
<div class="cov"><span class="num"><pre>437</pre></span><pre>			A report analyses the call dependency graph generated during dg evaluation</pre></div>
<div class="cov"><span class="num"><pre>438</pre></span><pre>			and presents it.</pre></div>
<div class="cov"><span class="num"><pre>439</pre></span><pre>		:return: report instance whose makeReport method can be called to retrieve it&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>440</pre></span><pre>		# make the target as dry run</pre></div>
<div class="cov"><span class="num"><pre>441</pre></span><pre>		return reportType( self._callgraph )</pre></div>
<div class="skip"><span class="num"><pre>442</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>443</pre></span><pre>	#} END main interface</pre></div>
<div class="skip"><span class="num"><pre>444</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>445</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>446</pre></span><pre>	#{ Query</pre></div>
<div class="skip"><span class="num"><pre>447</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>448</pre></span><pre>	def targetSupportList( self ):</pre></div>
<div class="cov"><span class="num"><pre>449</pre></span><pre>		&quot;&quot;&quot;:return: list of all supported target type</pre></div>
<div class="cov"><span class="num"><pre>450</pre></span><pre>		:note: this method is for informational purposes only&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>451</pre></span><pre>		uniqueout = set()</pre></div>
<div class="cov"><span class="num"><pre>452</pre></span><pre>		for node in self.iterNodes():</pre></div>
<div class="cov"><span class="num"><pre>453</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>454</pre></span><pre>				uniqueout.update( set( node.supportedTargetTypes() ) )</pre></div>
<div class="nocov"><span class="num"><pre>455</pre></span><pre>			except Exception, e:</pre></div>
<div class="nocov"><span class="num"><pre>456</pre></span><pre>				raise AssertionError( &quot;Process %r failed when calling supportedTargetTypes&quot; % p, e )</pre></div>
<div class="skip"><span class="num"><pre>457</pre></span><pre>		# END for each p in nodes iter</pre></div>
<div class="cov"><span class="num"><pre>458</pre></span><pre>		return list( uniqueout )</pre></div>
<div class="skip"><span class="num"><pre>459</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>460</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>461</pre></span><pre>	def targetRating( self, target ):</pre></div>
<div class="cov"><span class="num"><pre>462</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>463</pre></span><pre>		:return: int range(0,255) indicating how well a target can be made</pre></div>
<div class="cov"><span class="num"><pre>464</pre></span><pre>			0 means not at all, 255 means perfect.</pre></div>
<div class="skip"><span class="num"><pre>465</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>466</pre></span><pre>			Return value is tuple ( rate, PlugShell ), containing the process and plug with the</pre></div>
<div class="cov"><span class="num"><pre>467</pre></span><pre>			highest rating or None if rate is 0</pre></div>
<div class="skip"><span class="num"><pre>468</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>469</pre></span><pre>			Walk the dependency graph such that leaf nodes have higher ratings than</pre></div>
<div class="cov"><span class="num"><pre>470</pre></span><pre>			non-leaf nodes</pre></div>
<div class="cov"><span class="num"><pre>471</pre></span><pre>		:note: you can use the `process.ProcessBase` enumeration for comparison&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>472</pre></span><pre>		rescache = list()</pre></div>
<div class="cov"><span class="num"><pre>473</pre></span><pre>		best_process = None</pre></div>
<div class="skip"><span class="num"><pre>474</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>475</pre></span><pre>		for node in self.iterNodes( ):</pre></div>
<div class="cov"><span class="num"><pre>476</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>477</pre></span><pre>				rate, shell = node.targetRating( target )</pre></div>
<div class="nocov"><span class="num"><pre>478</pre></span><pre>			except TypeError,e:</pre></div>
<div class="skip"><span class="num"><pre>479</pre></span><pre>				# could be that there is a node having ambigous plugs, but we are not</pre></div>
<div class="skip"><span class="num"><pre>480</pre></span><pre>				# going to take it anyway</pre></div>
<div class="nocov"><span class="num"><pre>481</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>482</pre></span><pre>			# END try-except TypeError</pre></div>
<div class="skip"><span class="num"><pre>483</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>484</pre></span><pre>			if not rate:</pre></div>
<div class="cov"><span class="num"><pre>485</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>486</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>487</pre></span><pre>			# is leaf node ? ( no output connections )</pre></div>
<div class="cov"><span class="num"><pre>488</pre></span><pre>			if not node.connections( 0, 1 ):</pre></div>
<div class="cov"><span class="num"><pre>489</pre></span><pre>				rate = rate * 2									# prefer leafs in the rating</pre></div>
<div class="skip"><span class="num"><pre>490</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>491</pre></span><pre>			rescache.append( ( rate, shell ) )</pre></div>
<div class="skip"><span class="num"><pre>492</pre></span><pre>		# END for each process</pre></div>
<div class="skip"><span class="num"><pre>493</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>494</pre></span><pre>		rescache.sort()							# last is most suitable</pre></div>
<div class="cov"><span class="num"><pre>495</pre></span><pre>		if not rescache or rescache[-1][0] == 0:</pre></div>
<div class="cov"><span class="num"><pre>496</pre></span><pre>			return ( 0, None )</pre></div>
<div class="skip"><span class="num"><pre>497</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>498</pre></span><pre>		bestpick = rescache[-1]</pre></div>
<div class="skip"><span class="num"><pre>499</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>500</pre></span><pre>		# check if we have several best picks - raise if so</pre></div>
<div class="cov"><span class="num"><pre>501</pre></span><pre>		allbestpicks = [ pick for pick in rescache if pick[0] == bestpick[0] ]</pre></div>
<div class="cov"><span class="num"><pre>502</pre></span><pre>		if len( allbestpicks ) &gt; 1:</pre></div>
<div class="cov"><span class="num"><pre>503</pre></span><pre>			raise AssertionError( &quot;There should only be one suitable process for %r, found %i (%s)&quot; % ( target, len( allbestpicks ), allbestpicks ) )</pre></div>
<div class="skip"><span class="num"><pre>504</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>505</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>506</pre></span><pre>		shell = bestpick[1]</pre></div>
<div class="skip"><span class="num"><pre>507</pre></span><pre>		# recompute rate as we might have changed it</pre></div>
<div class="cov"><span class="num"><pre>508</pre></span><pre>		return shell.node.targetRating( target )</pre></div>
<div class="skip"><span class="num"><pre>509</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>510</pre></span><pre>	def callgraph( self ):</pre></div>
<div class="cov"><span class="num"><pre>511</pre></span><pre>		&quot;&quot;&quot;:return: current callgraph instance</pre></div>
<div class="cov"><span class="num"><pre>512</pre></span><pre>		:note: its strictly read-only and may not be changed&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>513</pre></span><pre>		return self._callgraph</pre></div>
<div class="skip"><span class="num"><pre>514</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>515</pre></span><pre>	#} END query</pre></div>
<div class="skip"><span class="num"><pre>516</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>517</pre></span><pre>	#{ Internal Process Interface</pre></div>
<div class="skip"><span class="num"><pre>518</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>519</pre></span><pre>	def _isDryRun( self ):</pre></div>
<div class="cov"><span class="num"><pre>520</pre></span><pre>		&quot;&quot;&quot;:return: True if the current computation is a dry run&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>521</pre></span><pre>		return self._mode</pre></div>
<div class="skip"><span class="num"><pre>522</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>523</pre></span><pre>	def _trackOutputQueryStart( self, process, plug, mode ):</pre></div>
<div class="cov"><span class="num"><pre>524</pre></span><pre>		&quot;&quot;&quot;Called by process base to indicate the start of a call of curProcess to targetProcess</pre></div>
<div class="cov"><span class="num"><pre>525</pre></span><pre>		This method tracks the actual call path taken through the graph ( which is dependent on the</pre></div>
<div class="cov"><span class="num"><pre>526</pre></span><pre>		dirty state of the prcoesses, allowing to walk it depth first to resolve the calls.</pre></div>
<div class="cov"><span class="num"><pre>527</pre></span><pre>		This also allows to create precise reports telling how to achieve a certain goal&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>528</pre></span><pre>		pdata = Workflow.ProcessData( process, plug, mode )</pre></div>
<div class="skip"><span class="num"><pre>529</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>530</pre></span><pre>		# keep the call graph</pre></div>
<div class="cov"><span class="num"><pre>531</pre></span><pre>		self._callgraph.startCall( pdata )</pre></div>
<div class="cov"><span class="num"><pre>532</pre></span><pre>		return pdata			# return so that decorators can use this information</pre></div>
<div class="skip"><span class="num"><pre>533</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>534</pre></span><pre>	def _trackOutputQueryEnd( self, result = None ):</pre></div>
<div class="cov"><span class="num"><pre>535</pre></span><pre>		&quot;&quot;&quot;Track that the process just finished its computation - thus the previously active process</pre></div>
<div class="cov"><span class="num"><pre>536</pre></span><pre>		should be on top of the stack again&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>537</pre></span><pre>		# update last data and its call time</pre></div>
<div class="cov"><span class="num"><pre>538</pre></span><pre>		self._callgraph.endCall( result )</pre></div>
<div class="skip"><span class="num"><pre>539</pre></span><pre>	#}</pre></div>
<div class="skip"><span class="num"><pre>540</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>541</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>542</pre></span><pre>	def _populateFromGraph( self, graph ):</pre></div>
<div class="cov"><span class="num"><pre>543</pre></span><pre>		&quot;&quot;&quot;Parse the networkx graph and populate ourselves with the respective process</pre></div>
<div class="cov"><span class="num"><pre>544</pre></span><pre>		instances as described by the graph</pre></div>
<div class="skip"><span class="num"><pre>545</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>546</pre></span><pre>		:param graph: networkx graph whose nodes are process names to be found in the processes</pre></div>
<div class="cov"><span class="num"><pre>547</pre></span><pre>			module &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>548</pre></span><pre>		raise NotImplementedError( &quot;TODO&quot; )</pre></div>
<div class="skip"><span class="num"><pre>549</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>550</pre></span><pre></pre></div>
</div>
</body>
</html>
