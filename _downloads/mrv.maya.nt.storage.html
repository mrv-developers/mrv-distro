<html>
<head>
<title>mrv.maya.nt.storage</title>
</head>
<body>
mrv.maya.nt.storage
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 369 lines<br/>
Missed: 30 lines<br/>
Skipped 182 lines<br/>
Percent: 92 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;Contains an implementation for the Persistence plugin for easy access within </pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>mrv and derived nodes.</pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>  6</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>import os</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>from persistence import PyPickleData</pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>import maya.OpenMaya as api</pre></div>
<div class="skip"><span class="num"><pre> 10</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>import mrv.maya.undo as undo</pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>from mrv.util import iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre> 13</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>from base import Node, DependNode, Data, createNode, delete</pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>from set import ObjectSet</pre></div>
<div class="skip"><span class="num"><pre> 16</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>import copy</pre></div>
<div class="skip"><span class="num"><pre> 18</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 19</pre></span><pre>MFnDependencyNode = api.MFnDependencyNode</pre></div>
<div class="skip"><span class="num"><pre> 20</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 21</pre></span><pre>__all__ = (&quot;StorageBase&quot;, &quot;StorageNode&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 22</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 23</pre></span><pre>#{ Procedural Access</pre></div>
<div class="skip"><span class="num"><pre> 24</pre></span><pre># Functions to access most functionality of the storagebase without actually deriving from it</pre></div>
<div class="skip"><span class="num"><pre> 25</pre></span><pre># They are as low-level as possible regarding their input parameters</pre></div>
<div class="skip"><span class="num"><pre> 26</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>def findStoragePlug(masterPlug, dataID):</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>	&quot;&quot;&quot;:return: compound plug containing all data and connections for the given dataID</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>	:param masterPlug: compound plug containing all data&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>	for compoundplug in masterPlug:</pre></div>
<div class="cov"><span class="num"><pre> 31</pre></span><pre>		if compoundplug.child(0).asString() == dataID:</pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>			return compoundplug</pre></div>
<div class="skip"><span class="num"><pre> 33</pre></span><pre>	# END for each elemnt (in search for mathching dataID)</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>	return None</pre></div>
<div class="skip"><span class="num"><pre> 35</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>def _makeElementPlug(masterPlug, dataID):</pre></div>
<div class="cov"><span class="num"><pre> 38</pre></span><pre>	&quot;&quot;&quot;Find an empty logical plug index and return the newly created</pre></div>
<div class="cov"><span class="num"><pre> 39</pre></span><pre>	logical plug with given dataID - unconditionally&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 40</pre></span><pre>	elementPlug = masterPlug.mnextLogicalPlug()</pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>	elementPlug.child(0).msetString(dataID)</pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>	return elementPlug</pre></div>
<div class="skip"><span class="num"><pre> 43</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre> 45</pre></span><pre>def storagePlug(masterPlug, dataID, plugType = None, autoCreate=False):</pre></div>
<div class="cov"><span class="num"><pre> 46</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>	:return: plug of the given type, either as tuple of two plugs or the plug</pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>		specified by plugType</pre></div>
<div class="cov"><span class="num"><pre> 49</pre></span><pre>	:param masterPlug: masterPlug to search for data</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>	:param dataID: the name of the plug to be returned</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>	:param plugType:</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>		StorageBase.kMessage: return message array plug only</pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>		StorageBase.kValue: return python pickle array plug only</pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>		StorageBase.kStorage: return the storage plug itself containing message and the value plug</pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>		StorageBase.kFlags return plug to integer which can be used as storage for bitflags to accompany the id</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>		None: return (picklePlug , messagePlug)</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>	:param autoCreate: if True, a plug with the given dataID will be created if it does not</pre></div>
<div class="cov"><span class="num"><pre> 58</pre></span><pre>		yet exist</pre></div>
<div class="cov"><span class="num"><pre> 59</pre></span><pre>	:raise AttributeError: if a plug with dataID does not exist and default value is None</pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>	:raise TypeError: if  plugtype unknown &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>	matchedplug = findStoragePlug(masterPlug, dataID)</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>	if matchedplug is None:</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>		if autoCreate:</pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>			matchedplug = _makeElementPlug(masterPlug, dataID)</pre></div>
<div class="cov"><span class="num"><pre> 65</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>			raise AttributeError(&quot;Plug with id %s not found&quot; % dataID)</pre></div>
<div class="skip"><span class="num"><pre> 67</pre></span><pre>	# END matched plug not found handling</pre></div>
<div class="skip"><span class="num"><pre> 68</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 69</pre></span><pre>	# return the result</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>	if plugType is None:</pre></div>
<div class="nocov"><span class="num"><pre> 71</pre></span><pre>		return (matchedplug.child(2), matchedplug.child(3))</pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>	elif plugType == StorageBase.kStorage:</pre></div>
<div class="nocov"><span class="num"><pre> 73</pre></span><pre>		return matchedplug</pre></div>
<div class="cov"><span class="num"><pre> 74</pre></span><pre>	elif plugType == StorageBase.kValue:</pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>		return matchedplug.child(2)</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>	elif plugType == StorageBase.kMessage:</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>		return matchedplug.child(3)</pre></div>
<div class="cov"><span class="num"><pre> 78</pre></span><pre>	elif plugType == StorageBase.kFlags:</pre></div>
<div class="cov"><span class="num"><pre> 79</pre></span><pre>		return matchedplug.child(1)</pre></div>
<div class="nocov"><span class="num"><pre> 80</pre></span><pre>	else:</pre></div>
<div class="nocov"><span class="num"><pre> 81</pre></span><pre>		raise TypeError(&quot;Invalid plugType value: %s&quot; % plugType)</pre></div>
<div class="skip"><span class="num"><pre> 82</pre></span><pre>	#END handle plug type</pre></div>
<div class="skip"><span class="num"><pre> 83</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>def makePlug(masterPlug, dataID):</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>	&quot;&quot;&quot;retrieve or create a plug that corresponds to the given dataID</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	:param dataID: string identifier</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>	:return: the created data plug, containing subplugs dval and dmsg</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>		for generic data and  message connections respectively &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre> 90</pre></span><pre>	existingPlug = findStoragePlug(masterPlug, dataID)</pre></div>
<div class="nocov"><span class="num"><pre> 91</pre></span><pre>	if existingPlug is not None:</pre></div>
<div class="nocov"><span class="num"><pre> 92</pre></span><pre>		return existingPlug</pre></div>
<div class="skip"><span class="num"><pre> 93</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 94</pre></span><pre>	# otherwise create it - find a free logical index - do a proper search</pre></div>
<div class="nocov"><span class="num"><pre> 95</pre></span><pre>	return _makeElementPlug(masterPlug, dataID)</pre></div>
<div class="skip"><span class="num"><pre> 96</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>def setsByPlug(mdplug):</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>	&quot;&quot;&quot;:return: all objectSets stored at the given message data plug&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 99</pre></span><pre>	allnodes = [p.mwrappedNode() for p in mdplug.minputs()]</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>	return [n for n in allnodes if isinstance(n, ObjectSet)]</pre></div>
<div class="skip"><span class="num"><pre>101</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>def partition(mdplug):</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>	&quot;&quot;&quot;:return: parition node attached to the sets of the given message data plug or None&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>	sets = setsByPlug(mdplug)</pre></div>
<div class="skip"><span class="num"><pre>105</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>106</pre></span><pre>	# get the dominant partition</pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>	partitions = list()</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>	for s in sets:</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>		partitions.extend(s.partitions())</pre></div>
<div class="skip"><span class="num"><pre>110</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>111</pre></span><pre>	for p in partitions:</pre></div>
<div class="cov"><span class="num"><pre>112</pre></span><pre>		if hasattr(p, StorageBase.kPartitionIdAttr):</pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>			return p</pre></div>
<div class="skip"><span class="num"><pre>114</pre></span><pre>	# END for each partition</pre></div>
<div class="skip"><span class="num"><pre>115</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>116</pre></span><pre>	# nothing found, there is no partition yet</pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>	return None</pre></div>
<div class="skip"><span class="num"><pre>118</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>def objectSet(mdplug, setIndex, autoCreate=True, setPrefix=''):</pre></div>
<div class="cov"><span class="num"><pre>121</pre></span><pre>	&quot;&quot;&quot;Get an object set identified with setIndex at the given dataId</pre></div>
<div class="skip"><span class="num"><pre>122</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>	:param mdplug: data message plug whose object set to handle</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>	:param setIndex: logical index at which the set will be connected to our message plug array</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>	:param autoCreate: if True, a set will be created if it does not yet exist</pre></div>
<div class="cov"><span class="num"><pre>126</pre></span><pre>	:param setPrefix: if given, the string will be used as prefix for the name of newly created</pre></div>
<div class="cov"><span class="num"><pre>127</pre></span><pre>		object sets</pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>	:raises ValueError: if a set does not exist at setIndex and autoCreate is False</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>	:raises AttributeError: if the plug did not exist (and autocreate is False)</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>	:note: method is implicitly undoable if autoCreate is True, this also means that you cannot</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>		explicitly undo this operation as you do not know if undo has been queued or not</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>	:note: newly created sets will automatically use partitions if one of the sets does&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>	mp = mdplug</pre></div>
<div class="skip"><span class="num"><pre>134</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>135</pre></span><pre>	# array plug having our sets</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>	setplug = mp.elementByLogicalIndex(setIndex)</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>	inputplug = setplug.minput()</pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>	if inputplug.isNull():</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>		if not autoCreate:</pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>			raise AttributeError(&quot;Set at %s[%i] did not exist&quot; % (mp.name(), setIndex))</pre></div>
<div class="cov"><span class="num"><pre>141</pre></span><pre>		su = undo.StartUndo()			# make the following operations atomic</pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>		objset = createNode(setPrefix + &quot;Set&quot;, &quot;objectSet&quot;, forceNewLeaf = True)</pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>		inputplug = objset.message</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>		inputplug.mconnectTo(setplug)</pre></div>
<div class="skip"><span class="num"><pre>145</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>146</pre></span><pre>		# hook it up to the partition</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>		if partition(mdplug):</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>			setPartition(mdplug, True)</pre></div>
<div class="skip"><span class="num"><pre>149</pre></span><pre>	# END create set as needed</pre></div>
<div class="skip"><span class="num"><pre>150</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>151</pre></span><pre>	# return actual object set</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>	return inputplug.mwrappedNode()</pre></div>
<div class="skip"><span class="num"><pre>153</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>def dataIDs(masterPlug, data_prefix=''):</pre></div>
<div class="cov"><span class="num"><pre>155</pre></span><pre>	&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>	:return: list of all data ids available in the given master plug</pre></div>
<div class="cov"><span class="num"><pre>157</pre></span><pre>	:param data_prefix: the string prefix of data names which must match with the prefix</pre></div>
<div class="cov"><span class="num"><pre>158</pre></span><pre>		of the data id to be returned, with the matching prefix pruned. </pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>		By default, all data ids will match&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>	outids = list()</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>	for compoundplug in masterPlug:</pre></div>
<div class="cov"><span class="num"><pre>162</pre></span><pre>		did = compoundplug.child(0).asString()</pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>		if did.startswith(data_prefix):</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>			outids.append(did[len(data_prefix):])</pre></div>
<div class="skip"><span class="num"><pre>165</pre></span><pre>		# END if is valid id</pre></div>
<div class="skip"><span class="num"><pre>166</pre></span><pre>	# END for each compound plug element</pre></div>
<div class="cov"><span class="num"><pre>167</pre></span><pre>	return outids</pre></div>
<div class="skip"><span class="num"><pre>168</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>169</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre>170</pre></span><pre>def setPartition(mdplug, state):</pre></div>
<div class="cov"><span class="num"><pre>171</pre></span><pre>	&quot;&quot;&quot;Make all sets of the given data message plug use a partition or not</pre></div>
<div class="cov"><span class="num"><pre>172</pre></span><pre>	:param state: if True, a partition will be used, if False, it will be disabled</pre></div>
<div class="cov"><span class="num"><pre>173</pre></span><pre>	:note: this method makes sure that all sets are hooked up to the partition</pre></div>
<div class="cov"><span class="num"><pre>174</pre></span><pre>	:raise ValueError: If we did not have a single set to which to add to the partition</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>	:raise AttributeError: If the dataID has never had sets</pre></div>
<div class="cov"><span class="num"><pre>176</pre></span><pre>	:return: if state is True, the name of the possibly created (or existing) partition&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>	sets = setsByPlug(mdplug)</pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>	pt = partition(mdplug)</pre></div>
<div class="skip"><span class="num"><pre>179</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>180</pre></span><pre>	if state:</pre></div>
<div class="cov"><span class="num"><pre>181</pre></span><pre>		if pt is None:</pre></div>
<div class="cov"><span class="num"><pre>182</pre></span><pre>			if not sets:</pre></div>
<div class="nocov"><span class="num"><pre>183</pre></span><pre>				raise ValueError(&quot;Cannot create partition as plug %s did not have any connected sets&quot; % mdplug)</pre></div>
<div class="skip"><span class="num"><pre>184</pre></span><pre>			# END check sets exist</pre></div>
<div class="skip"><span class="num"><pre>185</pre></span><pre>			# create partition</pre></div>
<div class="cov"><span class="num"><pre>186</pre></span><pre>			pt = createNode(&quot;storagePartition&quot;, &quot;partition&quot;, forceNewLeaf=True)</pre></div>
<div class="skip"><span class="num"><pre>187</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>			tattr = api.MFnTypedAttribute()</pre></div>
<div class="cov"><span class="num"><pre>189</pre></span><pre>			attr = tattr.create(StorageBase.kPartitionIdAttr, &quot;pid&quot;, api.MFnData.kString)</pre></div>
<div class="cov"><span class="num"><pre>190</pre></span><pre>			pt.addAttribute(attr)</pre></div>
<div class="skip"><span class="num"><pre>191</pre></span><pre>		# END create partition</pre></div>
<div class="skip"><span class="num"><pre>192</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre>		# make sure all sets are members of our partition</pre></div>
<div class="cov"><span class="num"><pre>194</pre></span><pre>		pt.addSets(sets)</pre></div>
<div class="cov"><span class="num"><pre>195</pre></span><pre>		return pt</pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>	else:</pre></div>
<div class="cov"><span class="num"><pre>197</pre></span><pre>		if pt:</pre></div>
<div class="skip"><span class="num"><pre>198</pre></span><pre>			# delete partition</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre>			# have to clear partition as, for some reason, or own node will be killed as well !</pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>			pt.clear()</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>			delete(pt)</pre></div>
<div class="skip"><span class="num"><pre>202</pre></span><pre>		# END if we have a partision</pre></div>
<div class="skip"><span class="num"><pre>203</pre></span><pre>	# END state check</pre></div>
<div class="skip"><span class="num"><pre>204</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>205</pre></span><pre># implicitly undoable</pre></div>
<div class="cov"><span class="num"><pre>206</pre></span><pre>def clearDataPlug(vdplug):</pre></div>
<div class="cov"><span class="num"><pre>207</pre></span><pre>	&quot;&quot;&quot;Clear the data in the given value data plug&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>	plugindataobj = api.MFnPluginData().create(PyPickleData.kPluginDataId)</pre></div>
<div class="cov"><span class="num"><pre>209</pre></span><pre>	vdplug.msetMObject(plugindataobj)</pre></div>
<div class="skip"><span class="num"><pre>210</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre>212</pre></span><pre>def clearAllData(masterPlug):</pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>	&quot;&quot;&quot;Empty all data storage plugs beneath the given masterPlug. Message connections are currently</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>	not affected&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>215</pre></span><pre>	for compoundplug in masterPlug:</pre></div>
<div class="nocov"><span class="num"><pre>216</pre></span><pre>		clearDataPlug(compoundplug.child(2))</pre></div>
<div class="skip"><span class="num"><pre>217</pre></span><pre>	#END for each element plug</pre></div>
<div class="skip"><span class="num"><pre>218</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>@undoable</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>def deleteObjectSet(mdplug, setIndex):</pre></div>
<div class="cov"><span class="num"><pre>221</pre></span><pre>	&quot;&quot;&quot;Delete the object set at the given message data plug, at the given setIndex</pre></div>
<div class="cov"><span class="num"><pre>222</pre></span><pre>	:note: use this method to delete your sets instead of manual deletion as it will automatically</pre></div>
<div class="cov"><span class="num"><pre>223</pre></span><pre>		remove the managed partition in case the last set is being deleted&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>224</pre></span><pre>	try:</pre></div>
<div class="cov"><span class="num"><pre>225</pre></span><pre>		objset = objectSet(mdplug, setIndex, autoCreate = False)</pre></div>
<div class="nocov"><span class="num"><pre>226</pre></span><pre>	except AttributeError:</pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>		# did not exist, its fine</pre></div>
<div class="nocov"><span class="num"><pre>228</pre></span><pre>		return</pre></div>
<div class="cov"><span class="num"><pre>229</pre></span><pre>	else:</pre></div>
<div class="skip"><span class="num"><pre>230</pre></span><pre>		# if this is the last set, remove the partition as well</pre></div>
<div class="cov"><span class="num"><pre>231</pre></span><pre>		if len(setsByPlug(mdplug)) == 1:</pre></div>
<div class="cov"><span class="num"><pre>232</pre></span><pre>			setPartition(mdplug, False)</pre></div>
<div class="skip"><span class="num"><pre>233</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>234</pre></span><pre>		delete(objset)</pre></div>
<div class="skip"><span class="num"><pre>235</pre></span><pre>	# END obj set handling</pre></div>
<div class="skip"><span class="num"><pre>236</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>237</pre></span><pre>#} END procedural access</pre></div>
<div class="skip"><span class="num"><pre>238</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>239</pre></span><pre>#{ Storage Access</pre></div>
<div class="skip"><span class="num"><pre>240</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>class StorageBase(iDuplicatable):</pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>	&quot;&quot;&quot;A storage node contains a set of attributes allowing it to store</pre></div>
<div class="cov"><span class="num"><pre>243</pre></span><pre>	python data and objects being stored in a pickled format upon file save.</pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>	Additionally you can store connections.</pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>	Nodes used with this interface must be compatible to the following attribute scheme.</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>	To create that scheme, use `createStorageAttribute`</pre></div>
<div class="skip"><span class="num"><pre>247</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>248</pre></span><pre>	**Attribute Setup**::</pre></div>
<div class="skip"><span class="num"><pre>249</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>250</pre></span><pre>		(shortname (description) [data type])</pre></div>
<div class="cov"><span class="num"><pre>251</pre></span><pre>		dta (data)[multi compound]</pre></div>
<div class="cov"><span class="num"><pre>252</pre></span><pre>			id (data id)[string]</pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>			type (data type) [int]	# for your own use, store bitflags to specify attribute</pre></div>
<div class="cov"><span class="num"><pre>254</pre></span><pre>			dval (data value) [python pickle]</pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>			dmsg (data message)[multi message]</pre></div>
<div class="skip"><span class="num"><pre>256</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>257</pre></span><pre>	**Configuration**::</pre></div>
<div class="skip"><span class="num"><pre>258</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>		data_prefix: will prefix every value name when setting and getting values - this allows</pre></div>
<div class="cov"><span class="num"><pre>260</pre></span><pre>			several clients to use the same storage attribute (on the same node for example)</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>			It acts like a namespace</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>		attr_prefix: prefixes the actual maya attribute to access</pre></div>
<div class="cov"><span class="num"><pre>263</pre></span><pre>		maya_node: the maya node holding the actual attributes</pre></div>
<div class="skip"><span class="num"><pre>264</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>265</pre></span><pre>	:note: A mrv node should derive from this class to allow easy attribute access of its</pre></div>
<div class="cov"><span class="num"><pre>266</pre></span><pre>		own compatible attributes - its designed for flexiblity</pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>	:note: attribute accepts on the generic attribute should be set by a plugin node when it</pre></div>
<div class="cov"><span class="num"><pre>268</pre></span><pre>		creates its attributes</pre></div>
<div class="cov"><span class="num"><pre>269</pre></span><pre>	:todo: should self._node be stored as weakref ?&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>	kValue, kMessage, kStorage, kFlags = range(4)</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>	kPartitionIdAttr = &quot;bda_storagePartition&quot;		# may not change !</pre></div>
<div class="skip"><span class="num"><pre>272</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>	class PyPickleValue(object):</pre></div>
<div class="cov"><span class="num"><pre>274</pre></span><pre>		&quot;&quot;&quot;Wrapper object prividing native access to the wrapped python pickle object</pre></div>
<div class="cov"><span class="num"><pre>275</pre></span><pre>		and to the corresponding value plug, providing utlity methods for easier handling&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>276</pre></span><pre>		__slots__ = ('_plug', '_pydata', '_isReferenced', '_updateCalled')</pre></div>
<div class="skip"><span class="num"><pre>277</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>278</pre></span><pre>		def __init__(self, valueplug, pythondata):</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>			&quot;&quot;&quot;value plug contains the plugin data in pythondata&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>			sa = object.__setattr__ </pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>			sa(self, '_plug', valueplug)</pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>			sa(self, '_pydata', pythondata)</pre></div>
<div class="skip"><span class="num"><pre>283</pre></span><pre>			# note: Dont' use the wrapped node to prevent dependency cycles and improve performance</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>			sa(self, '_isReferenced', MFnDependencyNode(valueplug.node()).isFromReferencedFile())</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>			sa(self, '_updateCalled', False)</pre></div>
<div class="skip"><span class="num"><pre>286</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>287</pre></span><pre>		def __len__(self):</pre></div>
<div class="cov"><span class="num"><pre>288</pre></span><pre>			return len(self._pydata)</pre></div>
<div class="skip"><span class="num"><pre>289</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>		def __iter__(self):</pre></div>
<div class="cov"><span class="num"><pre>291</pre></span><pre>			return iter(self._pydata)</pre></div>
<div class="skip"><span class="num"><pre>292</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>		def __getattr__(self, attr):</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>			return getattr(self._pydata, attr)</pre></div>
<div class="skip"><span class="num"><pre>295</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>296</pre></span><pre>		def __setattr__(self, attr, val):</pre></div>
<div class="cov"><span class="num"><pre>297</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre>298</pre></span><pre>				object.__setattr__(self, attr, val)</pre></div>
<div class="nocov"><span class="num"><pre>299</pre></span><pre>			except AttributeError:</pre></div>
<div class="nocov"><span class="num"><pre>300</pre></span><pre>				self._pydata[attr] = val</pre></div>
<div class="skip"><span class="num"><pre>301</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>302</pre></span><pre>		def __getitem__(self, key):</pre></div>
<div class="cov"><span class="num"><pre>303</pre></span><pre>			return self._pydata[key]</pre></div>
<div class="skip"><span class="num"><pre>304</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>305</pre></span><pre>		def __setitem__(self, key, value):</pre></div>
<div class="cov"><span class="num"><pre>306</pre></span><pre>			self._pydata[key] = value</pre></div>
<div class="cov"><span class="num"><pre>307</pre></span><pre>			if self._isReferenced:</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>				self._valueChanged()		# assure we make it into the reference , but only if we change</pre></div>
<div class="skip"><span class="num"><pre>309</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>310</pre></span><pre>		def __delitem__(self, key):</pre></div>
<div class="cov"><span class="num"><pre>311</pre></span><pre>			del(self._pydata[key])</pre></div>
<div class="skip"><span class="num"><pre>312</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>313</pre></span><pre>		def _valueChanged(self):</pre></div>
<div class="cov"><span class="num"><pre>314</pre></span><pre>			&quot;&quot;&quot;Will be called automatically if the underlying value changed if</pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>			the node of the underlying plug is referenced</pre></div>
<div class="skip"><span class="num"><pre>316</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>317</pre></span><pre>			:note: this method will only be called once during the lifetime of this object if it changes,</pre></div>
<div class="cov"><span class="num"><pre>318</pre></span><pre>				as its enough to trigger reference to write the value if it changes once.</pre></div>
<div class="cov"><span class="num"><pre>319</pre></span><pre>				Getting and setting data is expensive as there is a tracking dict in the background</pre></div>
<div class="cov"><span class="num"><pre>320</pre></span><pre>				being spawned with internally created copies.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>321</pre></span><pre>			if self._updateCalled:</pre></div>
<div class="nocov"><span class="num"><pre>322</pre></span><pre>				return</pre></div>
<div class="cov"><span class="num"><pre>323</pre></span><pre>			self._plug.msetMObject(self._plug.asMObject())</pre></div>
<div class="cov"><span class="num"><pre>324</pre></span><pre>			self._updateCalled = True</pre></div>
<div class="skip"><span class="num"><pre>325</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>326</pre></span><pre>		#{ Interface</pre></div>
<div class="skip"><span class="num"><pre>327</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>328</pre></span><pre>		def isReferenced(self):</pre></div>
<div class="cov"><span class="num"><pre>329</pre></span><pre>			&quot;&quot;&quot;:return: True if the data is from a referenced plug&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>330</pre></span><pre>			return self._isReferenced</pre></div>
<div class="skip"><span class="num"><pre>331</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>332</pre></span><pre>		#} END interface</pre></div>
<div class="skip"><span class="num"><pre>333</pre></span><pre>	# END class pypickle value</pre></div>
<div class="skip"><span class="num"><pre>334</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>335</pre></span><pre>	__slots__ = ('_dprefix', '_aprefix', '_node')</pre></div>
<div class="skip"><span class="num"><pre>336</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>337</pre></span><pre>	#{ Overridden Methods</pre></div>
<div class="cov"><span class="num"><pre>338</pre></span><pre>	def __init__(self, data_prefix='', maya_node = None, attr_prefix=''):</pre></div>
<div class="cov"><span class="num"><pre>339</pre></span><pre>		&quot;&quot;&quot;Allows customization of this base to modify its behaviour</pre></div>
<div class="cov"><span class="num"><pre>340</pre></span><pre>		:note: see more information on the input attributes in the class description&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>341</pre></span><pre>		# now one can derive from us and override __setattr__</pre></div>
<div class="cov"><span class="num"><pre>342</pre></span><pre>		object.__init__(self)</pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>		self._dprefix = data_prefix</pre></div>
<div class="cov"><span class="num"><pre>344</pre></span><pre>		self._aprefix = attr_prefix</pre></div>
<div class="cov"><span class="num"><pre>345</pre></span><pre>		self._node = maya_node</pre></div>
<div class="cov"><span class="num"><pre>346</pre></span><pre>		if not maya_node:</pre></div>
<div class="cov"><span class="num"><pre>347</pre></span><pre>			if not isinstance(self, Node):</pre></div>
<div class="nocov"><span class="num"><pre>348</pre></span><pre>				raise TypeError(&quot;StorageNode's derived class must be an instance of type %r if maya_node is not given&quot; % Node)</pre></div>
<div class="cov"><span class="num"><pre>349</pre></span><pre>			self._node = self</pre></div>
<div class="skip"><span class="num"><pre>350</pre></span><pre>		# END no maya node given handling</pre></div>
<div class="skip"><span class="num"><pre>351</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>352</pre></span><pre>	#} END overridden methods</pre></div>
<div class="skip"><span class="num"><pre>353</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>354</pre></span><pre>	#(iDuplicatable</pre></div>
<div class="cov"><span class="num"><pre>355</pre></span><pre>	def createInstance(self, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>356</pre></span><pre>		&quot;&quot;&quot;Create a new instance with our type&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>357</pre></span><pre>		return self.__class__(self._dprefix, self._node, self._aprefix)</pre></div>
<div class="skip"><span class="num"><pre>358</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>359</pre></span><pre>	def copyFrom(self, other, *args, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>360</pre></span><pre>		&quot;&quot;&quot;Copy all values from other to ourselves</pre></div>
<div class="skip"><span class="num"><pre>361</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>362</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>363</pre></span><pre>			 * shallow:</pre></div>
<div class="cov"><span class="num"><pre>364</pre></span><pre>			 	if True, default False, only a shallow copy will</pre></div>
<div class="cov"><span class="num"><pre>365</pre></span><pre>				be made. If False, a deep copy will be made</pre></div>
<div class="cov"><span class="num"><pre>366</pre></span><pre>		:note: only does so if the attribute and data prefixes actually match (which should be</pre></div>
<div class="cov"><span class="num"><pre>367</pre></span><pre>			the case if we get here, checking for it anyway</pre></div>
<div class="cov"><span class="num"><pre>368</pre></span><pre>		:note: as pickle data always copies by reference to be efficient, we have to explicitly</pre></div>
<div class="cov"><span class="num"><pre>369</pre></span><pre>			create new data to assure we really copy it</pre></div>
<div class="cov"><span class="num"><pre>370</pre></span><pre>		:todo: copy connections to our messages as well, make it an option at least&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>371</pre></span><pre>		self.setDataPrefix(other.dataPrefix())</pre></div>
<div class="cov"><span class="num"><pre>372</pre></span><pre>		self.setAttributePrefix(other.attributePrefix())</pre></div>
<div class="skip"><span class="num"><pre>373</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>374</pre></span><pre>		shallow = kwargs.pop(&quot;shallow&quot;, False)</pre></div>
<div class="cov"><span class="num"><pre>375</pre></span><pre>		for dataid in other.dataIDs():</pre></div>
<div class="cov"><span class="num"><pre>376</pre></span><pre>			othervalplug = other.storagePlug(dataid, plugType = self.kValue, autoCreate = False)</pre></div>
<div class="cov"><span class="num"><pre>377</pre></span><pre>			ownvalplug = self.storagePlug(dataid, plugType = self.kValue, autoCreate = True)</pre></div>
<div class="skip"><span class="num"><pre>378</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>379</pre></span><pre>			clearDataPlug(ownvalplug)</pre></div>
<div class="skip"><span class="num"><pre>380</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>381</pre></span><pre>			if shallow:</pre></div>
<div class="cov"><span class="num"><pre>382</pre></span><pre>				ownvalplug.msetMObject(othervalplug.asMObject())</pre></div>
<div class="cov"><span class="num"><pre>383</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>384</pre></span><pre>				owndict = self.pythonDataFromPlug(ownvalplug)</pre></div>
<div class="cov"><span class="num"><pre>385</pre></span><pre>				otherdict = other.pythonDataFromPlug(othervalplug)</pre></div>
<div class="skip"><span class="num"><pre>386</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>387</pre></span><pre>				# copy each value</pre></div>
<div class="cov"><span class="num"><pre>388</pre></span><pre>				for key in otherdict:</pre></div>
<div class="cov"><span class="num"><pre>389</pre></span><pre>					val = otherdict[key]</pre></div>
<div class="cov"><span class="num"><pre>390</pre></span><pre>					if isinstance(val, iDuplicatable):</pre></div>
<div class="nocov"><span class="num"><pre>391</pre></span><pre>						owndict[key] = val.duplicate()</pre></div>
<div class="cov"><span class="num"><pre>392</pre></span><pre>					else:</pre></div>
<div class="skip"><span class="num"><pre>393</pre></span><pre>						# try deep copy, use shallow copy on error</pre></div>
<div class="cov"><span class="num"><pre>394</pre></span><pre>						try:</pre></div>
<div class="cov"><span class="num"><pre>395</pre></span><pre>							owndict[key] = copy.deepcopy(val)</pre></div>
<div class="nocov"><span class="num"><pre>396</pre></span><pre>						except copy.Error:</pre></div>
<div class="nocov"><span class="num"><pre>397</pre></span><pre>							owndict[key] = val</pre></div>
<div class="skip"><span class="num"><pre>398</pre></span><pre>					# END copy operation</pre></div>
<div class="skip"><span class="num"><pre>399</pre></span><pre>				# END for each key to deep copy</pre></div>
<div class="skip"><span class="num"><pre>400</pre></span><pre>			# END shallow/deep copy</pre></div>
<div class="skip"><span class="num"><pre>401</pre></span><pre>		# END for each dataid</pre></div>
<div class="skip"><span class="num"><pre>402</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>403</pre></span><pre>	#) END iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre>404</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>405</pre></span><pre>	#{ Edit</pre></div>
<div class="skip"><span class="num"><pre>406</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>407</pre></span><pre>	def makePlug(self, dataID):</pre></div>
<div class="cov"><span class="num"><pre>408</pre></span><pre>		&quot;&quot;&quot;see ``makePlug`` module level function&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>409</pre></span><pre>		return makePlug(self.masterPlug(), self._dprefix + dataID)</pre></div>
<div class="skip"><span class="num"><pre>410</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>411</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>412</pre></span><pre>	def clearAllData(self):</pre></div>
<div class="cov"><span class="num"><pre>413</pre></span><pre>		&quot;&quot;&quot;see ``clearAllData`` module level method</pre></div>
<div class="cov"><span class="num"><pre>414</pre></span><pre>		:note: use this method if you want to make sure your node</pre></div>
<div class="cov"><span class="num"><pre>415</pre></span><pre>			is empty after it has been duplicated (would usually be done in the postContructor&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>416</pre></span><pre>		return clearAllData(self.masterPlug())</pre></div>
<div class="skip"><span class="num"><pre>417</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>418</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>419</pre></span><pre>	def clearData(self, dataID):</pre></div>
<div class="cov"><span class="num"><pre>420</pre></span><pre>		&quot;&quot;&quot;Clear all data stored in the given dataID&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>421</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>422</pre></span><pre>			valueplug = self.storagePlug(dataID, plugType=self.kValue, autoCreate = False)</pre></div>
<div class="nocov"><span class="num"><pre>423</pre></span><pre>		except AttributeError:</pre></div>
<div class="nocov"><span class="num"><pre>424</pre></span><pre>			return</pre></div>
<div class="cov"><span class="num"><pre>425</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>426</pre></span><pre>			clearDataPlug(valueplug)</pre></div>
<div class="skip"><span class="num"><pre>427</pre></span><pre>		# ELSE attr exists and clearage is required</pre></div>
<div class="skip"><span class="num"><pre>428</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>429</pre></span><pre>	#} END edit</pre></div>
<div class="skip"><span class="num"><pre>430</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>431</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>432</pre></span><pre>	#{ Query Plugs</pre></div>
<div class="skip"><span class="num"><pre>433</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>434</pre></span><pre>	def _elementPlug(self, dataID, dataType, autoCreate=False):</pre></div>
<div class="cov"><span class="num"><pre>435</pre></span><pre>		&quot;&quot;&quot;:return: element plug of the given type&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>436</pre></span><pre>		return storagePlug(self.masterPlug(), self._dprefix + dataID, dataType, autoCreate)</pre></div>
<div class="skip"><span class="num"><pre>437</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>438</pre></span><pre>	def findStoragePlug(self, dataID):</pre></div>
<div class="cov"><span class="num"><pre>439</pre></span><pre>		&quot;&quot;&quot;:return: compound plug with given dataID or None&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>440</pre></span><pre>		return findStoragePlug(self.masterPlug(), self._dprefix + dataID)</pre></div>
<div class="skip"><span class="num"><pre>441</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>442</pre></span><pre>	def masterPlug(self):</pre></div>
<div class="cov"><span class="num"><pre>443</pre></span><pre>		&quot;&quot;&quot;:return: master plug according to our attributePrefix&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>444</pre></span><pre>		return self._node.findPlug(self._aprefix + 'dta')</pre></div>
<div class="skip"><span class="num"><pre>445</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>446</pre></span><pre>	def dataIDs(self):</pre></div>
<div class="cov"><span class="num"><pre>447</pre></span><pre>		&quot;&quot;&quot;see module level function with the same name&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>448</pre></span><pre>		return dataIDs(self.masterPlug(), self._dprefix)</pre></div>
<div class="skip"><span class="num"><pre>449</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>450</pre></span><pre>	def storagePlug(self, dataID, plugType = None, autoCreate=False):</pre></div>
<div class="cov"><span class="num"><pre>451</pre></span><pre>		&quot;&quot;&quot;see ``storagePlug`` module level function&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>452</pre></span><pre>		return storagePlug(self.masterPlug(), self._dprefix+dataID, plugType, autoCreate)</pre></div>
<div class="skip"><span class="num"><pre>453</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>454</pre></span><pre>	#} END query plugs</pre></div>
<div class="skip"><span class="num"><pre>455</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>456</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>457</pre></span><pre>	#{ Query Data</pre></div>
<div class="cov"><span class="num"><pre>458</pre></span><pre>	def pythonData(self, dataID, **kwargs):</pre></div>
<div class="cov"><span class="num"><pre>459</pre></span><pre>		&quot;&quot;&quot;:return: PyPickleVal object at the given index (it can be modified natively)</pre></div>
<div class="cov"><span class="num"><pre>460</pre></span><pre>		:param dataID: id of of the data to retrieve</pre></div>
<div class="cov"><span class="num"><pre>461</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>462</pre></span><pre>			 * index: </pre></div>
<div class="cov"><span class="num"><pre>463</pre></span><pre>			 	element number of the plug to retrieve, or -1 to get a new plug.</pre></div>
<div class="cov"><span class="num"><pre>464</pre></span><pre>				Plugs will always be created, the given index specifies a logical plug index</pre></div>
<div class="cov"><span class="num"><pre>465</pre></span><pre>			 * Additionally all arguments supported by `storagePlug`&quot;&quot;&quot; </pre></div>
<div class="cov"><span class="num"><pre>466</pre></span><pre>		return self.pythonDataFromPlug(self._elementPlug(dataID, StorageBase.kValue, **kwargs))</pre></div>
<div class="skip"><span class="num"><pre>467</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>468</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>469</pre></span><pre>	def pythonDataFromPlug(cls, valplug):</pre></div>
<div class="cov"><span class="num"><pre>470</pre></span><pre>		&quot;&quot;&quot;Exract the python data using the given plug directly</pre></div>
<div class="skip"><span class="num"><pre>471</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>472</pre></span><pre>		:param valplug: data value plug containing the plugin data</pre></div>
<div class="cov"><span class="num"><pre>473</pre></span><pre>		:return: PyPickleData object allowing data access&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>474</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>475</pre></span><pre>		# initialize data if required</pre></div>
<div class="skip"><span class="num"><pre>476</pre></span><pre>		# if the data is null, we do not get a kNullObject, but an exception - fair enough ...</pre></div>
<div class="cov"><span class="num"><pre>477</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>478</pre></span><pre>			plugindata = valplug.masData()</pre></div>
<div class="cov"><span class="num"><pre>479</pre></span><pre>		except RuntimeError:</pre></div>
<div class="skip"><span class="num"><pre>480</pre></span><pre>			# set value</pre></div>
<div class="cov"><span class="num"><pre>481</pre></span><pre>			plugindataobj = api.MFnPluginData().create(PyPickleData.kPluginDataId)</pre></div>
<div class="skip"><span class="num"><pre>482</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>483</pre></span><pre>			# data gets copied here - re-retrieve data</pre></div>
<div class="cov"><span class="num"><pre>484</pre></span><pre>			valplug.msetMObject(plugindataobj) # use original version only - no undo support</pre></div>
<div class="cov"><span class="num"><pre>485</pre></span><pre>			plugindata = Data(plugindataobj)</pre></div>
<div class="skip"><span class="num"><pre>486</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>487</pre></span><pre>		# exstract the data</pre></div>
<div class="skip"><span class="num"><pre>488</pre></span><pre>		#return plugindata.data()</pre></div>
<div class="cov"><span class="num"><pre>489</pre></span><pre>		return StorageBase.PyPickleValue(valplug, plugindata.data())</pre></div>
<div class="skip"><span class="num"><pre>490</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>491</pre></span><pre>	#} END query Data</pre></div>
<div class="skip"><span class="num"><pre>492</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>493</pre></span><pre>	#{ Set Handling</pre></div>
<div class="cov"><span class="num"><pre>494</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>495</pre></span><pre>	def objectSet(self, dataID, setIndex, autoCreate = True):</pre></div>
<div class="cov"><span class="num"><pre>496</pre></span><pre>		&quot;&quot;&quot;see module level ``objectSet`` function&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>497</pre></span><pre>		return objectSet(self._elementPlug(dataID, self.kMessage, autoCreate), setIndex, autoCreate, dataID)</pre></div>
<div class="skip"><span class="num"><pre>498</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>499</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>500</pre></span><pre>	def deleteObjectSet(self, dataID, setIndex):</pre></div>
<div class="cov"><span class="num"><pre>501</pre></span><pre>		&quot;&quot;&quot;See the module level method called ``deleteObjectSet``&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>502</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>503</pre></span><pre>			return deleteObjectSet(self._elementPlug(dataID, self.kMessage, autoCreate = False), setIndex)</pre></div>
<div class="nocov"><span class="num"><pre>504</pre></span><pre>		except (ValueError, AttributeError):</pre></div>
<div class="skip"><span class="num"><pre>505</pre></span><pre>			# did not exist, its fine</pre></div>
<div class="nocov"><span class="num"><pre>506</pre></span><pre>			raise</pre></div>
<div class="nocov"><span class="num"><pre>507</pre></span><pre>			return</pre></div>
<div class="skip"><span class="num"><pre>508</pre></span><pre>		# END handle no such plug exists</pre></div>
<div class="skip"><span class="num"><pre>509</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>510</pre></span><pre>	def setsByID(self, dataID):</pre></div>
<div class="cov"><span class="num"><pre>511</pre></span><pre>		&quot;&quot;&quot;:return: all object sets stored under the given dataID&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>512</pre></span><pre>		return setsByPlug(self._elementPlug(dataID, self.kMessage, autoCreate=False))</pre></div>
<div class="skip"><span class="num"><pre>513</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>514</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>515</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>516</pre></span><pre>	def setPartition(self, dataID, state):</pre></div>
<div class="cov"><span class="num"><pre>517</pre></span><pre>		&quot;&quot;&quot;see ``setPartition`` function on module level&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>518</pre></span><pre>		return setPartition(self._elementPlug(dataID, self.kMessage, autoCreate=False), state)</pre></div>
<div class="skip"><span class="num"><pre>519</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>520</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>521</pre></span><pre>	def partition(self, dataID):</pre></div>
<div class="cov"><span class="num"><pre>522</pre></span><pre>		&quot;&quot;&quot;:return: partition Node attached to the sets at dataID or None if state is disabled&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>523</pre></span><pre>		return partition(self._elementPlug(dataID, self.kMessage, autoCreate=False))</pre></div>
<div class="skip"><span class="num"><pre>524</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>525</pre></span><pre>	#} END set handling</pre></div>
<div class="skip"><span class="num"><pre>526</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>527</pre></span><pre>	# Query General</pre></div>
<div class="skip"><span class="num"><pre>528</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>529</pre></span><pre>	def storageNode(self):</pre></div>
<div class="cov"><span class="num"><pre>530</pre></span><pre>		&quot;&quot;&quot;:return: Node actually being used as storage&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>531</pre></span><pre>		return self._node</pre></div>
<div class="skip"><span class="num"><pre>532</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>533</pre></span><pre>	def setStorageNode(self, node):</pre></div>
<div class="cov"><span class="num"><pre>534</pre></span><pre>		&quot;&quot;&quot;Set ourselves to use the given storage compatible node</pre></div>
<div class="skip"><span class="num"><pre>535</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>536</pre></span><pre>		:note: use this if the path of our instance has changed - otherwise</pre></div>
<div class="cov"><span class="num"><pre>537</pre></span><pre>			trying to access functions will fail as the path of our node might be invalid&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>538</pre></span><pre>		self._node = node</pre></div>
<div class="skip"><span class="num"><pre>539</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>540</pre></span><pre>	def setDataPrefix(self, prefix):</pre></div>
<div class="cov"><span class="num"><pre>541</pre></span><pre>		&quot;&quot;&quot;Change the data prefix to the given value string&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>542</pre></span><pre>		self._dprefix = prefix</pre></div>
<div class="skip"><span class="num"><pre>543</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>544</pre></span><pre>	def dataPrefix(self):</pre></div>
<div class="cov"><span class="num"><pre>545</pre></span><pre>		&quot;&quot;&quot;:return: our data prefix&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>546</pre></span><pre>		return self._dprefix</pre></div>
<div class="skip"><span class="num"><pre>547</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>548</pre></span><pre>	def attributePrefix(self):</pre></div>
<div class="cov"><span class="num"><pre>549</pre></span><pre>		&quot;&quot;&quot;:return: our attribute prefix&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>550</pre></span><pre>		return self._aprefix</pre></div>
<div class="skip"><span class="num"><pre>551</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>552</pre></span><pre>	def setAttributePrefix(self, prefix):</pre></div>
<div class="cov"><span class="num"><pre>553</pre></span><pre>		&quot;&quot;&quot;Change the prefix with which to access to the actual storage data attributes on our node</pre></div>
<div class="cov"><span class="num"><pre>554</pre></span><pre>		to the given string&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>555</pre></span><pre>		self._aprefix = prefix</pre></div>
<div class="skip"><span class="num"><pre>556</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>557</pre></span><pre>	# END query general</pre></div>
<div class="skip"><span class="num"><pre>558</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>559</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>560</pre></span><pre>class StorageNode(DependNode, StorageBase):</pre></div>
<div class="cov"><span class="num"><pre>561</pre></span><pre>	&quot;&quot;&quot;This node can be used as pythonic and easy-to-access value container - it could</pre></div>
<div class="cov"><span class="num"><pre>562</pre></span><pre>	be connected to your node, and queried for values actually being queried on your node.</pre></div>
<div class="cov"><span class="num"><pre>563</pre></span><pre>	As value container, it can easily be replaced by another one, or keep different sets of information</pre></div>
<div class="skip"><span class="num"><pre>564</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>565</pre></span><pre>	:note: the storage node can only use generic attributes and recover them properly during scene reload</pre></div>
<div class="cov"><span class="num"><pre>566</pre></span><pre>		if the configuration of the generic attributes have been setup properly - they are unique only per</pre></div>
<div class="cov"><span class="num"><pre>567</pre></span><pre>		node type, not per instance of the node type.</pre></div>
<div class="cov"><span class="num"><pre>568</pre></span><pre>		Thus it is recommened to use the storage node attribute base on your own custom type that setsup the</pre></div>
<div class="cov"><span class="num"><pre>569</pre></span><pre>		generic attributes as it requires during plugin load&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>570</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>571</pre></span><pre>	#{ Overrriden Methods</pre></div>
<div class="cov"><span class="num"><pre>572</pre></span><pre>	def __init__(self, *args):</pre></div>
<div class="cov"><span class="num"><pre>573</pre></span><pre>		&quot;&quot;&quot;initialize bases properly&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>574</pre></span><pre>		DependNode.__init__(self)</pre></div>
<div class="cov"><span class="num"><pre>575</pre></span><pre>		StorageBase.__init__(self)</pre></div>
<div class="skip"><span class="num"><pre>576</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>577</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>578</pre></span><pre>	#} END overridden methods</pre></div>
<div class="skip"><span class="num"><pre>579</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>580</pre></span><pre>#} END storage access</pre></div>
<div class="skip"><span class="num"><pre>581</pre></span><pre></pre></div>
</div>
</body>
</html>
