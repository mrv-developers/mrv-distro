<html>
<head>
<title>mrv.maya.nt.storage</title>
</head>
<body>
mrv.maya.nt.storage
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 309 lines<br/>
Missed: 26 lines<br/>
Skipped 157 lines<br/>
Percent: 92 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;Contains an implementation for the Persistence plugin for easy access within </pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>mrv and derived nodes.</pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  5</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>  6</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>import os</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>from persistence import PyPickleData</pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>import maya.OpenMaya as api</pre></div>
<div class="skip"><span class="num"><pre> 10</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>import mrv.maya.undo as undo</pre></div>
<div class="cov"><span class="num"><pre> 12</pre></span><pre>from mrv.util import iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre> 13</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>from base import Node, DependNode, Data, createNode, delete</pre></div>
<div class="cov"><span class="num"><pre> 15</pre></span><pre>from set import ObjectSet</pre></div>
<div class="skip"><span class="num"><pre> 16</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>import copy</pre></div>
<div class="skip"><span class="num"><pre> 18</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 19</pre></span><pre>__all__ = ( &quot;StorageBase&quot;, &quot;StorageNode&quot; )</pre></div>
<div class="skip"><span class="num"><pre> 20</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 21</pre></span><pre>#{ Storage Access</pre></div>
<div class="skip"><span class="num"><pre> 22</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>class StorageBase( iDuplicatable ):</pre></div>
<div class="cov"><span class="num"><pre> 24</pre></span><pre>	&quot;&quot;&quot;A storage node contains a set of attributes allowing it to store</pre></div>
<div class="cov"><span class="num"><pre> 25</pre></span><pre>	python data and objects being stored in a pickled format upon file save.</pre></div>
<div class="cov"><span class="num"><pre> 26</pre></span><pre>	Additionally you can store connections.</pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>	Nodes used with this interface must be compatible to the following attribute scheme.</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>	To create that scheme, use `createStorageAttribute`</pre></div>
<div class="skip"><span class="num"><pre> 29</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>	**Attribute Setup**::</pre></div>
<div class="skip"><span class="num"><pre> 31</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>		( shortname ( description ) [ data type ] )</pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>		dta ( data )[ multi compound ]</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>			id ( data id )[ string ]</pre></div>
<div class="cov"><span class="num"><pre> 35</pre></span><pre>			type ( data type ) [ int ]	# for your own use, store bitflags to specify attribute</pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>			dval ( data value ) [ python pickle ]</pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>			dmsg ( data message )[ multi message ]</pre></div>
<div class="skip"><span class="num"><pre> 38</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 39</pre></span><pre>	**Configuration**::</pre></div>
<div class="skip"><span class="num"><pre> 40</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>		attrprefix: will prefix every attribute during attr set and get - this allows</pre></div>
<div class="cov"><span class="num"><pre> 42</pre></span><pre>			several clients to access the same storage base ( on the same node for example )</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>			It acts like a namespace</pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>		mayaNode: the maya node holding the actual attributes</pre></div>
<div class="skip"><span class="num"><pre> 45</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 46</pre></span><pre>	:note: A mrv node should derive from this class to allow easy attribute access of its</pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>		own compatible attributes - its designed for flexiblity</pre></div>
<div class="cov"><span class="num"><pre> 48</pre></span><pre>	:note: attribute accepts on the generic attribute should be set by a plugin node when it</pre></div>
<div class="cov"><span class="num"><pre> 49</pre></span><pre>		creates its attributes</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>	:todo: should self._node be stored as weakref ?&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>	kValue, kMessage, kStorage = range( 3 )</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>	_partitionIdAttr = &quot;bda_storagePartition&quot;</pre></div>
<div class="skip"><span class="num"><pre> 53</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 54</pre></span><pre>	class PyPickleValue( object ):</pre></div>
<div class="cov"><span class="num"><pre> 55</pre></span><pre>		&quot;&quot;&quot;Wrapper object prividing native access to the wrapped python pickle object</pre></div>
<div class="cov"><span class="num"><pre> 56</pre></span><pre>		and to the corresponding value plug, providing utlity methods for easier handling&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 57</pre></span><pre>		__slots__ = ( '_plug', '_pydata', '_isReferenced', '_updateCalled' )</pre></div>
<div class="skip"><span class="num"><pre> 58</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 59</pre></span><pre>		def __init__( self, valueplug, pythondata ):</pre></div>
<div class="cov"><span class="num"><pre> 60</pre></span><pre>			&quot;&quot;&quot;value plug contains the plugin data in pythondata&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 61</pre></span><pre>			object.__setattr__( self, '_plug', valueplug )</pre></div>
<div class="cov"><span class="num"><pre> 62</pre></span><pre>			object.__setattr__( self, '_pydata', pythondata )</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>			object.__setattr__( self, '_isReferenced', valueplug.mwrappedNode( ).isReferenced( ) )</pre></div>
<div class="cov"><span class="num"><pre> 64</pre></span><pre>			object.__setattr__( self, '_updateCalled', False )</pre></div>
<div class="skip"><span class="num"><pre> 65</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 66</pre></span><pre>		def __len__( self ):</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>			return len( self._pydata )</pre></div>
<div class="skip"><span class="num"><pre> 68</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 69</pre></span><pre>		def __iter__( self ):</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>			return iter( self._pydata )</pre></div>
<div class="skip"><span class="num"><pre> 71</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>		def __getattr__( self, attr ):</pre></div>
<div class="cov"><span class="num"><pre> 73</pre></span><pre>			return getattr( self._pydata, attr )</pre></div>
<div class="skip"><span class="num"><pre> 74</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>		def __setattr__( self, attr, val ):</pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>				object.__setattr__( self, attr, val )</pre></div>
<div class="nocov"><span class="num"><pre> 78</pre></span><pre>			except AttributeError:</pre></div>
<div class="nocov"><span class="num"><pre> 79</pre></span><pre>				self._pydata[ attr ] = val</pre></div>
<div class="skip"><span class="num"><pre> 80</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 81</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 82</pre></span><pre>		def __getitem__( self, key ):</pre></div>
<div class="cov"><span class="num"><pre> 83</pre></span><pre>			return self._pydata[ key ]</pre></div>
<div class="skip"><span class="num"><pre> 84</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 85</pre></span><pre>		def __setitem__( self, key, value ):</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>			self._pydata[ key ] = value</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>			if self._isReferenced:</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>				self.valueChanged()		# assure we make it into the reference , but only if we change</pre></div>
<div class="skip"><span class="num"><pre> 89</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 90</pre></span><pre>		def valueChanged( self ):</pre></div>
<div class="cov"><span class="num"><pre> 91</pre></span><pre>			&quot;&quot;&quot;Will be called automatically if the underlying value changed if</pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>			the node of the underlying plug is referenced</pre></div>
<div class="skip"><span class="num"><pre> 93</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>			:note: this method will only be called once during the lifetime of this object if it changes,</pre></div>
<div class="cov"><span class="num"><pre> 95</pre></span><pre>				as its enough to trigger reference to write the value if it changes once.</pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>				Getting and setting data is expensive as there is a tracking dict in the background</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>				being spawned with internally created copies.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>			if self._updateCalled:</pre></div>
<div class="nocov"><span class="num"><pre> 99</pre></span><pre>				return</pre></div>
<div class="cov"><span class="num"><pre>100</pre></span><pre>			self._plug.msetMObject( self._plug.asMObject() )</pre></div>
<div class="cov"><span class="num"><pre>101</pre></span><pre>			self._updateCalled = True</pre></div>
<div class="skip"><span class="num"><pre>102</pre></span><pre>	# END class pypickle value</pre></div>
<div class="skip"><span class="num"><pre>103</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>104</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>105</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>106</pre></span><pre>	#{ Overridden Methods</pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>	def __init__( self, attrprefix = &quot;&quot;, mayaNode = None ):</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>		&quot;&quot;&quot;Allows customization of this base to modify its behaviour</pre></div>
<div class="skip"><span class="num"><pre>109</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>		:note: see more information on the input attributes in the class description&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>111</pre></span><pre>		# now one can derive from us and override __setattr__</pre></div>
<div class="cov"><span class="num"><pre>112</pre></span><pre>		object.__init__( self )</pre></div>
<div class="cov"><span class="num"><pre>113</pre></span><pre>		self._attrprefix = attrprefix</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>		self._node = mayaNode</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>		if not mayaNode:</pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>			if not isinstance( self, Node ):</pre></div>
<div class="nocov"><span class="num"><pre>117</pre></span><pre>				raise TypeError( &quot;StorageNode's derived class must be an instance of type %r if mayaNode is not given&quot; % Node )</pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>			self._node = self</pre></div>
<div class="skip"><span class="num"><pre>119</pre></span><pre>		# END no maya node given handling</pre></div>
<div class="skip"><span class="num"><pre>120</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>121</pre></span><pre>	#} END overridden methods</pre></div>
<div class="skip"><span class="num"><pre>122</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>123</pre></span><pre>	#( iDuplicatable</pre></div>
<div class="cov"><span class="num"><pre>124</pre></span><pre>	def createInstance( self, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>		&quot;&quot;&quot;Create a new instance with our type&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>126</pre></span><pre>		return self.__class__( self._attrprefix, self._node )</pre></div>
<div class="skip"><span class="num"><pre>127</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>	def copyFrom( self, other, *args, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>		&quot;&quot;&quot;Copy all values from other to ourselves</pre></div>
<div class="skip"><span class="num"><pre>130</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>			 * shallow:</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>			 	if True, default False, only a shallow copy will</pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>				be made. If False, a deep copy will be made</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>		:note: only does so if the attribute prefixes actually match ( which should be</pre></div>
<div class="cov"><span class="num"><pre>136</pre></span><pre>			the case if we get here, checking for it anyway</pre></div>
<div class="cov"><span class="num"><pre>137</pre></span><pre>		:note: as pickle data always copies by reference to be efficient, we have to explicitly</pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>			create new data to assure we really copy it</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>		:todo: copy connections to our messages as well, make it an option at least&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>140</pre></span><pre>		if self.attributePrefix() != other.attributePrefix():</pre></div>
<div class="nocov"><span class="num"><pre>141</pre></span><pre>			raise AssertionError( &quot;Attribute prefixes between self and other did not match&quot; )</pre></div>
<div class="skip"><span class="num"><pre>142</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>		shallow = kwargs.pop( &quot;shallow&quot;, False )</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>		for dataid in other.dataIDs():</pre></div>
<div class="cov"><span class="num"><pre>145</pre></span><pre>			othervalplug = other.storagePlug( dataid, plugType = self.kValue, autoCreate = False )</pre></div>
<div class="cov"><span class="num"><pre>146</pre></span><pre>			ownvalplug = self.storagePlug( dataid, plugType = self.kValue, autoCreate = True )</pre></div>
<div class="skip"><span class="num"><pre>147</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>			self._clearData( ownvalplug )</pre></div>
<div class="skip"><span class="num"><pre>149</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>150</pre></span><pre>			if shallow:</pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>				ownvalplug.msetMObject( othervalplug.asMObject() )</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>				owndict = self.pythonDataFromPlug( ownvalplug )</pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>				otherdict = other.pythonDataFromPlug( othervalplug )</pre></div>
<div class="skip"><span class="num"><pre>155</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>156</pre></span><pre>				# copy each value</pre></div>
<div class="cov"><span class="num"><pre>157</pre></span><pre>				for key in otherdict:</pre></div>
<div class="cov"><span class="num"><pre>158</pre></span><pre>					val = otherdict[ key ]</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>					if isinstance( val, iDuplicatable ):</pre></div>
<div class="nocov"><span class="num"><pre>160</pre></span><pre>						owndict[ key ] = val.duplicate( )</pre></div>
<div class="cov"><span class="num"><pre>161</pre></span><pre>					else:</pre></div>
<div class="skip"><span class="num"><pre>162</pre></span><pre>						# try deep copy, use shallow copy on error</pre></div>
<div class="cov"><span class="num"><pre>163</pre></span><pre>						try:</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>							owndict[ key ] = copy.deepcopy( val )</pre></div>
<div class="nocov"><span class="num"><pre>165</pre></span><pre>						except copy.Error:</pre></div>
<div class="nocov"><span class="num"><pre>166</pre></span><pre>							owndict[ key ] = val</pre></div>
<div class="skip"><span class="num"><pre>167</pre></span><pre>					# END copy operation</pre></div>
<div class="skip"><span class="num"><pre>168</pre></span><pre>				# END for each key to deep copy</pre></div>
<div class="skip"><span class="num"><pre>169</pre></span><pre>			# END shallow/deep copy</pre></div>
<div class="skip"><span class="num"><pre>170</pre></span><pre>		# END for each dataid</pre></div>
<div class="skip"><span class="num"><pre>171</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>172</pre></span><pre>	#) END iDuplicatable</pre></div>
<div class="skip"><span class="num"><pre>173</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>174</pre></span><pre>	def __makePlug( self, dataID ):</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>		&quot;&quot;&quot;Find an empty logical plug index and return the newly created</pre></div>
<div class="cov"><span class="num"><pre>176</pre></span><pre>		logical plug with given dataID&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>		elementPlug = self._node.dta.mnextLogicalPlug( )</pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>		elementPlug.mchildByName('id').msetString( dataID )</pre></div>
<div class="cov"><span class="num"><pre>179</pre></span><pre>		return elementPlug</pre></div>
<div class="skip"><span class="num"><pre>180</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>181</pre></span><pre>	#{ Edit</pre></div>
<div class="skip"><span class="num"><pre>182</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>183</pre></span><pre>	def makePlug( self, dataID ):</pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>		&quot;&quot;&quot;Create a plug that can be retrieved using the given dataID</pre></div>
<div class="skip"><span class="num"><pre>185</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>186</pre></span><pre>		:param dataID: string identifier</pre></div>
<div class="cov"><span class="num"><pre>187</pre></span><pre>		:return: the created master plug, containing subplugs dval and dmsg</pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>			for generic data and  message connections respectively &quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>189</pre></span><pre>		actualID = self._attrprefix + dataID</pre></div>
<div class="nocov"><span class="num"><pre>190</pre></span><pre>		existingPlug = self.findStoragePlug( dataID )</pre></div>
<div class="nocov"><span class="num"><pre>191</pre></span><pre>		if existingPlug is not None:</pre></div>
<div class="nocov"><span class="num"><pre>192</pre></span><pre>			return existingPlug</pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>194</pre></span><pre>		# otherwise create it - find a free logical index - do a proper search</pre></div>
<div class="nocov"><span class="num"><pre>195</pre></span><pre>		return self.__makePlug( actualID )</pre></div>
<div class="skip"><span class="num"><pre>196</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>197</pre></span><pre>	def _clearData( self, valueplug ):</pre></div>
<div class="cov"><span class="num"><pre>198</pre></span><pre>		&quot;&quot;&quot;Safely clear the data in valueplug - its undoable&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>199</pre></span><pre>		# NOTE: took special handling out - it shuld be done in the api-patch</pre></div>
<div class="skip"><span class="num"><pre>200</pre></span><pre>		# for an MPlug</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>		plugindataobj = api.MFnPluginData( ).create( PyPickleData.kPluginDataId )</pre></div>
<div class="cov"><span class="num"><pre>202</pre></span><pre>		valueplug.msetMObject( plugindataobj )</pre></div>
<div class="skip"><span class="num"><pre>203</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>205</pre></span><pre>	def clearAllData( self ):</pre></div>
<div class="cov"><span class="num"><pre>206</pre></span><pre>		&quot;&quot;&quot;empty the whole storage, creating new python storage data to assure</pre></div>
<div class="cov"><span class="num"><pre>207</pre></span><pre>		nothing is still referenced</pre></div>
<div class="skip"><span class="num"><pre>208</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>209</pre></span><pre>		:note: use this method if you want to make sure your node</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>			is empty after it has been duplicated ( would usually be done in the</pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>			postContructor&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>212</pre></span><pre>		for compoundplug in self._node.dta:</pre></div>
<div class="nocov"><span class="num"><pre>213</pre></span><pre>			self._clearData( compoundplug.mchildByName('dval') )</pre></div>
<div class="skip"><span class="num"><pre>214</pre></span><pre>		# END for each element in data compound</pre></div>
<div class="skip"><span class="num"><pre>215</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>216</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>217</pre></span><pre>	def clearData( self, dataID ):</pre></div>
<div class="cov"><span class="num"><pre>218</pre></span><pre>		&quot;&quot;&quot;Clear all data stored in the given dataID&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>			valueplug = self.storagePlug( dataID, plugType=self.kValue, autoCreate = False )</pre></div>
<div class="nocov"><span class="num"><pre>221</pre></span><pre>		except AttributeError:</pre></div>
<div class="nocov"><span class="num"><pre>222</pre></span><pre>			return</pre></div>
<div class="cov"><span class="num"><pre>223</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>224</pre></span><pre>			self._clearData( valueplug )</pre></div>
<div class="skip"><span class="num"><pre>225</pre></span><pre>		# ELSE attr exists and clearage is required</pre></div>
<div class="skip"><span class="num"><pre>226</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>227</pre></span><pre>	#} END edit</pre></div>
<div class="skip"><span class="num"><pre>228</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>229</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>230</pre></span><pre>	#{ Query Plugs</pre></div>
<div class="cov"><span class="num"><pre>231</pre></span><pre>	def findStoragePlug( self, dataID ):</pre></div>
<div class="cov"><span class="num"><pre>232</pre></span><pre>		&quot;&quot;&quot;:return: compound plug with given dataID or None&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>233</pre></span><pre>		actualID = self._attrprefix + dataID</pre></div>
<div class="cov"><span class="num"><pre>234</pre></span><pre>		for compoundplug in self._node.dta:</pre></div>
<div class="cov"><span class="num"><pre>235</pre></span><pre>			if compoundplug.mchildByName('id').asString( ) == actualID:</pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>				return compoundplug</pre></div>
<div class="skip"><span class="num"><pre>237</pre></span><pre>		# END for each elemnt ( in search for mathching dataID )</pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>		return None</pre></div>
<div class="skip"><span class="num"><pre>239</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>	def dataIDs( self ):</pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>		&quot;&quot;&quot;:return: list of all dataids available in the storage node</pre></div>
<div class="cov"><span class="num"><pre>242</pre></span><pre>		:note: respects attribute prefix, and will only see ids with matching prefix.</pre></div>
<div class="cov"><span class="num"><pre>243</pre></span><pre>			The prefix itself is transparent and will not bre returned&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>		outids = list()</pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>		for compoundplug in self._node.dta:</pre></div>
<div class="cov"><span class="num"><pre>246</pre></span><pre>			did = compoundplug.mchildByName('id').asString( )</pre></div>
<div class="cov"><span class="num"><pre>247</pre></span><pre>			if did and did.startswith( self._attrprefix ):</pre></div>
<div class="cov"><span class="num"><pre>248</pre></span><pre>				outids.append( did[ len( self._attrprefix ) : ] )</pre></div>
<div class="skip"><span class="num"><pre>249</pre></span><pre>			# END if is valid id</pre></div>
<div class="skip"><span class="num"><pre>250</pre></span><pre>		# END for each compound plug element</pre></div>
<div class="cov"><span class="num"><pre>251</pre></span><pre>		return outids</pre></div>
<div class="skip"><span class="num"><pre>252</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>	def storagePlug( self, dataID, plugType = None, autoCreate=False ):</pre></div>
<div class="cov"><span class="num"><pre>254</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>		:return: plug of the given type, either as tuple of two plugs or the plug</pre></div>
<div class="cov"><span class="num"><pre>256</pre></span><pre>			specified by plugType</pre></div>
<div class="cov"><span class="num"><pre>257</pre></span><pre>		:param dataID: the name of the plug to be returned</pre></div>
<div class="cov"><span class="num"><pre>258</pre></span><pre>		:param plugType:</pre></div>
<div class="cov"><span class="num"><pre>259</pre></span><pre>			StorageBase.kMessage: return message array plug only</pre></div>
<div class="cov"><span class="num"><pre>260</pre></span><pre>			StorageBase.kValue: return python pickle array plug only</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>			StorageBase.kStorage: return the storage plug itself containing message and the value plug</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>			None: return ( picklePlug , messagePlug )</pre></div>
<div class="cov"><span class="num"><pre>263</pre></span><pre>		:param autoCreate: if True, a plug with the given dataID will be created if it does not</pre></div>
<div class="cov"><span class="num"><pre>264</pre></span><pre>			yet exist</pre></div>
<div class="cov"><span class="num"><pre>265</pre></span><pre>		:raise AttributeError: if a plug with dataID does not exist and default value is None</pre></div>
<div class="cov"><span class="num"><pre>266</pre></span><pre>		:raise TypeError: if  plugtype unknown &quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>		matchedplug = self.findStoragePlug( dataID )</pre></div>
<div class="cov"><span class="num"><pre>268</pre></span><pre>		if matchedplug is None:</pre></div>
<div class="cov"><span class="num"><pre>269</pre></span><pre>			if autoCreate:</pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>				actualID = self._attrprefix + dataID</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>				matchedplug = self.__makePlug( actualID )</pre></div>
<div class="cov"><span class="num"><pre>272</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>273</pre></span><pre>				raise AttributeError( &quot;Plug with id %s not found on %r&quot; % ( dataID, self._node ) )</pre></div>
<div class="skip"><span class="num"><pre>274</pre></span><pre>		# END matched plug not found handling</pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>276</pre></span><pre>		# return the result</pre></div>
<div class="cov"><span class="num"><pre>277</pre></span><pre>		if plugType is None:</pre></div>
<div class="nocov"><span class="num"><pre>278</pre></span><pre>			return ( matchedplug.mchildByName('dval'), matchedplug.mchildByName('dmsg') )</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>		elif plugType == StorageBase.kStorage:</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>			return matchedplug</pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>		elif plugType == StorageBase.kValue:</pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>			return matchedplug.mchildByName('dval')</pre></div>
<div class="cov"><span class="num"><pre>283</pre></span><pre>		elif plugType == StorageBase.kMessage:</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>			return matchedplug.mchildByName('dmsg')</pre></div>
<div class="nocov"><span class="num"><pre>285</pre></span><pre>		else:</pre></div>
<div class="nocov"><span class="num"><pre>286</pre></span><pre>			raise TypeError( &quot;Invalid plugType value: %s&quot; % plugType )</pre></div>
<div class="skip"><span class="num"><pre>287</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>288</pre></span><pre>	#} END query plugs</pre></div>
<div class="skip"><span class="num"><pre>289</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>290</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>291</pre></span><pre>	#{ Query Data</pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>	def pythonData( self, dataID, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>293</pre></span><pre>		&quot;&quot;&quot;:return: PyPickleVal object at the given index ( it can be modified natively )</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>		:param dataID: id of of the data to retrieve</pre></div>
<div class="cov"><span class="num"><pre>295</pre></span><pre>		:param kwargs:</pre></div>
<div class="cov"><span class="num"><pre>296</pre></span><pre>			 * index: </pre></div>
<div class="cov"><span class="num"><pre>297</pre></span><pre>			 	element number of the plug to retrieve, or -1 to get a new plug.</pre></div>
<div class="cov"><span class="num"><pre>298</pre></span><pre>				Plugs will always be created, the given index specifies a logical plug index</pre></div>
<div class="cov"><span class="num"><pre>299</pre></span><pre>			 * Additionally all arguments supported by `storagePlug`</pre></div>
<div class="cov"><span class="num"><pre>300</pre></span><pre>		&quot;&quot;&quot; </pre></div>
<div class="cov"><span class="num"><pre>301</pre></span><pre>		storagePlug = self.storagePlug( dataID, plugType = StorageBase.kStorage, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre>302</pre></span><pre>		valplug = storagePlug.mchildByName('dval')</pre></div>
<div class="cov"><span class="num"><pre>303</pre></span><pre>		return self.pythonDataFromPlug( valplug )</pre></div>
<div class="skip"><span class="num"><pre>304</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>305</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>306</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>307</pre></span><pre>	def pythonDataFromPlug( cls, valplug ):</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>		&quot;&quot;&quot;Exract the python data using the given plug directly</pre></div>
<div class="skip"><span class="num"><pre>309</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>310</pre></span><pre>		:param valplug: data value plug containing the plugin data</pre></div>
<div class="cov"><span class="num"><pre>311</pre></span><pre>		:return: PyPickleData object allowing data access&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>312</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>313</pre></span><pre>		# initialize data if required</pre></div>
<div class="skip"><span class="num"><pre>314</pre></span><pre>		# if the data is null, we do not get a kNullObject, but an exception - fair enough ...</pre></div>
<div class="cov"><span class="num"><pre>315</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>316</pre></span><pre>			plugindata = valplug.masData()</pre></div>
<div class="cov"><span class="num"><pre>317</pre></span><pre>		except RuntimeError:</pre></div>
<div class="skip"><span class="num"><pre>318</pre></span><pre>			# set value</pre></div>
<div class="cov"><span class="num"><pre>319</pre></span><pre>			plugindataobj = api.MFnPluginData( ).create( PyPickleData.kPluginDataId )</pre></div>
<div class="skip"><span class="num"><pre>320</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>321</pre></span><pre>			# data gets copied here - re-retrieve data</pre></div>
<div class="cov"><span class="num"><pre>322</pre></span><pre>			valplug.msetMObject( plugindataobj ) # use original version only - no undo support</pre></div>
<div class="cov"><span class="num"><pre>323</pre></span><pre>			plugindata = Data( plugindataobj )</pre></div>
<div class="skip"><span class="num"><pre>324</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>325</pre></span><pre>		# exstract the data</pre></div>
<div class="skip"><span class="num"><pre>326</pre></span><pre>		#return plugindata.data()</pre></div>
<div class="cov"><span class="num"><pre>327</pre></span><pre>		return StorageBase.PyPickleValue( valplug, plugindata.data( ) )</pre></div>
<div class="skip"><span class="num"><pre>328</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>329</pre></span><pre>	#} END query Data</pre></div>
<div class="skip"><span class="num"><pre>330</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>331</pre></span><pre>	#{ Set Handling</pre></div>
<div class="cov"><span class="num"><pre>332</pre></span><pre>	def objectSet( self, dataID, setIndex, autoCreate = True ):</pre></div>
<div class="cov"><span class="num"><pre>333</pre></span><pre>		&quot;&quot;&quot;Get an object set identified with setIndex at the given dataId</pre></div>
<div class="skip"><span class="num"><pre>334</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>335</pre></span><pre>		:param dataID: id identifying the storage plug on this node</pre></div>
<div class="cov"><span class="num"><pre>336</pre></span><pre>		:param setIndex: logical index at which the set will be connected to our message plug array</pre></div>
<div class="cov"><span class="num"><pre>337</pre></span><pre>		:param autoCreate: if True, a set will be created if it does not yet exist</pre></div>
<div class="cov"><span class="num"><pre>338</pre></span><pre>		:raises ValueError: if a set does not exist at setIndex and autoCreate is False</pre></div>
<div class="cov"><span class="num"><pre>339</pre></span><pre>		:raises AttributeError: if the plug did not exist ( and autocreate is False )</pre></div>
<div class="cov"><span class="num"><pre>340</pre></span><pre>		:note: method is implicitly undoable if autoCreate is True, this also means that you cannot</pre></div>
<div class="cov"><span class="num"><pre>341</pre></span><pre>			explicitly undo this operation as you do not know if undo has been queued or not</pre></div>
<div class="cov"><span class="num"><pre>342</pre></span><pre>		:note: newly created sets will automatically use partitions if one of the sets does&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>343</pre></span><pre>		mp = self.storagePlug( dataID, self.kMessage, autoCreate = autoCreate )</pre></div>
<div class="skip"><span class="num"><pre>344</pre></span><pre>		# array plug having our sets</pre></div>
<div class="cov"><span class="num"><pre>345</pre></span><pre>		setplug = mp.elementByLogicalIndex( setIndex )</pre></div>
<div class="cov"><span class="num"><pre>346</pre></span><pre>		inputplug = setplug.minput()</pre></div>
<div class="cov"><span class="num"><pre>347</pre></span><pre>		if inputplug.isNull():</pre></div>
<div class="cov"><span class="num"><pre>348</pre></span><pre>			if not autoCreate:</pre></div>
<div class="cov"><span class="num"><pre>349</pre></span><pre>				raise AttributeError( &quot;Set at %s[%i] did not exist on %r&quot; % ( self._attrprefix + dataID, setIndex, self ) )</pre></div>
<div class="cov"><span class="num"><pre>350</pre></span><pre>			su = undo.StartUndo()			# make the following operations atomic</pre></div>
<div class="cov"><span class="num"><pre>351</pre></span><pre>			objset = createNode( dataID + &quot;Set&quot;, &quot;objectSet&quot;, forceNewLeaf = True )</pre></div>
<div class="cov"><span class="num"><pre>352</pre></span><pre>			inputplug = objset.message</pre></div>
<div class="cov"><span class="num"><pre>353</pre></span><pre>			inputplug.mconnectTo(setplug)</pre></div>
<div class="skip"><span class="num"><pre>354</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>355</pre></span><pre>			# hook it up to the partition</pre></div>
<div class="cov"><span class="num"><pre>356</pre></span><pre>			if self.partition( dataID ):</pre></div>
<div class="cov"><span class="num"><pre>357</pre></span><pre>				self.setPartition( dataID, True )</pre></div>
<div class="skip"><span class="num"><pre>358</pre></span><pre>		# END create set as needed</pre></div>
<div class="skip"><span class="num"><pre>359</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>360</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>361</pre></span><pre>		# return actual object set</pre></div>
<div class="cov"><span class="num"><pre>362</pre></span><pre>		return inputplug.mwrappedNode()</pre></div>
<div class="skip"><span class="num"><pre>363</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>364</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>365</pre></span><pre>	def deleteObjectSet( self, dataID, setIndex ):</pre></div>
<div class="cov"><span class="num"><pre>366</pre></span><pre>		&quot;&quot;&quot;Delete the object set identified by setIndex</pre></div>
<div class="skip"><span class="num"><pre>367</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>368</pre></span><pre>		:note: the method is implicitly undoable</pre></div>
<div class="cov"><span class="num"><pre>369</pre></span><pre>		:note: use this method to delete your sets instead of manual deletion as it will automatically</pre></div>
<div class="cov"><span class="num"><pre>370</pre></span><pre>			remove the managed partition in case the last set is being deleted&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>371</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre>372</pre></span><pre>			objset = self.objectSet( dataID, setIndex, autoCreate = False )</pre></div>
<div class="nocov"><span class="num"><pre>373</pre></span><pre>		except ( ValueError, AttributeError ):</pre></div>
<div class="skip"><span class="num"><pre>374</pre></span><pre>			# did not exist, its fine</pre></div>
<div class="nocov"><span class="num"><pre>375</pre></span><pre>			return</pre></div>
<div class="cov"><span class="num"><pre>376</pre></span><pre>		else:</pre></div>
<div class="skip"><span class="num"><pre>377</pre></span><pre>			# if this is the last set, remove the partition as well</pre></div>
<div class="cov"><span class="num"><pre>378</pre></span><pre>			if len( self.setsByID( dataID ) ) == 1:</pre></div>
<div class="cov"><span class="num"><pre>379</pre></span><pre>				self.setPartition( dataID, False )</pre></div>
<div class="skip"><span class="num"><pre>380</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>381</pre></span><pre>			delete( objset )</pre></div>
<div class="skip"><span class="num"><pre>382</pre></span><pre>		# END obj set handling</pre></div>
<div class="skip"><span class="num"><pre>383</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>384</pre></span><pre>	def setsByID( self, dataID ):</pre></div>
<div class="cov"><span class="num"><pre>385</pre></span><pre>		&quot;&quot;&quot;:return: all object sets stored under the given dataID&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>386</pre></span><pre>		mp = self.storagePlug( dataID, self.kMessage, autoCreate = False )</pre></div>
<div class="cov"><span class="num"><pre>387</pre></span><pre>		allnodes = [ p.mwrappedNode() for p in mp.minputs() ]</pre></div>
<div class="cov"><span class="num"><pre>388</pre></span><pre>		return [ n for n in allnodes if isinstance( n, ObjectSet ) ]</pre></div>
<div class="skip"><span class="num"><pre>389</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>390</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>391</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>392</pre></span><pre>	def setPartition( self, dataID, state ):</pre></div>
<div class="cov"><span class="num"><pre>393</pre></span><pre>		&quot;&quot;&quot;Make all sets in dataID use a partition or not</pre></div>
<div class="skip"><span class="num"><pre>394</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>395</pre></span><pre>		:param dataID: id identifying the storage plug</pre></div>
<div class="cov"><span class="num"><pre>396</pre></span><pre>		:param state: if True, a partition will be used, if False, it will be disabled</pre></div>
<div class="cov"><span class="num"><pre>397</pre></span><pre>		:note: this method makes sure that all sets are hooked up to the partition</pre></div>
<div class="cov"><span class="num"><pre>398</pre></span><pre>		:raise ValueError: If we did not have a single set to which to add to the partition</pre></div>
<div class="cov"><span class="num"><pre>399</pre></span><pre>		:raise AttributeError: If the dataID has never had sets</pre></div>
<div class="cov"><span class="num"><pre>400</pre></span><pre>		:return: if state is True, the name of the possibly created ( or existing ) partition&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>401</pre></span><pre>		sets = self.setsByID( dataID )</pre></div>
<div class="cov"><span class="num"><pre>402</pre></span><pre>		partition = self.partition( dataID )</pre></div>
<div class="skip"><span class="num"><pre>403</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>404</pre></span><pre>		if state:</pre></div>
<div class="cov"><span class="num"><pre>405</pre></span><pre>			if partition is None:</pre></div>
<div class="cov"><span class="num"><pre>406</pre></span><pre>				if not sets:</pre></div>
<div class="nocov"><span class="num"><pre>407</pre></span><pre>					raise ValueError(&quot;Cannot create partition as data %r did not have any connected sets&quot; % dataID)</pre></div>
<div class="skip"><span class="num"><pre>408</pre></span><pre>				# END check sets exist</pre></div>
<div class="skip"><span class="num"><pre>409</pre></span><pre>				# create partition</pre></div>
<div class="cov"><span class="num"><pre>410</pre></span><pre>				partition = createNode( &quot;storagePartition&quot;, &quot;partition&quot;, forceNewLeaf=True )</pre></div>
<div class="skip"><span class="num"><pre>411</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>412</pre></span><pre>				tattr = api.MFnTypedAttribute( )</pre></div>
<div class="cov"><span class="num"><pre>413</pre></span><pre>				attr = tattr.create( self._partitionIdAttr, &quot;pid&quot;, api.MFnData.kString )</pre></div>
<div class="cov"><span class="num"><pre>414</pre></span><pre>				partition.addAttribute( attr )</pre></div>
<div class="skip"><span class="num"><pre>415</pre></span><pre>			# END create partition</pre></div>
<div class="skip"><span class="num"><pre>416</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>417</pre></span><pre>			# make sure all sets are members of our partition</pre></div>
<div class="cov"><span class="num"><pre>418</pre></span><pre>			partition.addSets( sets )</pre></div>
<div class="cov"><span class="num"><pre>419</pre></span><pre>			return partition</pre></div>
<div class="cov"><span class="num"><pre>420</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>421</pre></span><pre>			if partition:</pre></div>
<div class="skip"><span class="num"><pre>422</pre></span><pre>				# delete partition</pre></div>
<div class="skip"><span class="num"><pre>423</pre></span><pre>				# have to clear partition as, for some reason, or own node will be killed as well !</pre></div>
<div class="cov"><span class="num"><pre>424</pre></span><pre>				partition.clear()</pre></div>
<div class="cov"><span class="num"><pre>425</pre></span><pre>				delete( partition )</pre></div>
<div class="skip"><span class="num"><pre>426</pre></span><pre>		# END state check</pre></div>
<div class="skip"><span class="num"><pre>427</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>428</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>429</pre></span><pre>	def partition( self, dataID ):</pre></div>
<div class="cov"><span class="num"><pre>430</pre></span><pre>		&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>431</pre></span><pre>		:return: partition Node attached to the sets at dataID or None if state</pre></div>
<div class="cov"><span class="num"><pre>432</pre></span><pre>			is disabled&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>433</pre></span><pre>		sets = self.setsByID( dataID )</pre></div>
<div class="skip"><span class="num"><pre>434</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>435</pre></span><pre>		# get the dominant partition</pre></div>
<div class="cov"><span class="num"><pre>436</pre></span><pre>		partitions = []</pre></div>
<div class="cov"><span class="num"><pre>437</pre></span><pre>		for s in sets:</pre></div>
<div class="cov"><span class="num"><pre>438</pre></span><pre>			partitions.extend( s.partitions() )</pre></div>
<div class="skip"><span class="num"><pre>439</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>440</pre></span><pre>		for p in partitions:</pre></div>
<div class="cov"><span class="num"><pre>441</pre></span><pre>			if hasattr( p, self._partitionIdAttr ):</pre></div>
<div class="cov"><span class="num"><pre>442</pre></span><pre>				return p</pre></div>
<div class="skip"><span class="num"><pre>443</pre></span><pre>		# END for each partition</pre></div>
<div class="skip"><span class="num"><pre>444</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>445</pre></span><pre>		# nothing found, there is no partition yet</pre></div>
<div class="cov"><span class="num"><pre>446</pre></span><pre>		return None</pre></div>
<div class="skip"><span class="num"><pre>447</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>448</pre></span><pre>	#} END set handling</pre></div>
<div class="skip"><span class="num"><pre>449</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>450</pre></span><pre>	# Query General</pre></div>
<div class="skip"><span class="num"><pre>451</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>452</pre></span><pre>	def storageNode( self ):</pre></div>
<div class="cov"><span class="num"><pre>453</pre></span><pre>		&quot;&quot;&quot;:return: Node actually being used as storage&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>454</pre></span><pre>		return self._node</pre></div>
<div class="skip"><span class="num"><pre>455</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>456</pre></span><pre>	def setStorageNode( self, node ):</pre></div>
<div class="cov"><span class="num"><pre>457</pre></span><pre>		&quot;&quot;&quot;Set ourselves to use the given storage compatible node</pre></div>
<div class="skip"><span class="num"><pre>458</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>459</pre></span><pre>		:note: use this if the path of our instance has changed - otherwise</pre></div>
<div class="cov"><span class="num"><pre>460</pre></span><pre>			trying to access functions will fail as the path of our node might be invalid&quot;&quot;&quot;</pre></div>
<div class="nocov"><span class="num"><pre>461</pre></span><pre>		self._node = node</pre></div>
<div class="skip"><span class="num"><pre>462</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>463</pre></span><pre>	def attributePrefix( self ):</pre></div>
<div class="cov"><span class="num"><pre>464</pre></span><pre>		&quot;&quot;&quot;:return: our attribute prefix</pre></div>
<div class="cov"><span class="num"><pre>465</pre></span><pre>		:note: it is read-only to assure we will never 'forget' about our data&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>466</pre></span><pre>		return self._attrprefix</pre></div>
<div class="skip"><span class="num"><pre>467</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>468</pre></span><pre>	# END query general</pre></div>
<div class="skip"><span class="num"><pre>469</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>470</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>471</pre></span><pre>class StorageNode( DependNode, StorageBase ):</pre></div>
<div class="cov"><span class="num"><pre>472</pre></span><pre>	&quot;&quot;&quot;This node can be used as pythonic and easy-to-access value container - it could</pre></div>
<div class="cov"><span class="num"><pre>473</pre></span><pre>	be connected to your node, and queried for values actually being queried on your node.</pre></div>
<div class="cov"><span class="num"><pre>474</pre></span><pre>	As value container, it can easily be replaced by another one, or keep different sets of information</pre></div>
<div class="skip"><span class="num"><pre>475</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>476</pre></span><pre>	:note: the storage node can only use generic attributes and recover them properly during scene reload</pre></div>
<div class="cov"><span class="num"><pre>477</pre></span><pre>		if the configuration of the generic attributes have been setup properly - they are unique only per</pre></div>
<div class="cov"><span class="num"><pre>478</pre></span><pre>		node type, not per instance of the node type.</pre></div>
<div class="cov"><span class="num"><pre>479</pre></span><pre>		Thus it is recommened to use the storage node attribute base on your own custom type that setsup the</pre></div>
<div class="cov"><span class="num"><pre>480</pre></span><pre>		generic attributes as it requires during plugin load&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>481</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>482</pre></span><pre>	#{ Overrriden Methods</pre></div>
<div class="cov"><span class="num"><pre>483</pre></span><pre>	def __init__( self, *args ):</pre></div>
<div class="cov"><span class="num"><pre>484</pre></span><pre>		&quot;&quot;&quot;initialize bases properly&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>485</pre></span><pre>		DependNode.__init__( self )</pre></div>
<div class="cov"><span class="num"><pre>486</pre></span><pre>		StorageBase.__init__( self )</pre></div>
<div class="skip"><span class="num"><pre>487</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>488</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>489</pre></span><pre>	#} END overridden methods</pre></div>
<div class="skip"><span class="num"><pre>490</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre>491</pre></span><pre>#} END storage access</pre></div>
<div class="skip"><span class="num"><pre>492</pre></span><pre></pre></div>
</div>
</body>
</html>
