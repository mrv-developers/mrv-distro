<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mrv.maya.nt.geometry &mdash; mrv v1.0.2-develop documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.2-develop',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="mrv v1.0.2-develop documentation" href="../index.html" />
    <link rel="next" title="mrv.automation.process" href="mrv.automation.process.html" />
    <link rel="prev" title="mrv.maya.nt.storage" href="mrv.maya.nt.storage.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="mrv.automation.process.html" title="mrv.automation.process"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mrv.maya.nt.storage.html" title="mrv.maya.nt.storage"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">mrv v1.0.2-develop documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-mrv.maya.nt.geometry">
<h1><tt class="xref docutils literal"><span class="pre">mrv.maya.nt.geometry</span></tt><a class="headerlink" href="#module-mrv.maya.nt.geometry" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="api/mrv.maya.nt.geometry-module.html">Epydoc: mrv.maya.nt.geometry</a></p>
<p>Contains implementations ( or improvements ) to mayas geometric shapes</p>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="api/mrv.maya.nt.geometry.ControlPoint-class.html">Epydoc: mrv.maya.nt.geometry.ControlPoint</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry.ControlPoint">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">ControlPoint</tt><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.DeformableShape</span></tt></p>
<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.addChild">
<tt class="descname">addChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.addChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given childNode as child to this Node. Allows instancing !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node you wish to add</li>
<li><em>position</em> &#8211; the index to which to add the new child, kNextPos will add it as last child.
It supports python style negative indices</li>
<li><em>keepExistingParent</em> &#8211; if True, the childNode will be instanced as it will
have its previous parent(s) and this one, if False, the previous parent will be removed
from the child&#8217;s parent list</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>keepWorldSpace</em> &#8211; see <cite>reparent</cite>, only effective if the node is not instanced</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">childNode whose path is pointing to the new child location</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if keepWorldSpace is requested with directly instanced nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">as maya internally handles add/remove child as instancing operation, even though
keepExistingParent is False, it will mess up things and for a short period of time in fact
have two n + 1 instances, right before one is unlinked, This still fills a slot or something, and
isInstanced will be true, although the pathcount is 1.
Long story short: if the item to be added to us is not instanced, we use reparent instead. It
will not harm in direct instances, so its save to use.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if the instance count of the item is 1 and keepExistingParent is False, the position
argument is being ignored</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.addInstancedChild">
<tt class="descname">addInstancedChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.addInstancedChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add childnode as instanced child to this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for more information, see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">its a shortcut to addChild allowing to clearly indicate what is happening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.addParent">
<tt class="descname">addParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.addParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds ourselves as instance to the given parentnode at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.ControlPoint.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x44cffb0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our dag path as this is our api object - the object defining this node best</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.child">
<tt class="descname">child</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.child" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">child of self at index</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method fixes the MFnDagNode.child method - it returns an MObject,
which doesnt work well with instanced nodes - a dag path is required, which is what
we use to aquire the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.childTransforms">
<tt class="descname">childTransforms</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dde8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.childTransforms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all transform nodes below this one</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479db18&gt;</em>, <em>asNode=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all child nodes below this dag node if predicate returns True for passed Node</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>asNode</em> &#8211; if True, you will receive the children as wrapped Nodes, otherwise you 
get MDagPaths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.childrenByType">
<tt class="descname">childrenByType</tt><big>(</big><em>nodeType</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x479dc08&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.childrenByType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all childnodes below this one matching the given nodeType and the predicate</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>nodeType</em> &#8211; class of the nodeTyoe, like nt.Transform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.componentAssignments">
<tt class="descname">componentAssignments</tt><big>(</big><em>setFilter=(319</em>, <em>False</em>, <em>0)</em>, <em>use_api=True</em>, <em>asComponent=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.componentAssignments" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of tuples(ObjectSetNode, Component_or_MObject) defininmg shader
assignments on per component basis.</p>
<p>If a shader is assigned to the whole object, the component would be a null object, otherwise
it is an instance of a wrapped IndexedComponent class</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">The returned Component will be an MObject(kNullObject) only in case the component is 
not set. Hence you should check whether it isNull() before actually using it.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>setFilter</em> &#8211; see <cite>connectedSets</cite></li>
<li><em>use_api</em> &#8211; if True, api methods will be used if possible which is usually faster.
If False, a custom non-api implementation will be used instead.
This can be required if the apiImplementation is not reliable which happens in
few cases of &#8216;weird&#8217; component assignments</li>
<li><em>asComponent</em> &#8211; If True, the components will be wrapped into the matching MRV compontent type
to provide a nicer interface. This might slightly slow down the process, but this is usually 
neglectable.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the sets order will be the order of connections of the respective component list
attributes at instObjGroups.objectGroups</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">currently only meshes and subdees support per component assignment, whereas only
meshes can have per component shader assignments</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">SubDivision Components cannot be supported as the component type kSubdivCVComponent
cannot be wrapped into any component function set - reevaluate that with new maya versions !</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">deformer set component assignments are only returned for instance 0 ! They apply to all
output meshes though</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.copyLightLinks">
<tt class="descname">copyLightLinks</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.copyLightLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy lightlinks from one meshShape to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>substitute: </dt>
<dd>if True, default False, the other shape will be put
in place of self, effectively receiving it&#8217;s light-links whereas self losses
them. This is practical in case you create a new shape below a transform that
had a previously visible and manipulated shape whose external connections you
wouuld like to keep</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.dagPath">
<tt class="descname">dagPath</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.dagPath" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the original DagPath attached to this Node - it&#8217;s not wrapped
for performance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If you plan to alter it, make sure you copy it using the 
MDagPath(node.dagPath()) construct !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node - this special version must be</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.displayOverrideValue">
<tt class="descname">displayOverrideValue</tt><big>(</big><em>plugName</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.displayOverrideValue" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the override display value actually identified by plugName affecting
the given object (that should be a leaf node for the result you see in the viewport.
The display type in effect is always the last one set in the hierarchy
returns None display overrides are disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplciate the given node to newpath</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newpath</em> &#8211; <p>result depends on its format:</p>
<ul>
<li>&#8216;&#8217; - empty string, creates a unique name based on the actual node name by appending a copy number
to it, if newTransform is True, the newly created shape/transform will keep its name, but receives a new parent</li>
<li>&#8216;newname&#8217; - relative path, the node will be duplicated not changing its current parent if newTransform is False</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">|parent|newname</span></tt> - absolute path, the node will be duplicated and reparented under the given path</dt>
<dd>if newTransform is True, a new transform name will be created based on your name by appending a unique copy number</dd>
</dl>
</li>
</ul>
</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
<li><em>newTransform</em> &#8211; if True, a new transform will be created based on the name of the parent transform
of this shape node, appending a unique copy number to it.
Only has an effect for shape nodes</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">newly create Node</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">duplicate performance could be improved by checking more before doing work that does not
really change the scene, but adds undo operations</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">inbetween parents are always required as needed</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">add example for each version of newpath</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">instancing can be realized using the <cite>addChild</cite> function</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">If meshes have tweaks applied, the duplicate will not have these tweaks and the meshes will look
mislocated.
Using MEL works in that case ... (they fixed it there obviously) , but creates invalid objects</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">Undo implementation - every undoable operation must in fact be based on strings to really work, all
this is far too much - dagNode.duplicate must be undoable by itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first last">duplicate should be completely reimplemented to support all mel options and actually work with
meshes and tweaks - the underlying api duplication would still be used of course, as well as
connections (to sets) and so on ...</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.ControlPoint.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.hasChild">
<tt class="descname">hasChild</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.hasChild" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if node is a child of self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.instance">
<tt class="descname">instance</tt><big>(</big><em>instanceNumber</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.instance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to the instance identified by instanceNumber</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>instanceNumber</em> &#8211; range(0, self.instanceCount()-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.instanceNumber">
<tt class="descname">instanceNumber</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.instanceNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our instance number</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">0 does not indicate that this object is not instanced - use getInstanceCount instead</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x442aea0&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isTemplate">
<tt class="descname">isTemplate</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isTemplate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is templated - this is the case if itself or one of its
parents are templated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Handles DAG objects correctly that can be instanced, in which case
the MObject may be valid , but the respective dag path is not.
Additionally, if the object is not parented below any object, everything appears
to be valid, but the path name is empty</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.isVisible">
<tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is visible - its visible if itself and all parents are
visible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.iterInstances">
<tt class="descname">iterInstances</tt><big>(</big><em>excludeSelf=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.iterInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get iterator over all (direct and indirect)instances of this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>excludeSelf</em> &#8211; if True, self will not be returned, if False, it will be in
the list of items</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Iterating instances is more efficient than querying all instances individually using
<cite>instance</cite></td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">add flag to allow iteration of indirect instances as well</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">fully qualified (long) name of this dag node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MObject as retrieved from the MDagPath of our Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maya node of the parent of this instance or None if this is the root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.parentAtIndex">
<tt class="descname">parentAtIndex</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.parentAtIndex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node of the parent at the given index - non-instanced nodes only have one parent</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if a node is instanced, it can have <cite>parentCount</cite> parents</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">Update dagpath afterwards ! Use dagpaths instead !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.removeChild">
<tt class="descname">removeChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.removeChild" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given childNode (being a child of this node) from our child list, effectively
parenting it under world !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node to unparent - if it is not one of our children, no change takes place</li>
<li><em>allowZeroParents</em> &#8211; if True, it is possible to leave a node unparented, thus no valid
dag paths leads to it. If False, transforms will just be reparented under the world</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">copy of childnode pointing to the first valid dag path we find.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">to prevent the child (if transform) to dangle in unknown space if the last instance
is to be removed, it will instead be reparented to world.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">removing shapes from their last parent will result in an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x456f830&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.removeParent">
<tt class="descname">removeParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.removeParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove ourselves from given parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.reparent">
<tt class="descname">reparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.reparent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of all nodes (also instances) to be located below parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>parentnode</em> &#8211; Node instance of transform under which this node should be parented to
if None, node will be reparented under the root (which only works for transforms)</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>raiseOnInstance</em> &#8211; if True, this method will raise if you try to reparent an instanced object.
If false, instanced objects will be merged into the newly created path under parentnode, effectively
eliminating all other paths , keeping the newly created one</li>
<li><em>keepWorldSpace</em> &#8211; if True and node to be reparented is a transform, the world space position
will be kept by adjusting the transformation accordingly.
<strong>WARNNG</strong>: Currently we reset pivots when doing so</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return : copy of self pointing to the new dag path self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will remove all instance of this object and leave this object at only one path -
if this is not what you want, use the addChild method instead as it can properly handle this case</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method handles namespaces properly</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.setParent">
<tt class="descname">setParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.setParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of self to parentnode being placed at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.shapes">
<tt class="descname">shapes</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dcf8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.shapes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all our Shape nodes</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you could use getChildren with a predicate, but this method is more
efficient as it uses dagpath functions to filter shapes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.transform">
<tt class="descname">transform</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to lowest transform in the path attached to our node</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for shapes this is the parent, for transforms the transform itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.ControlPoint.unparent">
<tt class="descname">unparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.ControlPoint.unparent" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>reparent</cite>, but will unparent this transform under the scene root</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry.DeformableShape-class.html">Epydoc: mrv.maya.nt.geometry.DeformableShape</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry.DeformableShape">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">DeformableShape</tt><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.GeometryShape</span></tt></p>
<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.addChild">
<tt class="descname">addChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.addChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given childNode as child to this Node. Allows instancing !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node you wish to add</li>
<li><em>position</em> &#8211; the index to which to add the new child, kNextPos will add it as last child.
It supports python style negative indices</li>
<li><em>keepExistingParent</em> &#8211; if True, the childNode will be instanced as it will
have its previous parent(s) and this one, if False, the previous parent will be removed
from the child&#8217;s parent list</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>keepWorldSpace</em> &#8211; see <cite>reparent</cite>, only effective if the node is not instanced</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">childNode whose path is pointing to the new child location</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if keepWorldSpace is requested with directly instanced nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">as maya internally handles add/remove child as instancing operation, even though
keepExistingParent is False, it will mess up things and for a short period of time in fact
have two n + 1 instances, right before one is unlinked, This still fills a slot or something, and
isInstanced will be true, although the pathcount is 1.
Long story short: if the item to be added to us is not instanced, we use reparent instead. It
will not harm in direct instances, so its save to use.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if the instance count of the item is 1 and keepExistingParent is False, the position
argument is being ignored</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.addInstancedChild">
<tt class="descname">addInstancedChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.addInstancedChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add childnode as instanced child to this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for more information, see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">its a shortcut to addChild allowing to clearly indicate what is happening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.addParent">
<tt class="descname">addParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.addParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds ourselves as instance to the given parentnode at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.DeformableShape.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x44cffb0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our dag path as this is our api object - the object defining this node best</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.child">
<tt class="descname">child</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.child" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">child of self at index</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method fixes the MFnDagNode.child method - it returns an MObject,
which doesnt work well with instanced nodes - a dag path is required, which is what
we use to aquire the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.childTransforms">
<tt class="descname">childTransforms</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dde8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.childTransforms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all transform nodes below this one</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479db18&gt;</em>, <em>asNode=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all child nodes below this dag node if predicate returns True for passed Node</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>asNode</em> &#8211; if True, you will receive the children as wrapped Nodes, otherwise you 
get MDagPaths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.childrenByType">
<tt class="descname">childrenByType</tt><big>(</big><em>nodeType</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x479dc08&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.childrenByType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all childnodes below this one matching the given nodeType and the predicate</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>nodeType</em> &#8211; class of the nodeTyoe, like nt.Transform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.componentAssignments">
<tt class="descname">componentAssignments</tt><big>(</big><em>setFilter=(319</em>, <em>False</em>, <em>0)</em>, <em>use_api=True</em>, <em>asComponent=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.componentAssignments" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of tuples(ObjectSetNode, Component_or_MObject) defininmg shader
assignments on per component basis.</p>
<p>If a shader is assigned to the whole object, the component would be a null object, otherwise
it is an instance of a wrapped IndexedComponent class</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">The returned Component will be an MObject(kNullObject) only in case the component is 
not set. Hence you should check whether it isNull() before actually using it.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>setFilter</em> &#8211; see <cite>connectedSets</cite></li>
<li><em>use_api</em> &#8211; if True, api methods will be used if possible which is usually faster.
If False, a custom non-api implementation will be used instead.
This can be required if the apiImplementation is not reliable which happens in
few cases of &#8216;weird&#8217; component assignments</li>
<li><em>asComponent</em> &#8211; If True, the components will be wrapped into the matching MRV compontent type
to provide a nicer interface. This might slightly slow down the process, but this is usually 
neglectable.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the sets order will be the order of connections of the respective component list
attributes at instObjGroups.objectGroups</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">currently only meshes and subdees support per component assignment, whereas only
meshes can have per component shader assignments</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">SubDivision Components cannot be supported as the component type kSubdivCVComponent
cannot be wrapped into any component function set - reevaluate that with new maya versions !</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">deformer set component assignments are only returned for instance 0 ! They apply to all
output meshes though</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.copyLightLinks">
<tt class="descname">copyLightLinks</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.copyLightLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy lightlinks from one meshShape to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>substitute: </dt>
<dd>if True, default False, the other shape will be put
in place of self, effectively receiving it&#8217;s light-links whereas self losses
them. This is practical in case you create a new shape below a transform that
had a previously visible and manipulated shape whose external connections you
wouuld like to keep</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.dagPath">
<tt class="descname">dagPath</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.dagPath" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the original DagPath attached to this Node - it&#8217;s not wrapped
for performance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If you plan to alter it, make sure you copy it using the 
MDagPath(node.dagPath()) construct !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node - this special version must be</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.displayOverrideValue">
<tt class="descname">displayOverrideValue</tt><big>(</big><em>plugName</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.displayOverrideValue" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the override display value actually identified by plugName affecting
the given object (that should be a leaf node for the result you see in the viewport.
The display type in effect is always the last one set in the hierarchy
returns None display overrides are disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplciate the given node to newpath</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newpath</em> &#8211; <p>result depends on its format:</p>
<ul>
<li>&#8216;&#8217; - empty string, creates a unique name based on the actual node name by appending a copy number
to it, if newTransform is True, the newly created shape/transform will keep its name, but receives a new parent</li>
<li>&#8216;newname&#8217; - relative path, the node will be duplicated not changing its current parent if newTransform is False</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">|parent|newname</span></tt> - absolute path, the node will be duplicated and reparented under the given path</dt>
<dd>if newTransform is True, a new transform name will be created based on your name by appending a unique copy number</dd>
</dl>
</li>
</ul>
</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
<li><em>newTransform</em> &#8211; if True, a new transform will be created based on the name of the parent transform
of this shape node, appending a unique copy number to it.
Only has an effect for shape nodes</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">newly create Node</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">duplicate performance could be improved by checking more before doing work that does not
really change the scene, but adds undo operations</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">inbetween parents are always required as needed</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">add example for each version of newpath</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">instancing can be realized using the <cite>addChild</cite> function</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">If meshes have tweaks applied, the duplicate will not have these tweaks and the meshes will look
mislocated.
Using MEL works in that case ... (they fixed it there obviously) , but creates invalid objects</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">Undo implementation - every undoable operation must in fact be based on strings to really work, all
this is far too much - dagNode.duplicate must be undoable by itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first last">duplicate should be completely reimplemented to support all mel options and actually work with
meshes and tweaks - the underlying api duplication would still be used of course, as well as
connections (to sets) and so on ...</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.DeformableShape.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.hasChild">
<tt class="descname">hasChild</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.hasChild" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if node is a child of self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.instance">
<tt class="descname">instance</tt><big>(</big><em>instanceNumber</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.instance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to the instance identified by instanceNumber</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>instanceNumber</em> &#8211; range(0, self.instanceCount()-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.instanceNumber">
<tt class="descname">instanceNumber</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.instanceNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our instance number</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">0 does not indicate that this object is not instanced - use getInstanceCount instead</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x442aea0&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isTemplate">
<tt class="descname">isTemplate</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isTemplate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is templated - this is the case if itself or one of its
parents are templated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Handles DAG objects correctly that can be instanced, in which case
the MObject may be valid , but the respective dag path is not.
Additionally, if the object is not parented below any object, everything appears
to be valid, but the path name is empty</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.isVisible">
<tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is visible - its visible if itself and all parents are
visible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.iterInstances">
<tt class="descname">iterInstances</tt><big>(</big><em>excludeSelf=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.iterInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get iterator over all (direct and indirect)instances of this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>excludeSelf</em> &#8211; if True, self will not be returned, if False, it will be in
the list of items</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Iterating instances is more efficient than querying all instances individually using
<cite>instance</cite></td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">add flag to allow iteration of indirect instances as well</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">fully qualified (long) name of this dag node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MObject as retrieved from the MDagPath of our Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maya node of the parent of this instance or None if this is the root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.parentAtIndex">
<tt class="descname">parentAtIndex</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.parentAtIndex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node of the parent at the given index - non-instanced nodes only have one parent</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if a node is instanced, it can have <cite>parentCount</cite> parents</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">Update dagpath afterwards ! Use dagpaths instead !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.removeChild">
<tt class="descname">removeChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.removeChild" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given childNode (being a child of this node) from our child list, effectively
parenting it under world !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node to unparent - if it is not one of our children, no change takes place</li>
<li><em>allowZeroParents</em> &#8211; if True, it is possible to leave a node unparented, thus no valid
dag paths leads to it. If False, transforms will just be reparented under the world</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">copy of childnode pointing to the first valid dag path we find.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">to prevent the child (if transform) to dangle in unknown space if the last instance
is to be removed, it will instead be reparented to world.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">removing shapes from their last parent will result in an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x456f830&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.removeParent">
<tt class="descname">removeParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.removeParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove ourselves from given parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.reparent">
<tt class="descname">reparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.reparent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of all nodes (also instances) to be located below parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>parentnode</em> &#8211; Node instance of transform under which this node should be parented to
if None, node will be reparented under the root (which only works for transforms)</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>raiseOnInstance</em> &#8211; if True, this method will raise if you try to reparent an instanced object.
If false, instanced objects will be merged into the newly created path under parentnode, effectively
eliminating all other paths , keeping the newly created one</li>
<li><em>keepWorldSpace</em> &#8211; if True and node to be reparented is a transform, the world space position
will be kept by adjusting the transformation accordingly.
<strong>WARNNG</strong>: Currently we reset pivots when doing so</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return : copy of self pointing to the new dag path self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will remove all instance of this object and leave this object at only one path -
if this is not what you want, use the addChild method instead as it can properly handle this case</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method handles namespaces properly</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.setParent">
<tt class="descname">setParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.setParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of self to parentnode being placed at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.shapes">
<tt class="descname">shapes</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dcf8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.shapes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all our Shape nodes</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you could use getChildren with a predicate, but this method is more
efficient as it uses dagpath functions to filter shapes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.transform">
<tt class="descname">transform</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to lowest transform in the path attached to our node</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for shapes this is the parent, for transforms the transform itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.DeformableShape.unparent">
<tt class="descname">unparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.DeformableShape.unparent" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>reparent</cite>, but will unparent this transform under the scene root</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry.GeometryShape-class.html">Epydoc: mrv.maya.nt.geometry.GeometryShape</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry.GeometryShape">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">GeometryShape</tt><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.Shape</span></tt></p>
<p>Contains common methods for all geometry types</p>
<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.addChild">
<tt class="descname">addChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.addChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given childNode as child to this Node. Allows instancing !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node you wish to add</li>
<li><em>position</em> &#8211; the index to which to add the new child, kNextPos will add it as last child.
It supports python style negative indices</li>
<li><em>keepExistingParent</em> &#8211; if True, the childNode will be instanced as it will
have its previous parent(s) and this one, if False, the previous parent will be removed
from the child&#8217;s parent list</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>keepWorldSpace</em> &#8211; see <cite>reparent</cite>, only effective if the node is not instanced</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">childNode whose path is pointing to the new child location</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if keepWorldSpace is requested with directly instanced nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">as maya internally handles add/remove child as instancing operation, even though
keepExistingParent is False, it will mess up things and for a short period of time in fact
have two n + 1 instances, right before one is unlinked, This still fills a slot or something, and
isInstanced will be true, although the pathcount is 1.
Long story short: if the item to be added to us is not instanced, we use reparent instead. It
will not harm in direct instances, so its save to use.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if the instance count of the item is 1 and keepExistingParent is False, the position
argument is being ignored</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.addInstancedChild">
<tt class="descname">addInstancedChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.addInstancedChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add childnode as instanced child to this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for more information, see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">its a shortcut to addChild allowing to clearly indicate what is happening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.addParent">
<tt class="descname">addParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.addParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds ourselves as instance to the given parentnode at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.GeometryShape.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x44cffb0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our dag path as this is our api object - the object defining this node best</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.child">
<tt class="descname">child</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.child" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">child of self at index</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method fixes the MFnDagNode.child method - it returns an MObject,
which doesnt work well with instanced nodes - a dag path is required, which is what
we use to aquire the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.childTransforms">
<tt class="descname">childTransforms</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dde8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.childTransforms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all transform nodes below this one</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479db18&gt;</em>, <em>asNode=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all child nodes below this dag node if predicate returns True for passed Node</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>asNode</em> &#8211; if True, you will receive the children as wrapped Nodes, otherwise you 
get MDagPaths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.childrenByType">
<tt class="descname">childrenByType</tt><big>(</big><em>nodeType</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x479dc08&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.childrenByType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all childnodes below this one matching the given nodeType and the predicate</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>nodeType</em> &#8211; class of the nodeTyoe, like nt.Transform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.componentAssignments">
<tt class="descname">componentAssignments</tt><big>(</big><em>setFilter=(319</em>, <em>False</em>, <em>0)</em>, <em>use_api=True</em>, <em>asComponent=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.componentAssignments" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of tuples(ObjectSetNode, Component_or_MObject) defininmg shader
assignments on per component basis.</p>
<p>If a shader is assigned to the whole object, the component would be a null object, otherwise
it is an instance of a wrapped IndexedComponent class</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">The returned Component will be an MObject(kNullObject) only in case the component is 
not set. Hence you should check whether it isNull() before actually using it.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>setFilter</em> &#8211; see <cite>connectedSets</cite></li>
<li><em>use_api</em> &#8211; if True, api methods will be used if possible which is usually faster.
If False, a custom non-api implementation will be used instead.
This can be required if the apiImplementation is not reliable which happens in
few cases of &#8216;weird&#8217; component assignments</li>
<li><em>asComponent</em> &#8211; If True, the components will be wrapped into the matching MRV compontent type
to provide a nicer interface. This might slightly slow down the process, but this is usually 
neglectable.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the sets order will be the order of connections of the respective component list
attributes at instObjGroups.objectGroups</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">currently only meshes and subdees support per component assignment, whereas only
meshes can have per component shader assignments</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">SubDivision Components cannot be supported as the component type kSubdivCVComponent
cannot be wrapped into any component function set - reevaluate that with new maya versions !</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">deformer set component assignments are only returned for instance 0 ! They apply to all
output meshes though</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.copyLightLinks">
<tt class="descname">copyLightLinks</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.copyLightLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy lightlinks from one meshShape to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>substitute: </dt>
<dd>if True, default False, the other shape will be put
in place of self, effectively receiving it&#8217;s light-links whereas self losses
them. This is practical in case you create a new shape below a transform that
had a previously visible and manipulated shape whose external connections you
wouuld like to keep</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.dagPath">
<tt class="descname">dagPath</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.dagPath" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the original DagPath attached to this Node - it&#8217;s not wrapped
for performance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If you plan to alter it, make sure you copy it using the 
MDagPath(node.dagPath()) construct !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node - this special version must be</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.displayOverrideValue">
<tt class="descname">displayOverrideValue</tt><big>(</big><em>plugName</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.displayOverrideValue" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the override display value actually identified by plugName affecting
the given object (that should be a leaf node for the result you see in the viewport.
The display type in effect is always the last one set in the hierarchy
returns None display overrides are disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplciate the given node to newpath</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newpath</em> &#8211; <p>result depends on its format:</p>
<ul>
<li>&#8216;&#8217; - empty string, creates a unique name based on the actual node name by appending a copy number
to it, if newTransform is True, the newly created shape/transform will keep its name, but receives a new parent</li>
<li>&#8216;newname&#8217; - relative path, the node will be duplicated not changing its current parent if newTransform is False</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">|parent|newname</span></tt> - absolute path, the node will be duplicated and reparented under the given path</dt>
<dd>if newTransform is True, a new transform name will be created based on your name by appending a unique copy number</dd>
</dl>
</li>
</ul>
</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
<li><em>newTransform</em> &#8211; if True, a new transform will be created based on the name of the parent transform
of this shape node, appending a unique copy number to it.
Only has an effect for shape nodes</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">newly create Node</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">duplicate performance could be improved by checking more before doing work that does not
really change the scene, but adds undo operations</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">inbetween parents are always required as needed</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">add example for each version of newpath</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">instancing can be realized using the <cite>addChild</cite> function</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">If meshes have tweaks applied, the duplicate will not have these tweaks and the meshes will look
mislocated.
Using MEL works in that case ... (they fixed it there obviously) , but creates invalid objects</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">Undo implementation - every undoable operation must in fact be based on strings to really work, all
this is far too much - dagNode.duplicate must be undoable by itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first last">duplicate should be completely reimplemented to support all mel options and actually work with
meshes and tweaks - the underlying api duplication would still be used of course, as well as
connections (to sets) and so on ...</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.GeometryShape.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.hasChild">
<tt class="descname">hasChild</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.hasChild" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if node is a child of self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.instance">
<tt class="descname">instance</tt><big>(</big><em>instanceNumber</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.instance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to the instance identified by instanceNumber</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>instanceNumber</em> &#8211; range(0, self.instanceCount()-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.instanceNumber">
<tt class="descname">instanceNumber</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.instanceNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our instance number</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">0 does not indicate that this object is not instanced - use getInstanceCount instead</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x442aea0&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isTemplate">
<tt class="descname">isTemplate</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isTemplate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is templated - this is the case if itself or one of its
parents are templated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Handles DAG objects correctly that can be instanced, in which case
the MObject may be valid , but the respective dag path is not.
Additionally, if the object is not parented below any object, everything appears
to be valid, but the path name is empty</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.isVisible">
<tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is visible - its visible if itself and all parents are
visible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.iterInstances">
<tt class="descname">iterInstances</tt><big>(</big><em>excludeSelf=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.iterInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get iterator over all (direct and indirect)instances of this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>excludeSelf</em> &#8211; if True, self will not be returned, if False, it will be in
the list of items</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Iterating instances is more efficient than querying all instances individually using
<cite>instance</cite></td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">add flag to allow iteration of indirect instances as well</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">fully qualified (long) name of this dag node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MObject as retrieved from the MDagPath of our Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maya node of the parent of this instance or None if this is the root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.parentAtIndex">
<tt class="descname">parentAtIndex</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.parentAtIndex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node of the parent at the given index - non-instanced nodes only have one parent</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if a node is instanced, it can have <cite>parentCount</cite> parents</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">Update dagpath afterwards ! Use dagpaths instead !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.removeChild">
<tt class="descname">removeChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.removeChild" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given childNode (being a child of this node) from our child list, effectively
parenting it under world !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node to unparent - if it is not one of our children, no change takes place</li>
<li><em>allowZeroParents</em> &#8211; if True, it is possible to leave a node unparented, thus no valid
dag paths leads to it. If False, transforms will just be reparented under the world</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">copy of childnode pointing to the first valid dag path we find.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">to prevent the child (if transform) to dangle in unknown space if the last instance
is to be removed, it will instead be reparented to world.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">removing shapes from their last parent will result in an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x456f830&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.removeParent">
<tt class="descname">removeParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.removeParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove ourselves from given parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.reparent">
<tt class="descname">reparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.reparent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of all nodes (also instances) to be located below parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>parentnode</em> &#8211; Node instance of transform under which this node should be parented to
if None, node will be reparented under the root (which only works for transforms)</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>raiseOnInstance</em> &#8211; if True, this method will raise if you try to reparent an instanced object.
If false, instanced objects will be merged into the newly created path under parentnode, effectively
eliminating all other paths , keeping the newly created one</li>
<li><em>keepWorldSpace</em> &#8211; if True and node to be reparented is a transform, the world space position
will be kept by adjusting the transformation accordingly.
<strong>WARNNG</strong>: Currently we reset pivots when doing so</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return : copy of self pointing to the new dag path self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will remove all instance of this object and leave this object at only one path -
if this is not what you want, use the addChild method instead as it can properly handle this case</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method handles namespaces properly</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.setParent">
<tt class="descname">setParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.setParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of self to parentnode being placed at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.shapes">
<tt class="descname">shapes</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dcf8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.shapes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all our Shape nodes</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you could use getChildren with a predicate, but this method is more
efficient as it uses dagpath functions to filter shapes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.transform">
<tt class="descname">transform</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to lowest transform in the path attached to our node</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for shapes this is the parent, for transforms the transform itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.GeometryShape.unparent">
<tt class="descname">unparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.GeometryShape.unparent" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>reparent</cite>, but will unparent this transform under the scene root</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry.Mesh-class.html">Epydoc: mrv.maya.nt.geometry.Mesh</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry.Mesh">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">Mesh</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.SurfaceShape</span></tt></p>
<p>Implemnetation of mesh related methods to make its handling more
convenient</p>
<p><strong>Component Access</strong>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cvtx</span><span class="p">[:]</span>                   <span class="c"># a complete set of components</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cvtx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>                 <span class="c"># initialized with 3 indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cvtx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c"># initialized with a single index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cvtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>               <span class="c"># initialized with multiple indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">cf</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>               <span class="c"># initialized with list or tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">ce</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>           <span class="c"># initialized from iterator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">ce</span><span class="p">[</span><span class="n">api</span><span class="o">.</span><span class="n">MIntArray</span><span class="p">()]</span>       <span class="c"># initialized from MIntArray</span>
</pre></div>
</div>
<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.addChild">
<tt class="descname">addChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.addChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given childNode as child to this Node. Allows instancing !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node you wish to add</li>
<li><em>position</em> &#8211; the index to which to add the new child, kNextPos will add it as last child.
It supports python style negative indices</li>
<li><em>keepExistingParent</em> &#8211; if True, the childNode will be instanced as it will
have its previous parent(s) and this one, if False, the previous parent will be removed
from the child&#8217;s parent list</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>keepWorldSpace</em> &#8211; see <cite>reparent</cite>, only effective if the node is not instanced</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">childNode whose path is pointing to the new child location</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if keepWorldSpace is requested with directly instanced nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">as maya internally handles add/remove child as instancing operation, even though
keepExistingParent is False, it will mess up things and for a short period of time in fact
have two n + 1 instances, right before one is unlinked, This still fills a slot or something, and
isInstanced will be true, although the pathcount is 1.
Long story short: if the item to be added to us is not instanced, we use reparent instead. It
will not harm in direct instances, so its save to use.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if the instance count of the item is 1 and keepExistingParent is False, the position
argument is being ignored</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.addInstancedChild">
<tt class="descname">addInstancedChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.addInstancedChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add childnode as instanced child to this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for more information, see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">its a shortcut to addChild allowing to clearly indicate what is happening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.addParent">
<tt class="descname">addParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.addParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds ourselves as instance to the given parentnode at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.Mesh.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x44cffb0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our dag path as this is our api object - the object defining this node best</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.autoUniformGridParams">
<tt class="descname">autoUniformGridParams</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.autoUniformGridParams" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.ce">
<tt class="descname">ce</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.ce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.cf">
<tt class="descname">cf</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.cf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.child">
<tt class="descname">child</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.child" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">child of self at index</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method fixes the MFnDagNode.child method - it returns an MObject,
which doesnt work well with instanced nodes - a dag path is required, which is what
we use to aquire the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.childTransforms">
<tt class="descname">childTransforms</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dde8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.childTransforms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all transform nodes below this one</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479db18&gt;</em>, <em>asNode=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all child nodes below this dag node if predicate returns True for passed Node</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>asNode</em> &#8211; if True, you will receive the children as wrapped Nodes, otherwise you 
get MDagPaths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.childrenByType">
<tt class="descname">childrenByType</tt><big>(</big><em>nodeType</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x479dc08&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.childrenByType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all childnodes below this one matching the given nodeType and the predicate</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>nodeType</em> &#8211; class of the nodeTyoe, like nt.Transform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.clearGlobalIntersectionAcceleratorInfo">
<tt class="descname">clearGlobalIntersectionAcceleratorInfo</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.clearGlobalIntersectionAcceleratorInfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.cmap">
<tt class="descname">cmap</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.cmap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.component">
<tt class="descname">component</tt><big>(</big><em>component_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.component" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A component object able to hold the given component type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>component_type</em> &#8211; a member of the <cite>eComponentType</cite> enumeration</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.componentAssignments">
<tt class="descname">componentAssignments</tt><big>(</big><em>setFilter=(319</em>, <em>False</em>, <em>0)</em>, <em>use_api=True</em>, <em>asComponent=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.componentAssignments" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of tuples(ObjectSetNode, Component_or_MObject) defininmg shader
assignments on per component basis.</p>
<p>If a shader is assigned to the whole object, the component would be a null object, otherwise
it is an instance of a wrapped IndexedComponent class</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">The returned Component will be an MObject(kNullObject) only in case the component is 
not set. Hence you should check whether it isNull() before actually using it.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>setFilter</em> &#8211; see <cite>connectedSets</cite></li>
<li><em>use_api</em> &#8211; if True, api methods will be used if possible which is usually faster.
If False, a custom non-api implementation will be used instead.
This can be required if the apiImplementation is not reliable which happens in
few cases of &#8216;weird&#8217; component assignments</li>
<li><em>asComponent</em> &#8211; If True, the components will be wrapped into the matching MRV compontent type
to provide a nicer interface. This might slightly slow down the process, but this is usually 
neglectable.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the sets order will be the order of connections of the respective component list
attributes at instObjGroups.objectGroups</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">currently only meshes and subdees support per component assignment, whereas only
meshes can have per component shader assignments</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">SubDivision Components cannot be supported as the component type kSubdivCVComponent
cannot be wrapped into any component function set - reevaluate that with new maya versions !</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">deformer set component assignments are only returned for instance 0 ! They apply to all
output meshes though</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.copyAssignmentsTo">
<tt class="descname">copyAssignmentsTo</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.copyAssignmentsTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy set assignments including component assignments to other</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; passed to set.addMember, additional kwargs are:
* setFilter: default is fSetsRenderable</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy tweaks and sets from other onto self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>setFilter: if given, default is fSets, you may specify the types of sets to copy</dt>
<dd>if None, no set conenctions will be copied</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.copyLightLinks">
<tt class="descname">copyLightLinks</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.copyLightLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy lightlinks from one meshShape to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>substitute: </dt>
<dd>if True, default False, the other shape will be put
in place of self, effectively receiving it&#8217;s light-links whereas self losses
them. This is practical in case you create a new shape below a transform that
had a previously visible and manipulated shape whose external connections you
wouuld like to keep</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.copyTweaksTo">
<tt class="descname">copyTweaksTo</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.copyTweaksTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy our tweaks onto another mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we do not check topology for maximum flexibility</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.cvtx">
<tt class="descname">cvtx</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.cvtx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.dagPath">
<tt class="descname">dagPath</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.dagPath" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the original DagPath attached to this Node - it&#8217;s not wrapped
for performance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If you plan to alter it, make sure you copy it using the 
MDagPath(node.dagPath()) construct !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node - this special version must be</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.displayOverrideValue">
<tt class="descname">displayOverrideValue</tt><big>(</big><em>plugName</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.displayOverrideValue" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the override display value actually identified by plugName affecting
the given object (that should be a leaf node for the result you see in the viewport.
The display type in effect is always the last one set in the hierarchy
returns None display overrides are disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplciate the given node to newpath</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newpath</em> &#8211; <p>result depends on its format:</p>
<ul>
<li>&#8216;&#8217; - empty string, creates a unique name based on the actual node name by appending a copy number
to it, if newTransform is True, the newly created shape/transform will keep its name, but receives a new parent</li>
<li>&#8216;newname&#8217; - relative path, the node will be duplicated not changing its current parent if newTransform is False</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">|parent|newname</span></tt> - absolute path, the node will be duplicated and reparented under the given path</dt>
<dd>if newTransform is True, a new transform name will be created based on your name by appending a unique copy number</dd>
</dl>
</li>
</ul>
</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
<li><em>newTransform</em> &#8211; if True, a new transform will be created based on the name of the parent transform
of this shape node, appending a unique copy number to it.
Only has an effect for shape nodes</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">newly create Node</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">duplicate performance could be improved by checking more before doing work that does not
really change the scene, but adds undo operations</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">inbetween parents are always required as needed</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">add example for each version of newpath</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">instancing can be realized using the <cite>addChild</cite> function</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">If meshes have tweaks applied, the duplicate will not have these tweaks and the meshes will look
mislocated.
Using MEL works in that case ... (they fixed it there obviously) , but creates invalid objects</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">Undo implementation - every undoable operation must in fact be based on strings to really work, all
this is far too much - dagNode.duplicate must be undoable by itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first last">duplicate should be completely reimplemented to support all mel options and actually work with
meshes and tweaks - the underlying api duplication would still be used of course, as well as
connections (to sets) and so on ...</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.e">
<tt class="descname">e</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.e" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.f">
<tt class="descname">f</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.f" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.Mesh.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.globalIntersectionAcceleratorsInfo">
<tt class="descname">globalIntersectionAcceleratorsInfo</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.globalIntersectionAcceleratorsInfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.hasChild">
<tt class="descname">hasChild</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.hasChild" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if node is a child of self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.instance">
<tt class="descname">instance</tt><big>(</big><em>instanceNumber</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.instance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to the instance identified by instanceNumber</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>instanceNumber</em> &#8211; range(0, self.instanceCount()-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.instanceNumber">
<tt class="descname">instanceNumber</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.instanceNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our instance number</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">0 does not indicate that this object is not instanced - use getInstanceCount instead</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x442aea0&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isTemplate">
<tt class="descname">isTemplate</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isTemplate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is templated - this is the case if itself or one of its
parents are templated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Handles DAG objects correctly that can be instanced, in which case
the MObject may be valid , but the respective dag path is not.
Additionally, if the object is not parented below any object, everything appears
to be valid, but the path name is empty</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isValidMesh">
<tt class="descname">isValidMesh</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isValidMesh" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if we are nonempty and valid - emptry meshes do not work with the mfnmesh
although it should ! Have to catch that case ourselves</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.isVisible">
<tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is visible - its visible if itself and all parents are
visible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.iterComponents">
<tt class="descname">iterComponents</tt><big>(</big><em>component_type</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x456cd20&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.iterComponents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">MItIterator matching your component_type to iteartor over items
on this mesh</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>component_type</em> &#8211; <ul>
<li>vertex -&gt; MItMeshVertex</li>
<li>edge -&gt; MItMeshEdge</li>
<li>face -&gt; MItMeshPolygon</li>
<li>uv -&gt; MItMeshFaceVertex</li>
</ul>
</li>
<li><em>component</em> &#8211; if not kNullObject, the iterator returned will be constrained
to the given indices as described by the Component. Use <cite>component</cite> to retrieve 
a matching component type&#8217;s instance</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.iterInstances">
<tt class="descname">iterInstances</tt><big>(</big><em>excludeSelf=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.iterInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get iterator over all (direct and indirect)instances of this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>excludeSelf</em> &#8211; if True, self will not be returned, if False, it will be in
the list of items</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Iterating instances is more efficient than querying all instances individually using
<cite>instance</cite></td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">add flag to allow iteration of indirect instances as well</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.map">
<tt class="descname">map</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.map" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">fully qualified (long) name of this dag node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MObject as retrieved from the MDagPath of our Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maya node of the parent of this instance or None if this is the root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.parentAtIndex">
<tt class="descname">parentAtIndex</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.parentAtIndex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node of the parent at the given index - non-instanced nodes only have one parent</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if a node is instanced, it can have <cite>parentCount</cite> parents</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">Update dagpath afterwards ! Use dagpaths instead !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.removeChild">
<tt class="descname">removeChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.removeChild" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given childNode (being a child of this node) from our child list, effectively
parenting it under world !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node to unparent - if it is not one of our children, no change takes place</li>
<li><em>allowZeroParents</em> &#8211; if True, it is possible to leave a node unparented, thus no valid
dag paths leads to it. If False, transforms will just be reparented under the world</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">copy of childnode pointing to the first valid dag path we find.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">to prevent the child (if transform) to dangle in unknown space if the last instance
is to be removed, it will instead be reparented to world.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">removing shapes from their last parent will result in an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x456f830&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.removeParent">
<tt class="descname">removeParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.removeParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove ourselves from given parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.reparent">
<tt class="descname">reparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.reparent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of all nodes (also instances) to be located below parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>parentnode</em> &#8211; Node instance of transform under which this node should be parented to
if None, node will be reparented under the root (which only works for transforms)</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>raiseOnInstance</em> &#8211; if True, this method will raise if you try to reparent an instanced object.
If false, instanced objects will be merged into the newly created path under parentnode, effectively
eliminating all other paths , keeping the newly created one</li>
<li><em>keepWorldSpace</em> &#8211; if True and node to be reparented is a transform, the world space position
will be kept by adjusting the transformation accordingly.
<strong>WARNNG</strong>: Currently we reset pivots when doing so</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return : copy of self pointing to the new dag path self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will remove all instance of this object and leave this object at only one path -
if this is not what you want, use the addChild method instead as it can properly handle this case</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method handles namespaces properly</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.resetTweaks">
<tt class="descname">resetTweaks</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.resetTweaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the tweaks on the given mesh shape</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>tweak_type</em> &#8211; the component type(s) whose tweaks are to be removed,
valid values are &#8216;vertex&#8217; and &#8216;uv&#8217; members of the eComponentType enumeration. 
Pass in a scalar value or a list of tweak types</li>
<li><em>keep_tweak_result</em> &#8211; <p>if True, the effect of the tweak will be kept. If False,
it will be removed. What actually happens depends on the context</p>
<ul>
<li><dl class="first docutils">
<dt>[referenced] mesh <em>without</em> history:</dt>
<dd>copy outMesh to inMesh, resetTweaks<p class="last">if referenced, plenty of reference edits are generated, ideally one operates
on non-referenced geomtry</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>[referenced] mesh <em>with</em> history:</dt>
<dd>put tweakNode into mesh history, copy tweaks onto tweak node</dd>
</dl>
</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">currently vertex and uv tweaks will be removed if keep is enabled, thus they must
both be specified</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.setParent">
<tt class="descname">setParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.setParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of self to parentnode being placed at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.shapes">
<tt class="descname">shapes</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dcf8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.shapes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all our Shape nodes</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you could use getChildren with a predicate, but this method is more
efficient as it uses dagpath functions to filter shapes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.transform">
<tt class="descname">transform</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to lowest transform in the path attached to our node</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for shapes this is the parent, for transforms the transform itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.uniformGridParams">
<tt class="descname">uniformGridParams</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.uniformGridParams" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.Mesh.unparent">
<tt class="descname">unparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.unparent" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>reparent</cite>, but will unparent this transform under the scene root</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry.Mesh.vtx">
<tt class="descname">vtx</tt><a class="headerlink" href="#mrv.maya.nt.geometry.Mesh.vtx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry.SurfaceShape-class.html">Epydoc: mrv.maya.nt.geometry.SurfaceShape</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry.SurfaceShape">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">SurfaceShape</tt><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.ControlPoint</span></tt></p>
<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.addChild">
<tt class="descname">addChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.addChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given childNode as child to this Node. Allows instancing !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node you wish to add</li>
<li><em>position</em> &#8211; the index to which to add the new child, kNextPos will add it as last child.
It supports python style negative indices</li>
<li><em>keepExistingParent</em> &#8211; if True, the childNode will be instanced as it will
have its previous parent(s) and this one, if False, the previous parent will be removed
from the child&#8217;s parent list</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>keepWorldSpace</em> &#8211; see <cite>reparent</cite>, only effective if the node is not instanced</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">childNode whose path is pointing to the new child location</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if keepWorldSpace is requested with directly instanced nodes</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">as maya internally handles add/remove child as instancing operation, even though
keepExistingParent is False, it will mess up things and for a short period of time in fact
have two n + 1 instances, right before one is unlinked, This still fills a slot or something, and
isInstanced will be true, although the pathcount is 1.
Long story short: if the item to be added to us is not instanced, we use reparent instead. It
will not harm in direct instances, so its save to use.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if the instance count of the item is 1 and keepExistingParent is False, the position
argument is being ignored</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.addInstancedChild">
<tt class="descname">addInstancedChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.addInstancedChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Add childnode as instanced child to this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for more information, see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">its a shortcut to addChild allowing to clearly indicate what is happening</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.addParent">
<tt class="descname">addParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.addParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds ourselves as instance to the given parentnode at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.SurfaceShape.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x44cffb0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our dag path as this is our api object - the object defining this node best</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.child">
<tt class="descname">child</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.child" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">child of self at index</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method fixes the MFnDagNode.child method - it returns an MObject,
which doesnt work well with instanced nodes - a dag path is required, which is what
we use to aquire the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.childTransforms">
<tt class="descname">childTransforms</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dde8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.childTransforms" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all transform nodes below this one</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479db18&gt;</em>, <em>asNode=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all child nodes below this dag node if predicate returns True for passed Node</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>asNode</em> &#8211; if True, you will receive the children as wrapped Nodes, otherwise you 
get MDagPaths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.childrenByType">
<tt class="descname">childrenByType</tt><big>(</big><em>nodeType</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x479dc08&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.childrenByType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all childnodes below this one matching the given nodeType and the predicate</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>nodeType</em> &#8211; class of the nodeTyoe, like nt.Transform</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.componentAssignments">
<tt class="descname">componentAssignments</tt><big>(</big><em>setFilter=(319</em>, <em>False</em>, <em>0)</em>, <em>use_api=True</em>, <em>asComponent=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.componentAssignments" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of tuples(ObjectSetNode, Component_or_MObject) defininmg shader
assignments on per component basis.</p>
<p>If a shader is assigned to the whole object, the component would be a null object, otherwise
it is an instance of a wrapped IndexedComponent class</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">The returned Component will be an MObject(kNullObject) only in case the component is 
not set. Hence you should check whether it isNull() before actually using it.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>setFilter</em> &#8211; see <cite>connectedSets</cite></li>
<li><em>use_api</em> &#8211; if True, api methods will be used if possible which is usually faster.
If False, a custom non-api implementation will be used instead.
This can be required if the apiImplementation is not reliable which happens in
few cases of &#8216;weird&#8217; component assignments</li>
<li><em>asComponent</em> &#8211; If True, the components will be wrapped into the matching MRV compontent type
to provide a nicer interface. This might slightly slow down the process, but this is usually 
neglectable.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the sets order will be the order of connections of the respective component list
attributes at instObjGroups.objectGroups</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">currently only meshes and subdees support per component assignment, whereas only
meshes can have per component shader assignments</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">SubDivision Components cannot be supported as the component type kSubdivCVComponent
cannot be wrapped into any component function set - reevaluate that with new maya versions !</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">deformer set component assignments are only returned for instance 0 ! They apply to all
output meshes though</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.copyLightLinks">
<tt class="descname">copyLightLinks</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.copyLightLinks" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy lightlinks from one meshShape to another</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>substitute: </dt>
<dd>if True, default False, the other shape will be put
in place of self, effectively receiving it&#8217;s light-links whereas self losses
them. This is practical in case you create a new shape below a transform that
had a previously visible and manipulated shape whose external connections you
wouuld like to keep</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.dagPath">
<tt class="descname">dagPath</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.dagPath" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the original DagPath attached to this Node - it&#8217;s not wrapped
for performance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">If you plan to alter it, make sure you copy it using the 
MDagPath(node.dagPath()) construct !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node - this special version must be</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.displayOverrideValue">
<tt class="descname">displayOverrideValue</tt><big>(</big><em>plugName</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.displayOverrideValue" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the override display value actually identified by plugName affecting
the given object (that should be a leaf node for the result you see in the viewport.
The display type in effect is always the last one set in the hierarchy
returns None display overrides are disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplciate the given node to newpath</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newpath</em> &#8211; <p>result depends on its format:</p>
<ul>
<li>&#8216;&#8217; - empty string, creates a unique name based on the actual node name by appending a copy number
to it, if newTransform is True, the newly created shape/transform will keep its name, but receives a new parent</li>
<li>&#8216;newname&#8217; - relative path, the node will be duplicated not changing its current parent if newTransform is False</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">|parent|newname</span></tt> - absolute path, the node will be duplicated and reparented under the given path</dt>
<dd>if newTransform is True, a new transform name will be created based on your name by appending a unique copy number</dd>
</dl>
</li>
</ul>
</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
<li><em>newTransform</em> &#8211; if True, a new transform will be created based on the name of the parent transform
of this shape node, appending a unique copy number to it.
Only has an effect for shape nodes</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">newly create Node</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">duplicate performance could be improved by checking more before doing work that does not
really change the scene, but adds undo operations</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">inbetween parents are always required as needed</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">add example for each version of newpath</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">instancing can be realized using the <cite>addChild</cite> function</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">If meshes have tweaks applied, the duplicate will not have these tweaks and the meshes will look
mislocated.
Using MEL works in that case ... (they fixed it there obviously) , but creates invalid objects</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">Undo implementation - every undoable operation must in fact be based on strings to really work, all
this is far too much - dagNode.duplicate must be undoable by itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first last">duplicate should be completely reimplemented to support all mel options and actually work with
meshes and tweaks - the underlying api duplication would still be used of course, as well as
connections (to sets) and so on ...</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.geometry.SurfaceShape.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.hasChild">
<tt class="descname">hasChild</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.hasChild" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if node is a child of self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.instance">
<tt class="descname">instance</tt><big>(</big><em>instanceNumber</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.instance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to the instance identified by instanceNumber</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>instanceNumber</em> &#8211; range(0, self.instanceCount()-1)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.instanceNumber">
<tt class="descname">instanceNumber</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.instanceNumber" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our instance number</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">0 does not indicate that this object is not instanced - use getInstanceCount instead</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x442aea0&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isTemplate">
<tt class="descname">isTemplate</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isTemplate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is templated - this is the case if itself or one of its
parents are templated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Handles DAG objects correctly that can be instanced, in which case
the MObject may be valid , but the respective dag path is not.
Additionally, if the object is not parented below any object, everything appears
to be valid, but the path name is empty</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.isVisible">
<tt class="descname">isVisible</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.isVisible" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this node is visible - its visible if itself and all parents are
visible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.iterInstances">
<tt class="descname">iterInstances</tt><big>(</big><em>excludeSelf=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.iterInstances" title="Permalink to this definition">¶</a></dt>
<dd><p>Get iterator over all (direct and indirect)instances of this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>excludeSelf</em> &#8211; if True, self will not be returned, if False, it will be in
the list of items</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Iterating instances is more efficient than querying all instances individually using
<cite>instance</cite></td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">add flag to allow iteration of indirect instances as well</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x2accd8a3c230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">fully qualified (long) name of this dag node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MObject as retrieved from the MDagPath of our Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Maya node of the parent of this instance or None if this is the root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.parentAtIndex">
<tt class="descname">parentAtIndex</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.parentAtIndex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node of the parent at the given index - non-instanced nodes only have one parent</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if a node is instanced, it can have <cite>parentCount</cite> parents</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">Update dagpath afterwards ! Use dagpaths instead !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.removeChild">
<tt class="descname">removeChild</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.removeChild" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the given childNode (being a child of this node) from our child list, effectively
parenting it under world !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>childNode</em> &#8211; Node to unparent - if it is not one of our children, no change takes place</li>
<li><em>allowZeroParents</em> &#8211; if True, it is possible to leave a node unparented, thus no valid
dag paths leads to it. If False, transforms will just be reparented under the world</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">copy of childnode pointing to the first valid dag path we find.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">to prevent the child (if transform) to dangle in unknown space if the last instance
is to be removed, it will instead be reparented to world.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">removing shapes from their last parent will result in an error</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x456f830&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.removeParent">
<tt class="descname">removeParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.removeParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove ourselves from given parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.reparent">
<tt class="descname">reparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.reparent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of all nodes (also instances) to be located below parentnode</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>parentnode</em> &#8211; Node instance of transform under which this node should be parented to
if None, node will be reparented under the root (which only works for transforms)</li>
<li><em>renameOnClash</em> &#8211; resolve nameclashes by automatically renaming the node to make it unique</li>
<li><em>raiseOnInstance</em> &#8211; if True, this method will raise if you try to reparent an instanced object.
If false, instanced objects will be merged into the newly created path under parentnode, effectively
eliminating all other paths , keeping the newly created one</li>
<li><em>keepWorldSpace</em> &#8211; if True and node to be reparented is a transform, the world space position
will be kept by adjusting the transformation accordingly.
<strong>WARNNG</strong>: Currently we reset pivots when doing so</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:return : copy of self pointing to the new dag path self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will remove all instance of this object and leave this object at only one path -
if this is not what you want, use the addChild method instead as it can properly handle this case</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method handles namespaces properly</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.setParent">
<tt class="descname">setParent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.setParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the parent of self to parentnode being placed at position</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; see <cite>addChild</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self with updated dag path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.shapes">
<tt class="descname">shapes</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x479dcf8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.shapes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all our Shape nodes</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you could use getChildren with a predicate, but this method is more
efficient as it uses dagpath functions to filter shapes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.transform">
<tt class="descname">transform</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.transform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node to lowest transform in the path attached to our node</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">for shapes this is the parent, for transforms the transform itself</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry.SurfaceShape.unparent">
<tt class="descname">unparent</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry.SurfaceShape.unparent" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>reparent</cite>, but will unparent this transform under the scene root</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry._SingleIndexedComponentGenerator-class.html">Epydoc: mrv.maya.nt.geometry._SingleIndexedComponentGenerator</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry._SingleIndexedComponentGenerator">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">_SingleIndexedComponentGenerator</tt><big>(</big><em>mesh</em>, <em>component</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry._SingleIndexedComponentGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">object</span></tt></p>
<p>Utility producing components, initialized with the given indices. See <cite>Mesh</cite>
for more info.</p>
<dl class="method">
<dt id="mrv.maya.nt.geometry._SingleIndexedComponentGenerator.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry._SingleIndexedComponentGenerator.empty" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">empty component of our type</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry._SingleIndexedComponentIterator-class.html">Epydoc: mrv.maya.nt.geometry._SingleIndexedComponentIterator</a></p>
<dl class="class">
<dt id="mrv.maya.nt.geometry._SingleIndexedComponentIterator">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.geometry.</tt><tt class="descname">_SingleIndexedComponentIterator</tt><big>(</big><em>mesh</em>, <em>component</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry._SingleIndexedComponentIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a title="mrv.maya.nt.geometry._SingleIndexedComponentGenerator" class="reference internal" href="#mrv.maya.nt.geometry._SingleIndexedComponentGenerator"><tt class="xref docutils literal"><span class="pre">mrv.maya.nt.geometry._SingleIndexedComponentGenerator</span></tt></a></p>
<p>Utility which produces iterators for the component type
it was initialized with. As a bonus, it allows to return 
quick constrained iterators using the slice and get-item notation</p>
<dl class="method">
<dt id="mrv.maya.nt.geometry._SingleIndexedComponentIterator.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry._SingleIndexedComponentIterator.empty" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">empty component of our type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.geometry._SingleIndexedComponentIterator.iter">
<tt class="descname">iter</tt><a class="headerlink" href="#mrv.maya.nt.geometry._SingleIndexedComponentIterator.iter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Iterator for all components in the mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.geometry._SingleIndexedComponentIterator.iterator">
<tt class="descname">iterator</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.geometry._SingleIndexedComponentIterator.iterator" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Iterator for all components in the mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.geometry-module.html#Element">Epydoc: mrv.maya.nt.geometry</a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#"><tt class="docutils literal"><span class="pre">mrv.maya.nt.geometry</span></tt></a><ul>
<li><a class="reference external" href="#functions">Functions</a></li>
<li><a class="reference external" href="#classes">Classes</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="mrv.maya.nt.storage.html"
                                  title="previous chapter"><tt class="docutils literal"><span class="pre">mrv.maya.nt.storage</span></tt></a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="mrv.automation.process.html"
                                  title="next chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">mrv.automation.process</span></tt></a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/generated/mrv.maya.nt.geometry.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mrv.automation.process.html" title="mrv.automation.process"
             >next</a> |</li>
        <li class="right" >
          <a href="mrv.maya.nt.storage.html" title="mrv.maya.nt.storage"
             >previous</a> |</li>
        <li><a href="../index.html">mrv v1.0.2-develop documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright Sebastian Thiel.
      Last updated on Apr 19, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>