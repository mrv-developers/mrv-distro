<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mrv.maya.nt.storage &mdash; mrv v1.0.2-develop documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.2-develop',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="mrv v1.0.2-develop documentation" href="../index.html" />
    <link rel="next" title="mrv.maya.nt.geometry" href="mrv.maya.nt.geometry.html" />
    <link rel="prev" title="mrv.maya.nt.util" href="mrv.maya.nt.util.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="mrv.maya.nt.geometry.html" title="mrv.maya.nt.geometry"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mrv.maya.nt.util.html" title="mrv.maya.nt.util"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">mrv v1.0.2-develop documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-mrv.maya.nt.storage">
<h1><tt class="xref docutils literal"><span class="pre">mrv.maya.nt.storage</span></tt><a class="headerlink" href="#module-mrv.maya.nt.storage" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html">Epydoc: mrv.maya.nt.storage</a></p>
<p>Contains an implementation for the Persistence plugin for easy access within 
mrv and derived nodes.</p>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="mrv.maya.nt.storage._makeElementPlug">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">_makeElementPlug</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage._makeElementPlug" title="Permalink to this definition">¶</a></dt>
<dd>Find an empty logical plug index and return the newly created
logical plug with given dataID - unconditionally</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.clearAllData">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">clearAllData</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.clearAllData" title="Permalink to this definition">¶</a></dt>
<dd>Empty all data storage plugs beneath the given masterPlug. Message connections are currently
not affected</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.clearDataPlug">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">clearDataPlug</tt><big>(</big><em>vdplug</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.clearDataPlug" title="Permalink to this definition">¶</a></dt>
<dd>Clear the data in the given value data plug</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.createNode">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">createNode</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.createNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new node of nodetype with given nodename</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>nodename</em> &#8211; like <tt class="docutils literal"><span class="pre">mynode``or</span> <span class="pre">``namespace:mynode</span></tt> or <tt class="docutils literal"><span class="pre">|parent|mynode</span></tt> or
<tt class="docutils literal"><span class="pre">|ns1:parent|ns1:ns2:parent|ns3:mynode</span></tt>. The name may contain any amount of parents
and/or namespaces.</li>
<li><em>nodetype</em> &#8211; a nodetype known to maya to be created accordingly</li>
<li><em>autocreateNamespace</em> &#8211; if True, namespaces given in the nodename will be created
if required</li>
<li><em>renameOnClash</em> &#8211; if True, nameclashes will automatcially be resolved by creating a unique
name - this only happens if a dependency node has the same name as a dag node</li>
<li><em>forceNewLeaf</em> &#8211; if True, nodes will be created anyway if a node with the same name
already exists - this will recreate the leaf portion of the given paths. Implies renameOnClash
If False, you will receive an already existing node if the name and type matches.</li>
<li><em>maxShapesPerTransform</em> &#8211; only used when renameOnClash is True, defining the number of
shapes you may have below a transform. If the number would be exeeded by the creation of
a shape below a given transform, a new auto-renamed transform will be created automatically.
This transform is garantueed to be new and will be used as new parent for the shape.</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">For reasons of safety, dag nodes must use absolute paths like <tt class="docutils literal"><span class="pre">|parent|child</span></tt> -
otherwise names might be ambiguous ! This method will assume absolute paths !</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises RuntimeError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">If nodename contains namespaces or parents that may not be created</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises NameError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">If name of desired node clashes as existing node has different type</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">As this method is checking a lot and tries to be smart, its relatively slow (creates ~1200 nodes / s)</p>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the newly create Node</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.dataIDs">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">dataIDs</tt><big>(</big><em>masterPlug</em>, <em>data_prefix=''</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.dataIDs" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all data ids available in the given master plug</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>data_prefix</em> &#8211; the string prefix of data names which must match with the prefix
of the data id to be returned, with the matching prefix pruned. 
By default, all data ids will match</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.delete">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>args</em> &#8211; Node instances, MObjects, MDagPaths or strings to delete</li>
<li><em>kwargs</em> &#8211; <blockquote>
<ul>
<li><dl class="first docutils">
<dt>presort: </dt>
<dd>if True, default False, will do alot of pre-work to actually
make the deletion work properly using  the UI, thus we sort dag nodes
by dag path token length to delete top level ones first and individually, 
to finally delete all dependency nodes in a bunch</dd>
</dl>
</li>
</ul>
</blockquote>
<p>Using this flag will be slower, but yields much better results if deleting complex
dag and dependency trees with locked attributes, conversion nodes, transforms and shapes</p>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">in general , no matter which options have been chosen , api deletion does not work well
as the used algorithm is totally different and inferior to the mel implementaiton</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">will not raise in case of an error, but print a notification message</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">all deletions will be stored on one undo operation</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.deleteObjectSet">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">deleteObjectSet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.deleteObjectSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the object set at the given message data plug, at the given setIndex
:note: use this method to delete your sets instead of manual deletion as it will automatically</p>
<blockquote>
remove the managed partition in case the last set is being deleted</blockquote>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.findStoragePlug">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">findStoragePlug</tt><big>(</big><em>masterPlug</em>, <em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.findStoragePlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">compound plug containing all data and connections for the given dataID</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>masterPlug</em> &#8211; compound plug containing all data</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.makePlug">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">makePlug</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.makePlug" title="Permalink to this definition">¶</a></dt>
<dd><p>retrieve or create a plug that corresponds to the given dataID
:param dataID: string identifier
:return: the created data plug, containing subplugs dval and dmsg</p>
<blockquote>
for generic data and  message connections respectively</blockquote>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.objectSet">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">objectSet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.objectSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an object set identified with setIndex at the given dataId</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>mdplug</em> &#8211; data message plug whose object set to handle</li>
<li><em>setIndex</em> &#8211; logical index at which the set will be connected to our message plug array</li>
<li><em>autoCreate</em> &#8211; if True, a set will be created if it does not yet exist</li>
<li><em>setPrefix</em> &#8211; if given, the string will be used as prefix for the name of newly created
object sets</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises ValueError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if a set does not exist at setIndex and autoCreate is False</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises AttributeError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if the plug did not exist (and autocreate is False)</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">method is implicitly undoable if autoCreate is True, this also means that you cannot
explicitly undo this operation as you do not know if undo has been queued or not</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">newly created sets will automatically use partitions if one of the sets does</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.partition">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">partition</tt><big>(</big><em>mdplug</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.partition" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">parition node attached to the sets of the given message data plug or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.setPartition">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">setPartition</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.setPartition" title="Permalink to this definition">¶</a></dt>
<dd>Make all sets of the given data message plug use a partition or not
:param state: if True, a partition will be used, if False, it will be disabled
:note: this method makes sure that all sets are hooked up to the partition
:raise ValueError: If we did not have a single set to which to add to the partition
:raise AttributeError: If the dataID has never had sets
:return: if state is True, the name of the possibly created (or existing) partition</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.setsByPlug">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">setsByPlug</tt><big>(</big><em>mdplug</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.setsByPlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all objectSets stored at the given message data plug</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mrv.maya.nt.storage.storagePlug">
<tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">storagePlug</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.storagePlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">plug of the given type, either as tuple of two plugs or the plug
specified by plugType</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>masterPlug</em> &#8211; masterPlug to search for data</li>
<li><em>dataID</em> &#8211; the name of the plug to be returned</li>
<li><em>plugType</em> &#8211; StorageBase.kMessage: return message array plug only
StorageBase.kValue: return python pickle array plug only
StorageBase.kStorage: return the storage plug itself containing message and the value plug
StorageBase.kFlags return plug to integer which can be used as storage for bitflags to accompany the id
None: return (picklePlug , messagePlug)</li>
<li><em>autoCreate</em> &#8211; if True, a plug with the given dataID will be created if it does not
yet exist</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises AttributeError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first">if a plug with dataID does not exist and default value is None</p>
</td>
</tr>
<tr class="field"><th class="field-name" colspan="2">Raises TypeError:</th></tr>
<tr><td>&nbsp;</td><td class="field-body"><p class="first last">if  plugtype unknown</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#Data">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.Data">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">Data</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">maya.OpenMaya.MObject</span></tt>, <tt class="xref docutils literal"><span class="pre">mrv.maya.nt._root_</span></tt></p>
<p>Represents an data in general - this is the base class
Use this general class to create data wrap objects - it will return a class of the respective type</p>
<dl class="method">
<dt id="mrv.maya.nt.storage.Data.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.apiType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Data.apiTypeStr">
<tt class="descname">apiTypeStr</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.apiTypeStr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Data.assign">
<tt class="descname">assign</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.assign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Data.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.Data.create">
<em class="property">classmethod </em><tt class="descname">create</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.create" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">A new instance of data wrapped in the desired Data type</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">specialize this method in derived types !</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Data.hasFn">
<tt class="descname">hasFn</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.hasFn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Data.isNull">
<tt class="descname">isNull</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Data.isNull" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.storage.Data.kNullObj">
<tt class="descname">kNullObj</tt><a class="headerlink" href="#mrv.maya.nt.storage.Data.kNullObj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.storage.Data.thisown">
<tt class="descname">thisown</tt><a class="headerlink" href="#mrv.maya.nt.storage.Data.thisown" title="Permalink to this definition">¶</a></dt>
<dd>The membership flag</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#DependNode">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.DependNode">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">DependNode</tt><a class="headerlink" href="#mrv.maya.nt.storage.DependNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.Node</span></tt>, <a title="mrv.interface.iDuplicatable" class="reference external" href="mrv.interface.html#mrv.interface.iDuplicatable"><tt class="xref docutils literal"><span class="pre">mrv.interface.iDuplicatable</span></tt></a></p>
<p>Implements access to dependency nodes</p>
<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.DependNode.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5c828e0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MObject attached to this Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name of this instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">it is mainly for compatability with dagNodes which need this method 
in order to return the name of their leaf node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c2ed8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of intermediate children of path, [ child1 , child2 ]</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; return True to include x in result</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the child objects returned are supposed to be valid paths, not just relative paths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate our node and return a wrapped version to it</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>name</em> &#8211; if given, the newly created node will use the given name</li>
<li><em>kwargs</em> &#8211; <ul>
<li>renameOnClash: if Trrue, default True, clashes are prevented by renaming the new node</li>
<li>autocreateNamespace: if True, default True, namespaces will be created if mentioned in the name</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the copyTo method may not have not-undoable side-effects to be a proper
implementation</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">undo could be implemented for dg nodes - but for reasons of consistency, its disabled here -
who knows how much it will crap out after a while as duplicate is not undoable (mel command)  -
it never really worked to undo a mel command from within python, executed using a dgmodifier - unfortunately
it does not return any result making it hard to find the newly duplicated object !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.DependNode.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5c1d740&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are NOT valid, but alive</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MObject attached to this Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">parent of this path, &#8216;/hello/world&#8217; -&gt; &#8216;/hello&#8217; or None if this path
is the dag&#8217;s root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5b41420&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.DependNode.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.DependNode.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#MFnDependencyNode">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.MFnDependencyNode">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">MFnDependencyNode</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">maya.OpenMaya.MFnBase</span></tt></p>
<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.attribute">
<tt class="descname">attribute</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.attribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.attributeClass">
<tt class="descname">attributeClass</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.attributeClass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.attributeCount">
<tt class="descname">attributeCount</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.attributeCount" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.canBeWritten">
<tt class="descname">canBeWritten</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.canBeWritten" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.create">
<tt class="descname">create</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgCallbackIds">
<tt class="descname">dgCallbackIds</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgCallbackIds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgCallbacks">
<tt class="descname">dgCallbacks</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgCallbacks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgTimer">
<tt class="descname">dgTimer</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgTimer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgTimerOff">
<tt class="descname">dgTimerOff</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgTimerOff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgTimerOn">
<tt class="descname">dgTimerOn</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgTimerOn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgTimerQueryState">
<tt class="descname">dgTimerQueryState</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgTimerQueryState" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.dgTimerReset">
<tt class="descname">dgTimerReset</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.dgTimerReset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.findAlias">
<tt class="descname">findAlias</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.findAlias" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.findPlug">
<tt class="descname">findPlug</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.findPlug" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.getAffectedAttributes">
<tt class="descname">getAffectedAttributes</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.getAffectedAttributes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.getAffectedByAttributes">
<tt class="descname">getAffectedByAttributes</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.getAffectedByAttributes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.getAliasAttr">
<tt class="descname">getAliasAttr</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.getAliasAttr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.getAliasList">
<tt class="descname">getAliasList</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.getAliasList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.getConnections">
<tt class="descname">getConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.getConnections" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.hasAttribute">
<tt class="descname">hasAttribute</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.hasAttribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.hasObj">
<tt class="descname">hasObj</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.hasObj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.hasUniqueName">
<tt class="descname">hasUniqueName</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.hasUniqueName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.icon">
<tt class="descname">icon</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.icon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.isDefaultNode">
<tt class="descname">isDefaultNode</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.isDefaultNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.isFlagSet">
<tt class="descname">isFlagSet</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.isFlagSet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.isFromReferencedFile">
<tt class="descname">isFromReferencedFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.isFromReferencedFile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.isLocked">
<tt class="descname">isLocked</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.isLocked" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.isNewAttribute">
<tt class="descname">isNewAttribute</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.isNewAttribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.isShared">
<tt class="descname">isShared</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.isShared" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.object" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.parentNamespace">
<tt class="descname">parentNamespace</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.parentNamespace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.pluginName">
<tt class="descname">pluginName</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.pluginName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.plugsAlias">
<tt class="descname">plugsAlias</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.plugsAlias" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.reorderedAttribute">
<tt class="descname">reorderedAttribute</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.reorderedAttribute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setAlias">
<tt class="descname">setAlias</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setAlias" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setDoNotWrite">
<tt class="descname">setDoNotWrite</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setDoNotWrite" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setFlag">
<tt class="descname">setFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setIcon">
<tt class="descname">setIcon</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setIcon" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setLocked">
<tt class="descname">setLocked</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setLocked" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setName">
<tt class="descname">setName</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.setObject">
<tt class="descname">setObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.setObject" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.thisown">
<tt class="descname">thisown</tt><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.thisown" title="Permalink to this definition">¶</a></dt>
<dd>The membership flag</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.type">
<tt class="descname">type</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.typeId">
<tt class="descname">typeId</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.typeId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.typeName">
<tt class="descname">typeName</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.typeName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.MFnDependencyNode.userNode">
<tt class="descname">userNode</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.MFnDependencyNode.userNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#Node">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.Node">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">Node</tt><a class="headerlink" href="#mrv.maya.nt.storage.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">object</span></tt></p>
<p>Common base for all maya nodes, providing access to the maya internal object
representation
Use this class to directly create a maya node of the required type</p>
<dl class="method">
<dt id="mrv.maya.nt.storage.Node.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Node.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the highest qualified api object of the actual superclass,
usually either MObject or MDagPath</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Node.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Node.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.Node.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Node.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.Node.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.Node.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#ObjectSet">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.ObjectSet">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">ObjectSet</tt><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.Entity</span></tt></p>
<p>Extended and more convenient object set interface dealing with Nodes ( and 
provides the original MFnSet interface as well</p>
<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.add">
<tt class="descname">add</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Combined method which takes single or multiple members which are to be added</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>member_or_members</em> &#8211; one of the input types supported by <cite>addMember</cite> and
<cite>addMembers</cite></li>
<li><em>kwargs</em> &#8211; see <cite>addMember</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">this method is for convenience only and should not be used to 
add massive amounts of items</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.addAttribute">
<tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.addMember">
<tt class="descname">addMember</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.addMember" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the item to the set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>member</em> &#8211; Node, MObject, MDagPath or plug</li>
<li><em>force</em> &#8211; if True, member ship will be forced by removing the member in question 
from the other set connected to our partitions</li>
<li><em>ignore_failure</em> &#8211; if True, a failed add due to partion constraints will result in an 
exception, otherwise it will be silently ignored. Ignored if if force is True</li>
<li><em>component</em> &#8211; if member is a dagnode, you can specify a component instance 
of type component instance ( Single|Double|TripleIndexComponent )</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body"><p class="first">handle components - currently its only possible when using selection lists</p>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.addMembers">
<tt class="descname">addMembers</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.addMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Add items from iterable or selection list as members to this set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>nodes</em> &#8211; MSelectionList or list of Nodes and Plugs</li>
<li><em>force</em> &#8211; see <cite>addMember</cite></li>
<li><em>ignore_failure</em> &#8211; see <cite>addMember</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.ObjectSet.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.addTo">
<tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5c828e0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.allocateFlag">
<tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.apiObject">
<tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MObject attached to this Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.apiType">
<tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name of this instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">it is mainly for compatability with dagNodes which need this method 
in order to return the name of their leaf node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c2ed8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of intermediate children of path, [ child1 , child2 ]</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; return True to include x in result</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the child objects returned are supposed to be valid paths, not just relative paths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.className">
<tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.classification">
<tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.clear">
<tt class="descname">clear</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the set so that it will be empty afterwards</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.connectedSets">
<tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.connections">
<tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.deallocateAllFlags">
<tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.deallocateFlag">
<tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.delete">
<tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.dependencyInfo">
<tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.difference">
<tt class="descname">difference</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>return the result of <tt class="docutils literal"><span class="pre">self</span> <span class="pre">minus</span> <span class="pre">objects</span></tt>, thus objects will be substracted from our obejcts</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; see <cite>union</cite></li>
<li><em>sets_are_members</em> &#8211; see <cite>union</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MSelectionList containing objects of self not being in objects list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.discard">
<tt class="descname">discard</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a single member or multiple members from the set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>member_or_members</em> &#8211; any of the types supported by <cite>removeMember</cite>
or <cite>removeMembers</cite></li>
<li><em>kwargs</em> &#8211; see <cite>removeMember</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate our node and return a wrapped version to it</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>name</em> &#8211; if given, the newly created node will use the given name</li>
<li><em>kwargs</em> &#8211; <ul>
<li>renameOnClash: if Trrue, default True, clashes are prevented by renaming the new node</li>
<li>autocreateNamespace: if True, default True, namespaces will be created if mentioned in the name</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the copyTo method may not have not-undoable side-effects to be a proper
implementation</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">undo could be implemented for dg nodes - but for reasons of consistency, its disabled here -
who knows how much it will crap out after a while as duplicate is not undoable (mel command)  -
it never really worked to undo a mel command from within python, executed using a dgmodifier - unfortunately
it does not return any result making it hard to find the newly duplicated object !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.getDifference">
<tt class="descname">getDifference</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.getDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>return the result of <tt class="docutils literal"><span class="pre">self</span> <span class="pre">minus</span> <span class="pre">objects</span></tt>, thus objects will be substracted from our obejcts</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; see <cite>union</cite></li>
<li><em>sets_are_members</em> &#8211; see <cite>union</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MSelectionList containing objects of self not being in objects list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.getIntersection">
<tt class="descname">getIntersection</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.getIntersection" title="Permalink to this definition">¶</a></dt>
<dd><p>As <cite>union</cite>, but returns the intersection ( items in common ) of this 
set with objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; see <cite>union</cite></li>
<li><em>sets_are_members</em> &#8211; see <cite>union</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MSelectionList of objects being in self and in objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.ObjectSet.getMFnClasses">
<em class="property">classmethod </em><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.getMembers">
<tt class="descname">getMembers</tt><big>(</big><em>flatten=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.getMembers" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MSelectionList with members of this set</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>flatten</em> &#8211; if True, members that are objectSets themselves will be resolved to their 
respective members</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the members are ordinary api objects that still need to be wrapped</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">use iterMembers to iterate the members as wrapped Nodes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.getUnion">
<tt class="descname">getUnion</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.getUnion" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a union of the given items with the members of this set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; an ObjectSet, an MObject of an object set, a list of ObjectSets 
or a list of wrapped Objects or an MSelectionList or a single wrapped object . 
If you have objects in a list as well as sets
themselves, objects must come first as the operation will fail otherwise.</li>
<li><em>sets_are_members</em> &#8211; if True, objects can contain sets, but they should not be treated 
as sets to apply the set operation with, they should simply be members of this set, and 
thus need to be wrapped into a tmp set as well</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MSelectionList of all objects of self and objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.hasFn">
<tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.intersection">
<tt class="descname">intersection</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>As <cite>union</cite>, but returns the intersection ( items in common ) of this 
set with objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; see <cite>union</cite></li>
<li><em>sets_are_members</em> &#8211; see <cite>union</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MSelectionList of objects being in self and in objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isAlive">
<tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isMember">
<tt class="descname">isMember</tt><big>(</big><em>obj</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5e387a0&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isMember" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if obj is a member of this set</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>component</em> &#8211; is given, the component must be fully part of the set 
for the object ( dagNode ) to be considered part of the set</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">all keywords of <cite>it.iterSelectionList</cite> are supported</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">ismember does not appear to be working properly with component assignments.
It returns true for components that are not actually in the givne shading group</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isMemberOf">
<tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5c1d740&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.isValid">
<tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are NOT valid, but alive</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.iterDifference">
<tt class="descname">iterDifference</tt><big>(</big><em>setOrSetsOrObjects</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.iterDifference" title="Permalink to this definition">¶</a></dt>
<dd><p>As difference, but returns an iterator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; passed to it.iterSelectionList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.iterIntersection">
<tt class="descname">iterIntersection</tt><big>(</big><em>setOrSetsOrObjects</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.iterIntersection" title="Permalink to this definition">¶</a></dt>
<dd><p>As intersection, but returns an iterator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; passed to it.iterSelectionList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.iterMembers">
<tt class="descname">iterMembers</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.iterMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate members of this set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">All keywords of iterMembers are supported</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if &#8216;handlePlugs&#8217; is False, the iteration using a filter type will be faster</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">handleComponents will allow component iteration - see the iterator documentation</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.iterUnion">
<tt class="descname">iterUnion</tt><big>(</big><em>setOrSetsOrObjects</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.iterUnion" title="Permalink to this definition">¶</a></dt>
<dd><p>As union, but returns an iterator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; passed to it.iterSelectionList</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.members">
<tt class="descname">members</tt><big>(</big><em>flatten=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.members" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MSelectionList with members of this set</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>flatten</em> &#8211; if True, members that are objectSets themselves will be resolved to their 
respective members</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the members are ordinary api objects that still need to be wrapped</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">use iterMembers to iterate the members as wrapped Nodes</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.object">
<tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MObject attached to this Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">parent of this path, &#8216;/hello/world&#8217; -&gt; &#8216;/hello&#8217; or None if this path
is the dag&#8217;s root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.partitions">
<tt class="descname">partitions</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.partitions" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of Nodes of partitions the entity is set is part of</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.referenceFile">
<tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.removeAttribute">
<tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.removeFrom">
<tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5b41420&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.removeMember">
<tt class="descname">removeMember</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.removeMember" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the member from the set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>member</em> &#8211; member of the list, for types see <cite>addMember</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.removeMembers">
<tt class="descname">removeMembers</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.removeMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove items from iterable or selection list from this set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>nodes</em> &#8211; see <cite>addMembers</cite></td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.rename">
<tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.setLocked">
<tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.setMembers">
<tt class="descname">setMembers</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.setMembers" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust set membership for nodes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>nodes</em> &#8211; items to handle, supports everything that <cite>addMembers</cite> does</li>
<li><em>kwargs</em> &#8211; arguments passed to <cite>addMembers</cite> or <cite>removeMembers</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.setNamespace">
<tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.setPartition">
<tt class="descname">setPartition</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.setPartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Add, add exclusive or remove the given partition from our partition list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>partition</em> &#8211; Node, representing the partition, or a list of such</li>
<li><em>mode</em> &#8211; <ul>
<li>0 = replace</li>
<li>1 = add</li>
<li>2 = remove</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self for chained operations</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">use the supplied enumeration to specify the mode</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.sets">
<tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.ObjectSet.tmpSet">
<em class="property">classmethod </em><tt class="descname">tmpSet</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.tmpSet" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">temporary set that will delete itself once it&#8217;s reference count
reaches 0. Use rval.setobj to access the actual set, as the returned object is 
just a hanlde to it. The handle is a valid input to the set functions as well</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; see <cite>union</cite></li>
<li><em>sets_are_members</em> &#8211; see <cite>union</cite></li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">useful if you want to use the set member union, intersection or substraction 
methods efficiently on many sets in a row - these internally operate on a set, thus 
it is faster to use them with another set from the beginning to prevent creation of intermediate 
sets</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.ObjectSet.union">
<tt class="descname">union</tt><big>(</big><em>objects</em>, <em>sets_are_members=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.ObjectSet.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a union of the given items with the members of this set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>objects</em> &#8211; an ObjectSet, an MObject of an object set, a list of ObjectSets 
or a list of wrapped Objects or an MSelectionList or a single wrapped object . 
If you have objects in a list as well as sets
themselves, objects must come first as the operation will fail otherwise.</li>
<li><em>sets_are_members</em> &#8211; if True, objects can contain sets, but they should not be treated 
as sets to apply the set operation with, they should simply be members of this set, and 
thus need to be wrapped into a tmp set as well</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">MSelectionList of all objects of self and objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#PyPickleData">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.PyPickleData">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">PyPickleData</tt><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">maya.OpenMayaMPx.MPxData</span></tt></p>
<p>Allows to access a pickled data object natively within a maya file.
In ascii mode, the pickle will be encoded into string data, in binary mode
the cPickle will be taken in its original value.</p>
<p>To get the respective dict-references back, we use a tracking dict as proposed
by the API Docs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This datatype is copies the data by reference which is why maya always calls
the copy constructor, even if you retrieve a const data reference, where this would not be
required actually. This is fine for most uses</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">as the datatype is reference based, undo is currently not supported (or does not
work as it is expected to do</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.copy">
<tt class="descname">copy</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.copy" title="Permalink to this definition">¶</a></dt>
<dd>Copy other into self - allows copy pointers as maya copies the data each
time you retrieve it</dd></dl>

<dl class="staticmethod">
<dt id="mrv.maya.nt.storage.PyPickleData.creator">
<em class="property">static </em><tt class="descname">creator</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.creator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.readASCII">
<tt class="descname">readASCII</tt><big>(</big><em>args</em>, <em>lastParsedElement</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.readASCII" title="Permalink to this definition">¶</a></dt>
<dd>Read base64 element and decode to cStringIO, then unpickle</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.readBinary">
<tt class="descname">readBinary</tt><big>(</big><em>inStream</em>, <em>numBytesToRead</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.readBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Read in 4 byte packs to cStringIO, unpickle from there</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">this method is more complicated than it needs be since asCharPtr does not work !
It returns a string of a single char ... which is not the same :) !</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">YES, this is a CUMBERSOME way to deal with bytes ... terrible, thanks maya :), thanks python</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mrv.maya.nt.storage.PyPickleData.thisown">
<tt class="descname">thisown</tt><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.thisown" title="Permalink to this definition">¶</a></dt>
<dd>The membership flag</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.typeId">
<tt class="descname">typeId</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.typeId" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.writeASCII">
<tt class="descname">writeASCII</tt><big>(</big><em>out</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.writeASCII" title="Permalink to this definition">¶</a></dt>
<dd>cPickle to cStringIO, encode with base64 encoding</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.PyPickleData.writeBinary">
<tt class="descname">writeBinary</tt><big>(</big><em>out</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.PyPickleData.writeBinary" title="Permalink to this definition">¶</a></dt>
<dd>cPickle to cStringIO, write in 4 byte packs using ScriptUtil</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage.StorageBase-class.html">Epydoc: mrv.maya.nt.storage.StorageBase</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.StorageBase">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">StorageBase</tt><big>(</big><em>data_prefix=''</em>, <em>maya_node=None</em>, <em>attr_prefix=''</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a title="mrv.interface.iDuplicatable" class="reference external" href="mrv.interface.html#mrv.interface.iDuplicatable"><tt class="xref docutils literal"><span class="pre">mrv.interface.iDuplicatable</span></tt></a></p>
<p>A storage node contains a set of attributes allowing it to store
python data and objects being stored in a pickled format upon file save.
Additionally you can store connections.
Nodes used with this interface must be compatible to the following attribute scheme.
To create that scheme, use <cite>createStorageAttribute</cite></p>
<p><strong>Attribute Setup</strong>:</p>
<div class="highlight-python"><pre>(shortname (description) [data type])
dta (data)[multi compound]
        id (data id)[string]
        type (data type) [int]  # for your own use, store bitflags to specify attribute
        dval (data value) [python pickle]
        dmsg (data message)[multi message]</pre>
</div>
<p><strong>Configuration</strong>:</p>
<div class="highlight-python"><pre>data_prefix: will prefix every value name when setting and getting values - this allows
        several clients to use the same storage attribute (on the same node for example)
        It acts like a namespace
attr_prefix: prefixes the actual maya attribute to access
maya_node: the maya node holding the actual attributes</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">A mrv node should derive from this class to allow easy attribute access of its
own compatible attributes - its designed for flexiblity</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">attribute accepts on the generic attribute should be set by a plugin node when it
creates its attributes</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">should self._node be stored as weakref ?</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="mrv.maya.nt.storage.StorageBase.PyPickleValue">
<em class="property">class </em><tt class="descname">PyPickleValue</tt><big>(</big><em>valueplug</em>, <em>pythondata</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.PyPickleValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">object</span></tt></p>
<p>Wrapper object prividing native access to the wrapped python pickle object
and to the corresponding value plug, providing utlity methods for easier handling</p>
<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.PyPickleValue.isReferenced">
<tt class="descname">isReferenced</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.PyPickleValue.isReferenced" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the data is from a referenced plug</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.StorageBase.addSep">
<em class="property">classmethod </em><tt class="descclassname">StorageBase.</tt><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.attributePrefix">
<tt class="descclassname">StorageBase.</tt><tt class="descname">attributePrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.attributePrefix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our attribute prefix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.basename">
<tt class="descclassname">StorageBase.</tt><tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.children">
<tt class="descclassname">StorageBase.</tt><tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c2ed8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of intermediate children of path, [ child1 , child2 ]</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; return True to include x in result</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the child objects returned are supposed to be valid paths, not just relative paths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.childrenDeep">
<tt class="descclassname">StorageBase.</tt><tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.clearAllData">
<tt class="descclassname">StorageBase.</tt><tt class="descname">clearAllData</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.clearAllData" title="Permalink to this definition">¶</a></dt>
<dd><p>see <tt class="docutils literal"><span class="pre">clearAllData</span></tt> module level method
:note: use this method if you want to make sure your node</p>
<blockquote>
is empty after it has been duplicated (would usually be done in the postContructor</blockquote>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.clearData">
<tt class="descclassname">StorageBase.</tt><tt class="descname">clearData</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.clearData" title="Permalink to this definition">¶</a></dt>
<dd>Clear all data stored in the given dataID</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.copyFrom">
<tt class="descclassname">StorageBase.</tt><tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all values from other to ourselves</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>shallow:</dt>
<dd>if True, default False, only a shallow copy will
be made. If False, a deep copy will be made</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only does so if the attribute and data prefixes actually match (which should be
the case if we get here, checking for it anyway</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">as pickle data always copies by reference to be efficient, we have to explicitly
create new data to assure we really copy it</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">copy connections to our messages as well, make it an option at least</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.copyTo">
<tt class="descclassname">StorageBase.</tt><tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.copyToOther">
<tt class="descclassname">StorageBase.</tt><tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.createInstance">
<tt class="descclassname">StorageBase.</tt><tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.createInstance" title="Permalink to this definition">¶</a></dt>
<dd>Create a new instance with our type</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.dataIDs">
<tt class="descclassname">StorageBase.</tt><tt class="descname">dataIDs</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.dataIDs" title="Permalink to this definition">¶</a></dt>
<dd>see module level function with the same name</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.dataPrefix">
<tt class="descclassname">StorageBase.</tt><tt class="descname">dataPrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.dataPrefix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our data prefix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.deleteObjectSet">
<tt class="descclassname">StorageBase.</tt><tt class="descname">deleteObjectSet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.deleteObjectSet" title="Permalink to this definition">¶</a></dt>
<dd>See the module level method called <tt class="docutils literal"><span class="pre">deleteObjectSet</span></tt></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.duplicate">
<tt class="descclassname">StorageBase.</tt><tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a c-style copy constructor by creating a new instance of self
and applying the <cite>copyFrom</cite> methods from base to all classes implementing the copyfrom
method. Thus we will call the method directly on the class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>args</em> &#8211; passed to <cite>copyFrom</cite> and <cite>createInstance</cite> method to give additional directions</li>
<li><em>kwargs</em> &#8211; see param args</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.findStoragePlug">
<tt class="descclassname">StorageBase.</tt><tt class="descname">findStoragePlug</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.findStoragePlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">compound plug with given dataID or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.fullChildName">
<tt class="descclassname">StorageBase.</tt><tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.isPartOf">
<tt class="descclassname">StorageBase.</tt><tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.isRoot">
<tt class="descclassname">StorageBase.</tt><tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.isRootOf">
<tt class="descclassname">StorageBase.</tt><tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.iterParents">
<tt class="descclassname">StorageBase.</tt><tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.makePlug">
<tt class="descclassname">StorageBase.</tt><tt class="descname">makePlug</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.makePlug" title="Permalink to this definition">¶</a></dt>
<dd>see <tt class="docutils literal"><span class="pre">makePlug</span></tt> module level function</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.masterPlug">
<tt class="descclassname">StorageBase.</tt><tt class="descname">masterPlug</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.masterPlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">master plug according to our attributePrefix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.objectSet">
<tt class="descclassname">StorageBase.</tt><tt class="descname">objectSet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.objectSet" title="Permalink to this definition">¶</a></dt>
<dd>see module level <tt class="docutils literal"><span class="pre">objectSet</span></tt> function</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.parent">
<tt class="descclassname">StorageBase.</tt><tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">parent of this path, &#8216;/hello/world&#8217; -&gt; &#8216;/hello&#8217; or None if this path
is the dag&#8217;s root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.parentDeep">
<tt class="descclassname">StorageBase.</tt><tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.partition">
<tt class="descclassname">StorageBase.</tt><tt class="descname">partition</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.partition" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">partition Node attached to the sets at dataID or None if state is disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.pythonData">
<tt class="descclassname">StorageBase.</tt><tt class="descname">pythonData</tt><big>(</big><em>dataID</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.pythonData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">PyPickleVal object at the given index (it can be modified natively)</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>dataID</em> &#8211; id of of the data to retrieve</li>
<li><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>index: </dt>
<dd>element number of the plug to retrieve, or -1 to get a new plug.
Plugs will always be created, the given index specifies a logical plug index</dd>
</dl>
</li>
<li>Additionally all arguments supported by <cite>storagePlug</cite></li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.StorageBase.pythonDataFromPlug">
<em class="property">classmethod </em><tt class="descclassname">StorageBase.</tt><tt class="descname">pythonDataFromPlug</tt><big>(</big><em>valplug</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.pythonDataFromPlug" title="Permalink to this definition">¶</a></dt>
<dd><p>Exract the python data using the given plug directly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>valplug</em> &#8211; data value plug containing the plugin data</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">PyPickleData object allowing data access</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.root">
<tt class="descclassname">StorageBase.</tt><tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.setAttributePrefix">
<tt class="descclassname">StorageBase.</tt><tt class="descname">setAttributePrefix</tt><big>(</big><em>prefix</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.setAttributePrefix" title="Permalink to this definition">¶</a></dt>
<dd>Change the prefix with which to access to the actual storage data attributes on our node
to the given string</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.setDataPrefix">
<tt class="descclassname">StorageBase.</tt><tt class="descname">setDataPrefix</tt><big>(</big><em>prefix</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.setDataPrefix" title="Permalink to this definition">¶</a></dt>
<dd>Change the data prefix to the given value string</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.setPartition">
<tt class="descclassname">StorageBase.</tt><tt class="descname">setPartition</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.setPartition" title="Permalink to this definition">¶</a></dt>
<dd>see <tt class="docutils literal"><span class="pre">setPartition</span></tt> function on module level</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.setStorageNode">
<tt class="descclassname">StorageBase.</tt><tt class="descname">setStorageNode</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.setStorageNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set ourselves to use the given storage compatible node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">use this if the path of our instance has changed - otherwise
trying to access functions will fail as the path of our node might be invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.setsByID">
<tt class="descclassname">StorageBase.</tt><tt class="descname">setsByID</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.setsByID" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all object sets stored under the given dataID</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.storageNode">
<tt class="descclassname">StorageBase.</tt><tt class="descname">storageNode</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.storageNode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node actually being used as storage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.storagePlug">
<tt class="descclassname">StorageBase.</tt><tt class="descname">storagePlug</tt><big>(</big><em>dataID</em>, <em>plugType=None</em>, <em>autoCreate=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.storagePlug" title="Permalink to this definition">¶</a></dt>
<dd>see <tt class="docutils literal"><span class="pre">storagePlug</span></tt> module level function</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageBase.supports">
<tt class="descclassname">StorageBase.</tt><tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageBase.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage.StorageNode-class.html">Epydoc: mrv.maya.nt.storage.StorageNode</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.StorageNode">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">StorageNode</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">mrv.maya.nt.DependNode</span></tt>, <a title="mrv.maya.nt.storage.StorageBase" class="reference internal" href="#mrv.maya.nt.storage.StorageBase"><tt class="xref docutils literal"><span class="pre">mrv.maya.nt.storage.StorageBase</span></tt></a></p>
<p>This node can be used as pythonic and easy-to-access value container - it could
be connected to your node, and queried for values actually being queried on your node.
As value container, it can easily be replaced by another one, or keep different sets of information</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the storage node can only use generic attributes and recover them properly during scene reload
if the configuration of the generic attributes have been setup properly - they are unique only per
node type, not per instance of the node type.
Thus it is recommened to use the storage node attribute base on your own custom type that setsup the
generic attributes as it requires during plugin load</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="mrv.maya.nt.storage.StorageNode.PyPickleValue">
<em class="property">class </em><tt class="descname">PyPickleValue</tt><big>(</big><em>valueplug</em>, <em>pythondata</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.PyPickleValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref docutils literal"><span class="pre">object</span></tt></p>
<p>Wrapper object prividing native access to the wrapped python pickle object
and to the corresponding value plug, providing utlity methods for easier handling</p>
<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.PyPickleValue.isReferenced">
<tt class="descname">isReferenced</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.PyPickleValue.isReferenced" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the data is from a referenced plug</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.addAttribute">
<tt class="descclassname">StorageNode.</tt><tt class="descname">addAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.addAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given attribute to the node as local dynamic attribute</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; MObject of attribute or Attribute instance as retrieved from
a plug</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">plug to the newly added attribute</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">This method is explicitly not undoable as attributes are being deleted
in memory right in the moment they are being removed, thus they cannot
reside on the undo queue</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.StorageNode.addSep">
<em class="property">classmethod </em><tt class="descclassname">StorageNode.</tt><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.addTo">
<tt class="descclassname">StorageNode.</tt><tt class="descname">addTo</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5c828e0&gt; &gt;</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.addTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.allocateFlag">
<tt class="descclassname">StorageNode.</tt><tt class="descname">allocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.allocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.apiObject">
<tt class="descclassname">StorageNode.</tt><tt class="descname">apiObject</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.apiObject" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MObject attached to this Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.apiType">
<tt class="descclassname">StorageNode.</tt><tt class="descname">apiType</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.apiType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MFn Type id of the wrapped object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.attributePrefix">
<tt class="descclassname">StorageNode.</tt><tt class="descname">attributePrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.attributePrefix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our attribute prefix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.basename">
<tt class="descclassname">StorageNode.</tt><tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name of this instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">it is mainly for compatability with dagNodes which need this method 
in order to return the name of their leaf node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.children">
<tt class="descclassname">StorageNode.</tt><tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c2ed8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of intermediate children of path, [ child1 , child2 ]</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; return True to include x in result</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the child objects returned are supposed to be valid paths, not just relative paths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.childrenDeep">
<tt class="descclassname">StorageNode.</tt><tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.className">
<tt class="descclassname">StorageNode.</tt><tt class="descname">className</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.className" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.classification">
<tt class="descclassname">StorageNode.</tt><tt class="descname">classification</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.classification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.clearAllData">
<tt class="descclassname">StorageNode.</tt><tt class="descname">clearAllData</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.clearAllData" title="Permalink to this definition">¶</a></dt>
<dd><p>see <tt class="docutils literal"><span class="pre">clearAllData</span></tt> module level method
:note: use this method if you want to make sure your node</p>
<blockquote>
is empty after it has been duplicated (would usually be done in the postContructor</blockquote>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.clearData">
<tt class="descclassname">StorageNode.</tt><tt class="descname">clearData</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.clearData" title="Permalink to this definition">¶</a></dt>
<dd>Clear all data stored in the given dataID</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.connectedSets">
<tt class="descclassname">StorageNode.</tt><tt class="descname">connectedSets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.connectedSets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.connections">
<tt class="descclassname">StorageNode.</tt><tt class="descname">connections</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.connections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">MPlugArray of connected plugs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.copyFrom">
<tt class="descclassname">StorageNode.</tt><tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all values from other to ourselves</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>shallow:</dt>
<dd>if True, default False, only a shallow copy will
be made. If False, a deep copy will be made</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only does so if the attribute and data prefixes actually match (which should be
the case if we get here, checking for it anyway</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">as pickle data always copies by reference to be efficient, we have to explicitly
create new data to assure we really copy it</td>
</tr>
<tr class="field"><th class="field-name">Todo:</th><td class="field-body">copy connections to our messages as well, make it an option at least</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.copyTo">
<tt class="descclassname">StorageNode.</tt><tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.copyToOther">
<tt class="descclassname">StorageNode.</tt><tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.createInstance">
<tt class="descclassname">StorageNode.</tt><tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.createInstance" title="Permalink to this definition">¶</a></dt>
<dd>Create a new instance with our type</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.dataIDs">
<tt class="descclassname">StorageNode.</tt><tt class="descname">dataIDs</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.dataIDs" title="Permalink to this definition">¶</a></dt>
<dd>see module level function with the same name</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.dataPrefix">
<tt class="descclassname">StorageNode.</tt><tt class="descname">dataPrefix</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.dataPrefix" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">our data prefix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.deallocateAllFlags">
<tt class="descclassname">StorageNode.</tt><tt class="descname">deallocateAllFlags</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.deallocateAllFlags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.deallocateFlag">
<tt class="descclassname">StorageNode.</tt><tt class="descname">deallocateFlag</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.deallocateFlag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.delete">
<tt class="descclassname">StorageNode.</tt><tt class="descname">delete</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if the undo queue is enabled, the object becomes invalid, but stays alive until it
drops off the queue</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">if you want to delete many nodes, its more efficient to delete them
using the global <cite>delete</cite> method</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.deleteObjectSet">
<tt class="descclassname">StorageNode.</tt><tt class="descname">deleteObjectSet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.deleteObjectSet" title="Permalink to this definition">¶</a></dt>
<dd>See the module level method called <tt class="docutils literal"><span class="pre">deleteObjectSet</span></tt></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.dependencyInfo">
<tt class="descclassname">StorageNode.</tt><tt class="descname">dependencyInfo</tt><big>(</big><em>attribute</em>, <em>by=True</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.dependencyInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of attributes that given attribute affects or that the given attribute
is affected by
if the attribute turns dirty.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>attribute</em> &#8211; attribute instance or attribute name</li>
<li><em>by</em> &#8211; if false, affected attributes will be returned, otherwise the attributes affecting this one</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">see also <cite>MPlug.affectedByPlugs</cite></p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">USING MEL: as api command and mObject array always crashed on me ... don&#8217;t know :(</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.duplicate">
<tt class="descclassname">StorageNode.</tt><tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate our node and return a wrapped version to it</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>name</em> &#8211; if given, the newly created node will use the given name</li>
<li><em>kwargs</em> &#8211; <ul>
<li>renameOnClash: if Trrue, default True, clashes are prevented by renaming the new node</li>
<li>autocreateNamespace: if True, default True, namespaces will be created if mentioned in the name</li>
</ul>
</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">the copyTo method may not have not-undoable side-effects to be a proper
implementation</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">undo could be implemented for dg nodes - but for reasons of consistency, its disabled here -
who knows how much it will crap out after a while as duplicate is not undoable (mel command)  -
it never really worked to undo a mel command from within python, executed using a dgmodifier - unfortunately
it does not return any result making it hard to find the newly duplicated object !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.findStoragePlug">
<tt class="descclassname">StorageNode.</tt><tt class="descname">findStoragePlug</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.findStoragePlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">compound plug with given dataID or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.fullChildName">
<tt class="descclassname">StorageNode.</tt><tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.StorageNode.getMFnClasses">
<em class="property">classmethod </em><tt class="descclassname">StorageNode.</tt><tt class="descname">getMFnClasses</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.getMFnClasses" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of all function set classes this node supports, most derived
function set comes first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.hasFn">
<tt class="descclassname">StorageNode.</tt><tt class="descname">hasFn</tt><big>(</big><em>mfntype</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.hasFn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if our object supports the given function set type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.isAlive">
<tt class="descclassname">StorageNode.</tt><tt class="descname">isAlive</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.isAlive" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in memory</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are alive, but NOT valid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.isMemberOf">
<tt class="descclassname">StorageNode.</tt><tt class="descname">isMemberOf</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5c1d740&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.isMemberOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is part of setnode</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.isPartOf">
<tt class="descclassname">StorageNode.</tt><tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.isRoot">
<tt class="descclassname">StorageNode.</tt><tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.isRootOf">
<tt class="descclassname">StorageNode.</tt><tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.isValid">
<tt class="descclassname">StorageNode.</tt><tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if the object exists in the scene</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">objects on the undo queue are NOT valid, but alive</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.iterParents">
<tt class="descclassname">StorageNode.</tt><tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.makePlug">
<tt class="descclassname">StorageNode.</tt><tt class="descname">makePlug</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.makePlug" title="Permalink to this definition">¶</a></dt>
<dd>see <tt class="docutils literal"><span class="pre">makePlug</span></tt> module level function</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.masterPlug">
<tt class="descclassname">StorageNode.</tt><tt class="descname">masterPlug</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.masterPlug" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">master plug according to our attributePrefix</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.object">
<tt class="descclassname">StorageNode.</tt><tt class="descname">object</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.object" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the MObject attached to this Node</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.objectSet">
<tt class="descclassname">StorageNode.</tt><tt class="descname">objectSet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.objectSet" title="Permalink to this definition">¶</a></dt>
<dd>see module level <tt class="docutils literal"><span class="pre">objectSet</span></tt> function</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.parent">
<tt class="descclassname">StorageNode.</tt><tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">parent of this path, &#8216;/hello/world&#8217; -&gt; &#8216;/hello&#8217; or None if this path
is the dag&#8217;s root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.parentDeep">
<tt class="descclassname">StorageNode.</tt><tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.partition">
<tt class="descclassname">StorageNode.</tt><tt class="descname">partition</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.partition" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">partition Node attached to the sets at dataID or None if state is disabled</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.pythonData">
<tt class="descclassname">StorageNode.</tt><tt class="descname">pythonData</tt><big>(</big><em>dataID</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.pythonData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">PyPickleVal object at the given index (it can be modified natively)</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>dataID</em> &#8211; id of of the data to retrieve</li>
<li><em>kwargs</em> &#8211; <ul>
<li><dl class="first docutils">
<dt>index: </dt>
<dd>element number of the plug to retrieve, or -1 to get a new plug.
Plugs will always be created, the given index specifies a logical plug index</dd>
</dl>
</li>
<li>Additionally all arguments supported by <cite>storagePlug</cite></li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="mrv.maya.nt.storage.StorageNode.pythonDataFromPlug">
<em class="property">classmethod </em><tt class="descclassname">StorageNode.</tt><tt class="descname">pythonDataFromPlug</tt><big>(</big><em>valplug</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.pythonDataFromPlug" title="Permalink to this definition">¶</a></dt>
<dd><p>Exract the python data using the given plug directly</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>valplug</em> &#8211; data value plug containing the plugin data</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">PyPickleData object allowing data access</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.referenceFile">
<tt class="descclassname">StorageNode.</tt><tt class="descname">referenceFile</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.referenceFile" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">name (str) of file this node is coming from - it could contain
a copy number as {x}</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">will raise if the node is not referenced, use isReferenced to figure
that out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.removeAttribute">
<tt class="descclassname">StorageNode.</tt><tt class="descname">removeAttribute</tt><big>(</big><em>attr</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.removeAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the given attribute from the node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>attr</em> &#8211; see <cite>addAttribute</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.removeFrom">
<tt class="descclassname">StorageNode.</tt><tt class="descname">removeFrom</tt><big>(</big><em>setnode</em>, <em>component=&lt;maya.OpenMaya.MObject; proxy of &lt;Swig Object of type 'MObject *' at 0x5b41420&gt; &gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.removeFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>remove ourselves to the given set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">method is undoable</td>
</tr>
<tr class="field"><th class="field-name">See:</th><td class="field-body"><cite>sets.ObjectSet</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.rename">
<tt class="descclassname">StorageNode.</tt><tt class="descname">rename</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename this node to newname</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>newname</em> &#8211; new name of the node</li>
<li><em>autocreateNamespace</em> &#8211; if true, namespaces given in newpath will be created automatically, otherwise
a RuntimeException will be thrown if a required namespace does not exist</li>
<li><em>renameOnClash</em> &#8211; if true, clashing names will automatically be resolved by adjusting the name</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">renamed node which is the node itself</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">for safety reasons, this node is dagnode aware and uses a dag modifier for them !</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.root">
<tt class="descclassname">StorageNode.</tt><tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setAttributePrefix">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setAttributePrefix</tt><big>(</big><em>prefix</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setAttributePrefix" title="Permalink to this definition">¶</a></dt>
<dd>Change the prefix with which to access to the actual storage data attributes on our node
to the given string</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setDataPrefix">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setDataPrefix</tt><big>(</big><em>prefix</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setDataPrefix" title="Permalink to this definition">¶</a></dt>
<dd>Change the data prefix to the given value string</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setLocked">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setLocked</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setLocked" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock or unloack this node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>state</em> &#8211; if True, the node is locked. Locked nodes cannot be deleted,
renamed or reparented</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you can query the lock state with <cite>isLocked</cite></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setNamespace">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setNamespace</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setNamespace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self after being moved to the given namespace. This will effectively
rename the object.</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>newns</em> &#8211; Namespace instance to put this Node into</li>
<li><em>kwargs</em> &#8211; to be passed to <cite>rename</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setPartition">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setPartition</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setPartition" title="Permalink to this definition">¶</a></dt>
<dd>see <tt class="docutils literal"><span class="pre">setPartition</span></tt> function on module level</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setStorageNode">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setStorageNode</tt><big>(</big><em>node</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setStorageNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set ourselves to use the given storage compatible node</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">use this if the path of our instance has changed - otherwise
trying to access functions will fail as the path of our node might be invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.sets">
<tt class="descclassname">StorageNode.</tt><tt class="descname">sets</tt><big>(</big><em>setFilter=(459</em>, <em>False</em>, <em>0)</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.sets" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of object set compatible Nodes having self as member</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>setFilter</em> &#8211; tuple(apiType, use_exact_type) - the combination of the
desired api type and the exact type flag allow precise control whether you which
to get only renderable shading engines, only objectfSets (tuple[1] = True),
or all objects supporting the given object type.
Its preset to only return shading engines</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the returned sets order is defined by the order connections to instObjGroups</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">only sets will be returned that have the whole object as member, thus you will not
see sets having component assignments like per-compoent shader assignments or deformer sets</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.setsByID">
<tt class="descclassname">StorageNode.</tt><tt class="descname">setsByID</tt><big>(</big><em>dataID</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.setsByID" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all object sets stored under the given dataID</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.storageNode">
<tt class="descclassname">StorageNode.</tt><tt class="descname">storageNode</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.storageNode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">Node actually being used as storage</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.storagePlug">
<tt class="descclassname">StorageNode.</tt><tt class="descname">storagePlug</tt><big>(</big><em>dataID</em>, <em>plugType=None</em>, <em>autoCreate=False</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.storagePlug" title="Permalink to this definition">¶</a></dt>
<dd>see <tt class="docutils literal"><span class="pre">storagePlug</span></tt> module level function</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.StorageNode.supports">
<tt class="descclassname">StorageNode.</tt><tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.StorageNode.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p><a class="reference external" href="api/mrv.maya.nt.storage-module.html#iDuplicatable">Epydoc: mrv.maya.nt.storage</a></p>
<dl class="class">
<dt id="mrv.maya.nt.storage.iDuplicatable">
<em class="property">class </em><tt class="descclassname">mrv.maya.nt.storage.</tt><tt class="descname">iDuplicatable</tt><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a title="mrv.interface.Interface" class="reference external" href="mrv.interface.html#mrv.interface.Interface"><tt class="xref docutils literal"><span class="pre">mrv.interface.Interface</span></tt></a></p>
<p>Simple interface allowing any class to be properly duplicated</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">to implement this interface, implement <cite>createInstance</cite> and
<cite>copyFrom</cite> in your class</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="mrv.maya.nt.storage.iDuplicatable.addSep">
<em class="property">classmethod </em><tt class="descname">addSep</tt><big>(</big><em>item</em>, <em>sep</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.addSep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">item with separator added to it ( just once )</p>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first">operates best on strings</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>item</em> &#8211; item to add separator to</li>
<li><em>sep</em> &#8211; the separator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.basename">
<tt class="descname">basename</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.basename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">basename of this path, &#8216;/hello/world&#8217; -&gt; &#8216;world&#8217;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.children">
<tt class="descname">children</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c2ed8&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.children" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">list of intermediate children of path, [ child1 , child2 ]</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; return True to include x in result</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">the child objects returned are supposed to be valid paths, not just relative paths</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.childrenDeep">
<tt class="descname">childrenDeep</tt><big>(</big><em>order=1</em>, <em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5050&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.childrenDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of all children of path, [ child1 , child2 ]</p>
</td>
</tr>
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><em>order</em> &#8211; order enumeration</li>
<li><em>predicate</em> &#8211; returns true if x may be returned</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">the child objects returned are supposed to be valid paths, not just relative paths</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.copyFrom">
<tt class="descname">copyFrom</tt><big>(</big><em>other</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the data from other into self as good as possible
Only copy the data that is unique to your specific class - the data of other
classes will be taken care of by them !</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.copyTo">
<tt class="descname">copyTo</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.copyTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the values of ourselves onto the given instance which must be an
instance of our class to be compatible.
Only the common classes will be copied to instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">altered instance</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">instance will be altered during the process</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.copyToOther">
<tt class="descname">copyToOther</tt><big>(</big><em>instance</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.copyToOther" title="Permalink to this definition">¶</a></dt>
<dd>As <cite>copyTo</cite>, but does only require the objects to have a common base.
It will match the actually compatible base classes and call <cite>copyFrom</cite>
if possible.
As more checking is performed, this method performs worse than <cite>copyTo</cite></dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.createInstance">
<tt class="descname">createInstance</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.createInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and Initialize an instance of self.__class__( ... ) based on your own data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">new instance of self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">using self.__class__ instead of an explicit class allows derived
classes that do not have anything to duplicate just to use your implementeation</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">you must support <tt class="docutils literal"><span class="pre">args</span></tt> and <tt class="docutils literal"><span class="pre">kwargs</span></tt> if one of your iDuplicate bases does</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.duplicate">
<tt class="descname">duplicate</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements a c-style copy constructor by creating a new instance of self
and applying the <cite>copyFrom</cite> methods from base to all classes implementing the copyfrom
method. Thus we will call the method directly on the class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>args</em> &#8211; passed to <cite>copyFrom</cite> and <cite>createInstance</cite> method to give additional directions</li>
<li><em>kwargs</em> &#8211; see param args</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.fullChildName">
<tt class="descname">fullChildName</tt><big>(</big><em>childname</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.fullChildName" title="Permalink to this definition">¶</a></dt>
<dd>Add the given name to the string version of our instance
:return: string with childname added like name _sep childname</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.isPartOf">
<tt class="descname">isPartOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.isPartOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if self is a part of other, and thus can be found in other</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings only</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.isRoot">
<tt class="descname">isRoot</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.isRoot" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this path is the root of the DAG</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.isRootOf">
<tt class="descname">isRootOf</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.isRootOf" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True other starts with self</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">operates on strings</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">we assume other has the same type as self, thus the same separator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.iterParents">
<tt class="descname">iterParents</tt><big>(</big><em>predicate=&lt;function &lt;lambda&gt; at 0x7f41dd7c5230&gt;</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.iterParents" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">generator retrieving all parents up to the root</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>predicate</em> &#8211; returns True for all x that you want to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.parent">
<tt class="descname">parent</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.parent" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">parent of this path, &#8216;/hello/world&#8217; -&gt; &#8216;/hello&#8217; or None if this path
is the dag&#8217;s root</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.parentDeep">
<tt class="descname">parentDeep</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.parentDeep" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">all parents of this path, &#8216;/hello/my/world&#8217; -&gt; [ &#8216;/hello/my&#8217;,&#8217;/hello&#8217; ]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.root">
<tt class="descname">root</tt><big>(</big><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.root" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">the root of the DAG - it has no further parents</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mrv.maya.nt.storage.iDuplicatable.supports">
<tt class="descname">supports</tt><big>(</big><em>interface_type</em><big>)</big><a class="headerlink" href="#mrv.maya.nt.storage.iDuplicatable.supports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">True if this instance supports the interface of the given type</td>
</tr>
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>interface_type</em> &#8211; Type of the interface you require this instance 
to support</td>
</tr>
<tr class="field"><th class="field-name">Note:</th><td class="field-body">Must be used in case you only have a weak reference of your interface
instance or proxy which is a case where the ordinary isinstance( obj, iInterface )
will not work</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#"><tt class="docutils literal"><span class="pre">mrv.maya.nt.storage</span></tt></a><ul>
<li><a class="reference external" href="#functions">Functions</a></li>
<li><a class="reference external" href="#classes">Classes</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="mrv.maya.nt.util.html"
                                  title="previous chapter"><tt class="docutils literal docutils literal"><span class="pre">mrv.maya.nt.util</span></tt></a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="mrv.maya.nt.geometry.html"
                                  title="next chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">mrv.maya.nt.geometry</span></tt></a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/generated/mrv.maya.nt.storage.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mrv.maya.nt.geometry.html" title="mrv.maya.nt.geometry"
             >next</a> |</li>
        <li class="right" >
          <a href="mrv.maya.nt.util.html" title="mrv.maya.nt.util"
             >previous</a> |</li>
        <li><a href="../index.html">mrv v1.0.2-develop documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright Sebastian Thiel.
      Last updated on Apr 19, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.5.
    </div>
  </body>
</html>